<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><title>Python │ hh-blog</title><link rel="stylesheet" href="/css/oasis.css"><meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="hh-blog" type="application/atom+xml">
</head><body><div id="content"><h1 id="title">Python</h1><div id="menu-outer"><nav id="menu-inner"><a id="menu-back" href="javascript:history.back()">Back</a><time datetime="2022-10-31T01:57:20.000Z">2022-10-31</time></nav></div><div id="content-outer"><div id="content-inner"><article id="post"><blockquote>
<p>持续更新</p>
</blockquote>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="变量相关"><a href="#变量相关" class="headerlink" title="变量相关"></a>变量相关</h3><ul>
<li><p>Numbers（数字）</p>
<ul>
<li>int（有符号整型） <em>Python3.X 版本中 long 类型被移除，使用 int 替代。</em></li>
<li>float（浮点型）<ul>
<li>float(‘inf’) 表示正无穷 -float(‘inf’) 或 float(‘-inf’) 表示负无穷 其中，inf 均可以写成 Inf</li>
</ul>
</li>
<li>complex（复数）复数由实数部分和虚数部分构成，可以用 a + bj,或者 complex(a,b) 表示， 复数的实部 a 和虚部 b 都是浮点型。</li>
</ul>
</li>
<li><p>String（字符串）</p>
<ul>
<li><p>u&#x2F;U:表示unicode字符串<br>不是仅仅是针对中文, 可以针对任何的字符串，代表是对字符串进行unicode编码。<br>一般英文字符在使用各种编码下, 基本都可以正常解析, 所以一般不带u；但是中文, 必须表明所需编码, 否则一旦编码转换就会出现乱码。<br>建议所有编码方式采用utf-8，即在py文件开头添加: # coding: utf-8</p>
</li>
<li><p>r&#x2F;R:非转义的原始字符串<br>与普通字符相比，其他相对特殊的字符，其中可能包含转义字符，即那些，反斜杠加上对应字母，表示对应的特殊含义的，比如最常见的”\n”表示换行，”\t”表示Tab等。而如果是以r开头，那么说明后面的字符，都是普通的字符了，即如果是“\n”那么表示一个反斜杠字符，一个字母n，而不是表示换行了。<br>以r开头的字符，常用于正则表达式，对应着re模块。</p>
</li>
<li><p>F-strings python3.6开始支持，类似js的模板字符串</p>
<pre class="language-python" data-language="python"><code class="language-python">str_p <span class="token operator">=</span> <span class="token string-interpolation"><span class="token string">f'顺子是</span><span class="token interpolation"><span class="token punctuation">&#123;</span>add_string<span class="token punctuation">(</span><span class="token builtin">str</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span></span><span class="token string">'</span></span></code></pre></li>
</ul>
</li>
<li><p>List（列表）</p>
</li>
<li><p>Tuple（元组）</p>
</li>
<li><p>Dictionary（字典），类似js的map和object结合，键值可以为字符串也可以为number</p>
</li>
</ul>
<p>None 是 NoneType 数据类型的唯一值</p>
<p>python中除号用&#x2F;表示，但是和C语言不同的是&#x2F;得到的值总是<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E6%B5%AE%E7%82%B9&spm=1001.2101.3001.7020">浮点</a>数，&#x2F;&#x2F; 两数相除，向下取整</p>
<p>未声明为非局部变量的变量是只读的，（写入只读变量会在最内层作用域中创建一个 <strong>新的</strong> 局部变量，而同名的外部变量保持不变。）</p>
<p>空字符串、空列表、空元组、空字典、空集合均为false</p>
<h3 id="内置类型"><a href="#内置类型" class="headerlink" title="内置类型"></a>内置类型</h3><p><a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/stdtypes.html?highlight=maketrans#text-sequence-type-str">https://docs.python.org/zh-cn/3/library/stdtypes.html?highlight=maketrans#text-sequence-type-str</a></p>
<p>数字类型 — <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/functions.html#int"><code>int</code></a>, <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/functions.html#float"><code>float</code></a>, <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/functions.html#complex"><code>complex</code></a></p>
<p>迭代器类型 — 生成器generator</p>
<p>序列类型 — <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/stdtypes.html?highlight=maketrans#list"><code>list</code></a>, <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/stdtypes.html?highlight=maketrans#tuple"><code>tuple</code></a>, <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/stdtypes.html?highlight=maketrans#range"><code>range</code></a><a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/stdtypes.html?highlight=maketrans#sequence-types-list-tuple-range">¶</a></p>
<p>文本序列类型 — <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/stdtypes.html?highlight=maketrans#str"><code>str</code></a><a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/stdtypes.html?highlight=maketrans#text-sequence-type-str">¶</a></p>
<p>二进制序列</p>
<p>集合类型 — set，frozenset</p>
<p>映射类型 — dict</p>
<p>…</p>
<h3 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h3><p>list() 可以直接把字符串转为字符数组，split方法则不行</p>
<p>chr()函数取整数值作为Unicode码转换为字符，ord() 获取单个字符输出 Unicode 码</p>
<h3 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h3><table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>in &#x2F; not in</td>
<td>成员运算符</td>
</tr>
<tr>
<td>is &#x2F; not is</td>
<td>身份运算符</td>
</tr>
</tbody></table>
<h3 id="基础语句"><a href="#基础语句" class="headerlink" title="基础语句"></a>基础语句</h3><ul>
<li><p>yield语句：与 return 的差别在于会保留执行状态，下次调用会从上次执行点继续执行</p>
</li>
<li><p><code>if</code> 、<code>elif</code> 、<code>else</code>条件控制语句</p>
<p>支持a&lt;x&lt;b这种连比</p>
</li>
<li><p>循环语句：</p>
<ul>
<li><p>while……else</p>
</li>
<li><p>for循环，start默认为0，step默认为1，&lt;stop，不会等于stop</p>
<pre class="language-none"><code class="language-none">for i in range(satrt, stop, step):
    业务逻辑</code></pre></li>
</ul>
<p><code>pass 语句</code> 是 Python 中的空语句，程序执行到此语句直接跳过，不会做任何的操作，仅作占位语句，但它在保持程序结构的完整性方面，有一定价值。</p>
<ul>
<li><p>列表推导式效率远高于for循环语句</p>
<p>out_list &#x3D; [表达式 for 变量 in 列表 条件判断语句等]</p>
<pre class="language-none"><code class="language-none">&gt;&gt;&gt; out_list &#x3D; [i**2 for i in range(10) if i % 2 &#x3D;&#x3D;0]
&gt;&gt;&gt; out_list
[0, 4, 16, 36, 64]</code></pre></li>
</ul>
</li>
<li><p>match…case</p>
<ul>
<li>变量名 <code>_</code> 作为 通配符 并确保目标将总是被匹配，是可选的，如果没有又之前 case 未得到匹配，则会执行一个空操作（no-op）</li>
</ul>
</li>
<li><p>try…except…as… 捕获异常</p>
<pre class="language-none"><code class="language-none">try:
    a&#x3D;1+&quot;b&quot;
except Exception as e:
    print(e)</code></pre>
</li>
<li><p>lambda函数</p>
<pre class="language-none"><code class="language-none">lambda arg1,arg2,arg3… :&lt;表达式&gt;

lambda x, y: x*y；函数输入是x和y，输出是它们的积x*y

lambda:None；函数没有输入参数，输出是None

lambda *args: sum(args); 输入是任意个数的参数，输出是它们的和(隐性要求是输入参数必须能够进行加法运算)

lambda **kwargs: 1；输入是任意键值对参数，输出是1</code></pre></li>
</ul>
<h3 id="数据值传递和引用"><a href="#数据值传递和引用" class="headerlink" title="数据值传递和引用"></a>数据值传递和引用</h3><p>字符串，数值，元组均为静态变量，列表，字典为动态变量。一般静态变量值传递为拷贝，动态变量值传递为引用。利用 id() 可以查看变量存储地址。</p>
<p>注：对静态变量首次传递时也是引用，当需要修改静态变量时，因为静态变量不能改变，所以需要生成一个新的空间存储数据。</p>
<p>所以更准确地说，python中只有引用传递，只不过静态类型不可改变，要改变对应名称的值只能改变其指向的内存地址。</p>
<p><strong>is比较的是两个对象的内存地址是否相等，&#x3D;&#x3D;比较的是两个对象的值是否相等</strong>。</p>
<pre class="language-python" data-language="python"><code class="language-python">a <span class="token operator">=</span> <span class="token number">1</span>
b <span class="token operator">=</span> <span class="token number">1</span>
a <span class="token operator">==</span> b <span class="token comment"># True</span>
a <span class="token keyword">is</span> b <span class="token comment"># True</span>

a <span class="token operator">=</span> <span class="token number">888</span>
b <span class="token operator">=</span> <span class="token number">888</span>
a <span class="token operator">==</span> b <span class="token comment"># True</span>
a <span class="token keyword">is</span> b <span class="token comment"># False</span>

a <span class="token operator">=</span> <span class="token string">'hello'</span>
b <span class="token operator">=</span> <span class="token string">'hello'</span>
a <span class="token keyword">is</span> b <span class="token comment"># True</span>
a <span class="token operator">==</span> b <span class="token comment"># True</span>

a <span class="token operator">=</span> <span class="token string">'hello world'</span>
b <span class="token operator">=</span> <span class="token string">'hello world'</span>
a <span class="token operator">==</span> b <span class="token comment"># True</span>
a <span class="token keyword">is</span> b <span class="token comment"># False</span></code></pre>

<p>部分代表小整数的对象都会指向小整数池，类似的，Python解释器中使用了 intern（字符串驻留），使值同样的字符串对象仅仅会保存一份，放在一个字符串储蓄池中，是共用的，如果字符串中有空格，默认不启用intern机制。对字符串储蓄池中的字符串使用 is 和 &#x3D;&#x3D; 比较会得到相同的结果。</p>
<p><strong>在shell中，仅有以下划线、数字、字母组成的字符串会被intern。而pycharm中只要是同一个字符串不超过20个字符都被加入到池中</strong></p>
<p>需要严格根据解释环境判断，在IDLE中id都一样。</p>
<p>垃圾回收：引用计数，当某个对象在其作用域内不再被其他对象引用的时候，Python 就自动清除对象；</p>
<p>注意深浅拷贝：</p>
<ul>
<li>a.append(tmp)	a.append(tmp[:])</li>
</ul>
<h3 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h3><p>切片使用2个冒号分隔的3个数字来完成：</p>
<ul>
<li>第一个数字表示切片的开始位置，默认为0</li>
<li>第二个数字表是切片的截止（但不包含）位置（默认为列表长度）</li>
<li>第三个数字表示切片的步长(默认为1)，当步长省略时，顺便可以省略最后一个冒号。</li>
</ul>
<p><code>a[:]</code>是深复制，<code>a</code>是浅复制，相当于赋值<code>a</code>的话是赋值了指针，赋值<code>a[:]</code>相当于复制了<code>a</code>对应的那段空间</p>
<h3 id="解包"><a href="#解包" class="headerlink" title="解包"></a>解包</h3><p>解包赋值，是zip函数的逆操作。</p>
<h2 id="基础数据结构类型"><a href="#基础数据结构类型" class="headerlink" title="基础数据结构类型"></a>基础数据结构类型</h2><h3 id="效率"><a href="#效率" class="headerlink" title="效率"></a>效率</h3><p>list查询是O(n), set是O(1)</p>
<p>增删list到最后一个(append, pop)是O(1), 其他的为O(n), set的增删是O(1)</p>
<p>详见<a target="_blank" rel="noopener" href="https://wiki.python.org/moin/TimeComplexity">https://wiki.python.org/moin/TimeComplexity</a></p>
<h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><p>中括号<code>[]</code>创建一个列表，列表内可含有各种不同类型，包括再嵌套列表。</p>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><ul>
<li><code>append</code>一次添加1个元素，<code>insert</code>在指定位置添加元素</li>
</ul>
<pre class="language-python" data-language="python"><code class="language-python">a<span class="token punctuation">.</span>insert<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span> <span class="token comment"># insert 在索引2处添加元素5</span></code></pre>

<ul>
<li><p><code>remove</code>直接删除元素，若被删除元素在列表内重复出现多次，则只删除第一次</p>
</li>
<li><p><code>pop</code>方法若不带参数默认删除列表最后一个元素；若带参数则删除此参数代表的索引处的元素</p>
</li>
<li><p>remove方法</p>
<p>移除列表第一个匹配项</p>
</li>
</ul>
<pre class="language-python" data-language="python"><code class="language-python"><span class="token comment">#移除list1中第一个值为1的项</span>
list1<span class="token punctuation">.</span>remove<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span></code></pre>

<ul>
<li><p>extend方法</p>
<p>list.extend(L)</p>
<p>通过将所有元素追加到已知list来扩充它，相当于a[len(a):]&#x3D; L</p>
</li>
</ul>
<p>列表封装的其他方法还包括如下：</p>
<pre class="language-none"><code class="language-none">&#96;clear&#96;,&#96;index&#96;,&#96;count&#96;,&#96;sort&#96;,&#96;reverse&#96;,&#96;copy</code></pre>



<h3 id="tuple"><a href="#tuple" class="headerlink" title="tuple"></a>tuple</h3><p>元组是一类不允许添加删除元素的特殊列表，也就是一旦创建后续决不允许增加、删除、修改。</p>
<p><code>()</code>创建元组。</p>
<h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p>基本用法 set是一种里面不能含有重复元素的数据结构，这种特性天然的使用于列表的去重。</p>
<h4 id="创建set"><a href="#创建set" class="headerlink" title="创建set"></a>创建set</h4><p><strong>此为python2语法</strong></p>
<pre class="language-idl" data-language="idl"><code class="language-idl">&gt;&gt;&gt;x &#x3D; set(&#39;runoob&#39;)
&gt;&gt;&gt; y &#x3D; set(&#39;google&#39;)
&gt;&gt;&gt; x, y
(set([&#39;b&#39;, &#39;r&#39;, &#39;u&#39;, &#39;o&#39;, &#39;n&#39;]), set([&#39;e&#39;, &#39;o&#39;, &#39;g&#39;, &#39;l&#39;]))   # 重复的被删除

&gt;&gt;&gt; x &#x3D; set(&#39;eleven&#39;)
&gt;&gt;&gt; y &#x3D; set(&#39;twelve&#39;)
&gt;&gt;&gt; x,y
(&#123;&#39;l&#39;, &#39;e&#39;, &#39;n&#39;, &#39;v&#39;&#125;, &#123;&#39;e&#39;, &#39;v&#39;, &#39;l&#39;, &#39;t&#39;, &#39;w&#39;&#125;)
&gt;&gt;&gt; x &amp; y  #交集
&#123;&#39;l&#39;, &#39;e&#39;, &#39;v&#39;&#125;
&gt;&gt;&gt; x | y  #并集
&#123;&#39;e&#39;, &#39;v&#39;, &#39;n&#39;, &#39;l&#39;, &#39;t&#39;, &#39;w&#39;&#125;
&gt;&gt;&gt; x - y  #差集
&#123;&#39;n&#39;&#125;
&gt;&gt;&gt; y -x   #差集
&#123;&#39;t&#39;, &#39;w&#39;&#125;
&gt;&gt;&gt; x ^ y  #补集
&#123;&#39;t&#39;, &#39;n&#39;, &#39;w&#39;&#125;
&gt;&gt;&gt; y ^ x  #补集
&#123;&#39;w&#39;, &#39;n&#39;, &#39;t&#39;&#125;</code></pre>

<p>python3中，除了可以使用 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.9/library/stdtypes.html?highlight=set#set"><code>set</code></a> 构造器，非空的 set (不是 frozenset) 还可以通过将以逗号分隔的元素列表包含于花括号之内来创建，例如: <code>&#123;&#39;jack&#39;, &#39;sjoerd&#39;&#125;</code>。</p>
<h4 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h4><p>摘自菜鸟教程，可能过时，建议查看python doc</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>语法格式</th>
<th>功能</th>
<th>实例</th>
</tr>
</thead>
<tbody><tr>
<td>add()</td>
<td>set1.add()</td>
<td>向 set1 集合中添加数字、字符串、元组或者布尔类型</td>
<td>&gt;&gt;&gt; set1 &#x3D; {1,2,3} &gt;&gt;&gt; set1.add((1,2)) &gt;&gt;&gt; set1 {(1, 2), 1, 2, 3}</td>
</tr>
<tr>
<td>clear()</td>
<td>set1.clear()</td>
<td>清空 set1 集合中所有元素</td>
<td>&gt;&gt;&gt; set1 &#x3D; {1,2,3} &gt;&gt;&gt; set1.clear() &gt;&gt;&gt; set1 set()  set()才表示空集合，{}表示的是空字典</td>
</tr>
<tr>
<td>copy()</td>
<td>set2 &#x3D; set1.copy()</td>
<td>拷贝 set1 集合给 set2</td>
<td>&gt;&gt;&gt; set1 &#x3D; {1,2,3} &gt;&gt;&gt; set2 &#x3D; set1.copy() &gt;&gt;&gt; set1.add(4) &gt;&gt;&gt; set1 {1, 2, 3, 4} &gt;&gt;&gt; set1 {1, 2, 3}</td>
</tr>
<tr>
<td>difference()</td>
<td>set3 &#x3D; set1.difference(set2)</td>
<td>将 set1 中有而 set2 没有的元素给 set3</td>
<td>&gt;&gt;&gt; set1 &#x3D; {1,2,3} &gt;&gt;&gt; set2 &#x3D; {3,4} &gt;&gt;&gt; set3 &#x3D; set1.difference(set2) &gt;&gt;&gt; set3 {1, 2}</td>
</tr>
<tr>
<td>difference_update()</td>
<td>set1.difference_update(set2)</td>
<td>从 set1 中删除与 set2 相同的元素</td>
<td>&gt;&gt;&gt; set1 &#x3D; {1,2,3} &gt;&gt;&gt; set2 &#x3D; {3,4} &gt;&gt;&gt; set1.difference_update(set2) &gt;&gt;&gt; set1 {1, 2}</td>
</tr>
<tr>
<td>discard()</td>
<td>set1.discard(elem)</td>
<td>删除 set1 中的 elem 元素</td>
<td>&gt;&gt;&gt; set1 &#x3D; {1,2,3} &gt;&gt;&gt; set1.discard(2) &gt;&gt;&gt; set1 {1, 3} &gt;&gt;&gt; set1.discard(4) {1, 3}</td>
</tr>
<tr>
<td>intersection()</td>
<td>set3 &#x3D; set1.intersection(set2)</td>
<td>取 set1 和 set2 的交集给 set3</td>
<td>&gt;&gt;&gt; set1 &#x3D; {1,2,3} &gt;&gt;&gt; set2 &#x3D; {3,4} &gt;&gt;&gt; set3 &#x3D; set1.intersection(set2) &gt;&gt;&gt; set3 {3}</td>
</tr>
<tr>
<td>intersection_update()</td>
<td>set1.intersection_update(set2)</td>
<td>取 set1和 set2 的交集，并更新给 set1</td>
<td>&gt;&gt;&gt; set1 &#x3D; {1,2,3} &gt;&gt;&gt; set2 &#x3D; {3,4} &gt;&gt;&gt; set1.intersection_update(set2) &gt;&gt;&gt; set1 {3}</td>
</tr>
<tr>
<td>isdisjoint()</td>
<td>set1.isdisjoint(set2)</td>
<td>判断 set1 和 set2 是否没有交集，有交集返回 False；没有交集返回 True</td>
<td>&gt;&gt;&gt; set1 &#x3D; {1,2,3} &gt;&gt;&gt; set2 &#x3D; {3,4} &gt;&gt;&gt; set1.isdisjoint(set2) False</td>
</tr>
<tr>
<td>issubset()</td>
<td>set1.issubset(set2)</td>
<td>判断 set1 是否是 set2 的子集</td>
<td>&gt;&gt;&gt; set1 &#x3D; {1,2,3} &gt;&gt;&gt; set2 &#x3D; {1,2} &gt;&gt;&gt; set1.issubset(set2) False</td>
</tr>
<tr>
<td>issuperset()</td>
<td>set1.issuperset(set2)</td>
<td>判断 set2 是否是 set1 的子集</td>
<td>&gt;&gt;&gt; set1 &#x3D; {1,2,3} &gt;&gt;&gt; set2 &#x3D; {1,2} &gt;&gt;&gt; set1.issuperset(set2) True</td>
</tr>
<tr>
<td>pop()</td>
<td>a &#x3D; set1.pop()</td>
<td>取 set1 中一个元素，并赋值给 a</td>
<td>&gt;&gt;&gt; set1 &#x3D; {1,2,3} &gt;&gt;&gt; a &#x3D; set1.pop() &gt;&gt;&gt; set1 {2,3} &gt;&gt;&gt; a 1</td>
</tr>
<tr>
<td>remove()</td>
<td>set1.remove(elem)</td>
<td>移除 set1 中的 elem 元素</td>
<td>&gt;&gt;&gt; set1 &#x3D; {1,2,3} &gt;&gt;&gt; set1.remove(2) &gt;&gt;&gt; set1 {1, 3} &gt;&gt;&gt; set1.remove(4) Traceback (most recent call last):  File “&lt;pyshell#90&gt;”, line 1, in <module>   set1.remove(4) KeyError: 4</td>
</tr>
<tr>
<td>symmetric_difference()</td>
<td>set3 &#x3D; set1.symmetric_difference(set2)</td>
<td>取 set1 和 set2 中互不相同的元素，给 set3</td>
<td>&gt;&gt;&gt; set1 &#x3D; {1,2,3} &gt;&gt;&gt; set2 &#x3D; {3,4} &gt;&gt;&gt; set3 &#x3D; set1.symmetric_difference(set2) &gt;&gt;&gt; set3 {1, 2, 4}</td>
</tr>
<tr>
<td>symmetric_difference_update()</td>
<td>set1.symmetric_difference_update(set2)</td>
<td>取 set1 和 set2 中互不相同的元素，并更新给 set1</td>
<td>&gt;&gt;&gt; set1 &#x3D; {1,2,3} &gt;&gt;&gt; set2 &#x3D; {3,4} &gt;&gt;&gt; set1.symmetric_difference_update(set2) &gt;&gt;&gt; set1 {1, 2, 4}</td>
</tr>
<tr>
<td>union()</td>
<td>set3 &#x3D; set1.union(set2)</td>
<td>取 set1 和 set2 的并集，赋给 set3</td>
<td>&gt;&gt;&gt; set1 &#x3D; {1,2,3} &gt;&gt;&gt; set2 &#x3D; {3,4} &gt;&gt;&gt; set3&#x3D;set1.union(set2) &gt;&gt;&gt; set3 {1, 2, 3, 4}</td>
</tr>
<tr>
<td>update()</td>
<td>set1.update(elem)</td>
<td>添加列表或集合中的元素到 set1</td>
<td>&gt;&gt;&gt; set1 &#x3D; {1,2,3} &gt;&gt;&gt; set1.update([3,4]) &gt;&gt;&gt; set1 {1,2,3,4}</td>
</tr>
</tbody></table>
<h3 id="dict"><a href="#dict" class="headerlink" title="dict"></a>dict</h3><p>键值可以为数字、字符串甚至是元祖</p>
<p>字典可用多种方式来创建:</p>
<ul>
<li>使用花括号内以逗号分隔 <code>键: 值</code> 对的方式: <code>&#123;&#39;jack&#39;: 4098, &#39;sjoerd&#39;: 4127&#125;</code> or <code>&#123;4098: &#39;jack&#39;, 4127: &#39;sjoerd&#39;&#125;</code></li>
<li>使用字典推导式: <code>&#123;&#125;</code>, <code>&#123;x: x ** 2 for x in range(10)&#125;</code></li>
<li>使用类型构造器: <code>dict()</code>, <code>dict([(&#39;foo&#39;, 100), (&#39;bar&#39;, 200)])</code>, <code>dict(foo=100, bar=200)</code></li>
</ul>
<p>元组可以作为 dict 的 key，但列表不能作为元组的 key。这是由于 dict 要求 key 必须是不可变类型，但列表是可变类型，因此列表不能作为元组的 key。</p>
<p>items()、keys()、values() 分别用于获取字典中的所有 key-value 对、所有 key、所有 value。这三个方法依次返回 dict_items、dict_keys 和 dict_values 对象，Python 不希望用户直接操作这几个方法，但可通过 list() 函数把它们转换成列表。</p>
<ul>
<li>dict.has_key(key)<br>如果键在字典dict里返回true，否则返回false</li>
<li>dict.get(key, default&#x3D;None) 返回指定键的值，如果值不在字典中返回default值</li>
</ul>
<h3 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h3><p>collections.deque()</p>
<p><em>class</em> <code>collections.``deque</code>([<em>iterable</em>[, <em>maxlen</em>]])</p>
<ul>
<li><p><code>append</code>(<em>x</em>)</p>
<p>添加 <em>x</em> 到右端。</p>
</li>
<li><p><code>appendleft</code>(<em>x</em>)</p>
<p>添加 <em>x</em> 到左端。</p>
</li>
<li><p><code>pop</code>()</p>
<p>移去并且返回一个元素，deque 最右侧的那一个。 如果没有元素的话，就引发一个 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/exceptions.html#IndexError"><code>IndexError</code></a>。</p>
</li>
<li><p><code>popleft</code>()</p>
<p>移去并且返回一个元素，deque 最左侧的那一个。 如果没有元素的话，就引发 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/exceptions.html#IndexError"><code>IndexError</code></a>。</p>
</li>
<li><p>Deque对象同样提供了一个只读属性:</p>
<ul>
<li><p><code>maxlen</code></p>
<p>Deque的最大尺寸，如果没有限定的话就是 <code>None</code> 。</p>
</li>
</ul>
</li>
</ul>
<h3 id="Counter"><a href="#Counter" class="headerlink" title="Counter"></a>Counter</h3><h3 id="OrderedDict"><a href="#OrderedDict" class="headerlink" title="OrderedDict"></a>OrderedDict</h3><p>collections. 有序字典</p>
<h3 id="heapq"><a href="#heapq" class="headerlink" title="heapq"></a>heapq</h3><h3 id="defaultdict"><a href="#defaultdict" class="headerlink" title="defaultdict"></a>defaultdict</h3><h3 id="ChainMap"><a href="#ChainMap" class="headerlink" title="ChainMap"></a>ChainMap</h3><h2 id="常用函数、方法"><a href="#常用函数、方法" class="headerlink" title="常用函数、方法"></a>常用函数、方法</h2><pre class="language-none"><code class="language-none">a &#x3D; &#39;123456&#39;
a[2:3]
&#x2F;&#x2F;&#39;3&#39; 冒号前包后不包

string.isdigit() 	
&#x2F;&#x2F;如果 string 只包含数字则返回 True 否则返回 False.

</code></pre>

<h3 id="enumerate"><a href="#enumerate" class="headerlink" title="enumerate()"></a><strong>enumerate()</strong></h3><p>遍历列表(数组)，可以同时获取索引和值，下面是例子</p>
<pre class="language-python" data-language="python"><code class="language-python">arr1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"a"</span><span class="token punctuation">,</span><span class="token string">"b"</span><span class="token punctuation">,</span><span class="token string">"c"</span><span class="token punctuation">,</span><span class="token string">"d"</span><span class="token punctuation">]</span>
<span class="token keyword">for</span> index<span class="token punctuation">,</span>value <span class="token keyword">in</span> <span class="token builtin">enumerate</span><span class="token punctuation">(</span>arr1<span class="token punctuation">)</span><span class="token punctuation">:</span>
	<span class="token keyword">print</span><span class="token punctuation">(</span>index<span class="token punctuation">,</span>value<span class="token punctuation">)</span>

<span class="token comment"># 结果</span>
<span class="token number">0</span> a
<span class="token number">1</span> b
<span class="token number">2</span> c
<span class="token number">3</span> d</code></pre>



<h3 id="json模块"><a href="#json模块" class="headerlink" title="json模块"></a>json模块</h3><p>把字符串转换成字典对象json.loads()</p>
<p>把对象转换成字符串json.dumps()</p>
<p>json.dump(data,file)把字典对象转换成字符串并写入文件</p>
<p>字符串转换成字典对象时，字符串里只能使用双引号</p>
<h3 id="‘’-join-拼接字符串"><a href="#‘’-join-拼接字符串" class="headerlink" title="‘’.join() 拼接字符串"></a>‘’.join() 拼接字符串</h3><pre class="language-python" data-language="python"><code class="language-python">arr <span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">"a"</span><span class="token punctuation">,</span><span class="token string">"b"</span><span class="token punctuation">,</span><span class="token string">"c"</span><span class="token punctuation">]</span>
arr_str <span class="token operator">=</span> <span class="token string">"-"</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>arr<span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>arr_str<span class="token punctuation">)</span>

<span class="token comment"># 输出结果 a-b-c</span>

<span class="token string">''</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>chain<span class="token punctuation">(</span><span class="token operator">*</span>mat<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">//</span>拼接二维矩阵</code></pre>







<h3 id="math-comb"><a href="#math-comb" class="headerlink" title="math.comb()"></a>math.comb()</h3><p>Python中的method方法用于获取从n个项目中选择k个项目(不重复且无顺序)的方法数量</p>
<h3 id="os-path-split-‘PATH’"><a href="#os-path-split-‘PATH’" class="headerlink" title="os.path.split(‘PATH’)"></a>os.path.split(‘PATH’)</h3><p>以 “PATH” 中最后一个 ‘&#x2F;‘ 作为分隔符，分隔后，将索引为0的视为目录（路径），将索引为1的视为文件名</p>
<h3 id="print"><a href="#print" class="headerlink" title="print"></a>print</h3><p> print(i,end&#x3D;’\n’)，可指定末尾字符，默认为换行</p>
<h3 id="product"><a href="#product" class="headerlink" title="product"></a>product</h3><p> product(A,B)函数,返回A和B中的元素组成的<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E7%AC%9B%E5%8D%A1%E5%B0%94%E7%A7%AF&spm=1001.2101.3001.7020">笛卡尔积</a>的元组,具体见如下代码:</p>
<pre class="language-Python" data-language="Python"><code class="language-Python">import itertools
for item in itertools.product([1,2,3,4],[100,200]):
    print(item)
    &#39;&#39;&#39;
(1, 100)
(1, 200)
(2, 100)
(2, 200)
(3, 100)
(3, 200)
(4, 100)
(4, 200)
    &#39;&#39;&#39;
12345678910111213</code></pre>

<p> product(list1,list2)依次取出list1中每1个元素,与list2中的每1个元素,组成元组,将所有元组组合成一个列表返回.</p>
<h3 id="round"><a href="#round" class="headerlink" title="round()"></a>round()</h3><p>四舍五入取整</p>
<h3 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h3><p>Python 列表有一个内置的 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#list.sort"><code>list.sort()</code></a> 方法可以直接修改列表。还有一个 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.10/library/functions.html#sorted"><code>sorted()</code></a> 内置函数，它会从一个可迭代对象构建一个新的排序列表</p>
<pre class="language-none"><code class="language-none">class Student:
    def __init__(self, name, grade, age):
        self.name &#x3D; name
        self.grade &#x3D; grade
        self.age &#x3D; age
    def __repr__(self):
        return repr((self.name, self.grade, self.age))

student_objects &#x3D; [
    Student(&#39;john&#39;, &#39;A&#39;, 15),
    Student(&#39;jane&#39;, &#39;B&#39;, 12),
    Student(&#39;dave&#39;, &#39;B&#39;, 10),
]</code></pre>

<p>Operator 模块函数</p>
<p>上面显示的键函数模式非常常见，因此 Python 提供了便利功能，使访问器功能更容易，更快捷。 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/operator.html#module-operator"><code>operator</code></a> 模块有 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/operator.html#operator.itemgetter"><code>itemgetter()</code></a> 、 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/operator.html#operator.attrgetter"><code>attrgetter()</code></a> 和 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/operator.html#operator.methodcaller"><code>methodcaller()</code></a> 函数。</p>
<p>使用这些函数，上述示例变得更简单，更快捷：</p>
<pre class="language-none"><code class="language-none">&gt;&gt;&gt; from operator import itemgetter, attrgetter

&gt;&gt;&gt; sorted(student_tuples, key&#x3D;itemgetter(2))
[(&#39;dave&#39;, &#39;B&#39;, 10), (&#39;jane&#39;, &#39;B&#39;, 12), (&#39;john&#39;, &#39;A&#39;, 15)]

&gt;&gt;&gt; sorted(student_objects, key&#x3D;attrgetter(&#39;age&#39;))
[(&#39;dave&#39;, &#39;B&#39;, 10), (&#39;jane&#39;, &#39;B&#39;, 12), (&#39;john&#39;, &#39;A&#39;, 15)]</code></pre>

<p>Operator 模块功能允许<strong>多级排序</strong>。 例如，按 <em>grade</em> 排序，然后按 <em>age</em> 排序：</p>
<pre class="language-none"><code class="language-none">&gt;&gt;&gt; sorted(student_tuples, key&#x3D;itemgetter(1,2))
[(&#39;john&#39;, &#39;A&#39;, 15), (&#39;dave&#39;, &#39;B&#39;, 10), (&#39;jane&#39;, &#39;B&#39;, 12)]

&gt;&gt;&gt; sorted(student_objects, key&#x3D;attrgetter(&#39;grade&#39;, &#39;age&#39;))
[(&#39;john&#39;, &#39;A&#39;, 15), (&#39;dave&#39;, &#39;B&#39;, 10), (&#39;jane&#39;, &#39;B&#39;, 12)]</code></pre>

<h4 id="升序和降序"><a href="#升序和降序" class="headerlink" title="升序和降序"></a>升序和降序</h4><p><a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#list.sort"><code>list.sort()</code></a> 和 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/functions.html#sorted"><code>sorted()</code></a> 接受布尔值的 <em>reverse</em> 参数。这用于标记降序排序。 例如，要以反向 <em>age</em> 顺序获取学生数据：</p>
<pre class="language-none"><code class="language-none">&gt;&gt;&gt; sorted(student_tuples, key&#x3D;itemgetter(2), reverse&#x3D;True)
[(&#39;john&#39;, &#39;A&#39;, 15), (&#39;jane&#39;, &#39;B&#39;, 12), (&#39;dave&#39;, &#39;B&#39;, 10)]

&gt;&gt;&gt; sorted(student_objects, key&#x3D;attrgetter(&#39;age&#39;), reverse&#x3D;True)
[(&#39;john&#39;, &#39;A&#39;, 15), (&#39;jane&#39;, &#39;B&#39;, 12), (&#39;dave&#39;, &#39;B&#39;, 10)]</code></pre>

<h4 id="排序稳定性和排序复杂度"><a href="#排序稳定性和排序复杂度" class="headerlink" title="排序稳定性和排序复杂度"></a>排序稳定性和排序复杂度</h4><p>排序保证是 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Sorting_algorithm#Stability">稳定</a> 的。 这意味着当多个记录具有相同的键值时，将保留其原始顺序。</p>
<h3 id="str-isalpha"><a href="#str-isalpha" class="headerlink" title="str.isalpha()"></a>str.isalpha()</h3><p>字符串是否为字母</p>
<h3 id="str-maketrans-intab-outtab"><a href="#str-maketrans-intab-outtab" class="headerlink" title="str.maketrans(intab.outtab)"></a>str.maketrans(intab.outtab)</h3><ul>
<li>intab – 字符串中要替代的字符组成的字符串。</li>
<li>outtab – 相应的映射字符的字符串。</li>
</ul>
<p>内建函数: bytearray.maketrans()、bytes.maketrans()、str.maketrans()</p>
<p>通常和 translate 方法配合使用</p>
<pre class="language-python" data-language="python"><code class="language-python"><span class="token comment">#!/usr/bin/python3</span>
 
intab <span class="token operator">=</span> <span class="token string">"aeiou"</span>
outtab <span class="token operator">=</span> <span class="token string">"12345"</span>
deltab <span class="token operator">=</span> <span class="token string">"thw"</span>
 
trantab1 <span class="token operator">=</span> <span class="token builtin">str</span><span class="token punctuation">.</span>maketrans<span class="token punctuation">(</span>intab<span class="token punctuation">,</span>outtab<span class="token punctuation">)</span> <span class="token comment"># 创建字符映射转换表</span>
trantab2 <span class="token operator">=</span> <span class="token builtin">str</span><span class="token punctuation">.</span>maketrans<span class="token punctuation">(</span>intab<span class="token punctuation">,</span>outtab<span class="token punctuation">,</span>deltab<span class="token punctuation">)</span> <span class="token comment">#创建字符映射转换表，并删除指定字符</span>
 
test <span class="token operator">=</span> <span class="token string">"this is string example....wow!!!"</span>
 
<span class="token keyword">print</span><span class="token punctuation">(</span>test<span class="token punctuation">.</span>translate<span class="token punctuation">(</span>trantab1<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>test<span class="token punctuation">.</span>translate<span class="token punctuation">(</span>trantab2<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre>



<h3 id="str-split"><a href="#str-split" class="headerlink" title="str.split()"></a>str.split()</h3><p>语法：str.split(str&#x3D;” “,num&#x3D;string.count(str))</p>
<p>参数说明：<br>str： 表示为分隔符，默认为空格，但是不能为空串。若字符串中没有分隔符，则把整个字符串作为列表的一个元素。<br>num：表示分割次数。如果存在参数num，则仅分隔成 num+1 个子字符串。</p>
<p>默认空格分隔时会忽略分割后的空串，包括\n\t\r （\r\n表示回车换行）</p>
<pre class="language-none"><code class="language-none">s.split(&#39;.&#39;,-1) #尽可能多的分隔，与不加num参数相同</code></pre>

<p>注意：str为不可变对象，所以此方法不会修改原对象，若需处理分割后的字符串需要转储返回值</p>
<pre class="language-none"><code class="language-none">sNew &#x3D; str.split()</code></pre>



<h3 id="str-strip-chars"><a href="#str-strip-chars" class="headerlink" title="str.strip([chars])"></a>str.strip([chars])</h3><p>strip() 方法用于移除<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%AD%97%E7%AC%A6%E4%B8%B2&spm=1001.2101.3001.7020">字符串</a>头尾指定的字符（默认为空格或换行符）或字符序列。</p>
<p>还有lstrip和rstrip，去除头部或尾部</p>
<h3 id="和"><a href="#和" class="headerlink" title="* 和 **"></a>* 和 **</h3><ul>
<li><code>*args</code>：argument用于列表、元组、集合</li>
<li><code>**kwargs</code>：kwargument用于字典</li>
</ul>
<p>1.解包可迭代对象</p>
<pre class="language-none"><code class="language-none">nums1&#x3D;[*nums1,*nums2]
nums1+&#x3D;nums2
nums1.extend(nums2)</code></pre>



<p>2.函数可变参数</p>
<h2 id="regex"><a href="#regex" class="headerlink" title="regex"></a>regex</h2><p>python3.9文档<a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.9/library/re.html?highlight=re#module-contents">https://docs.python.org/zh-cn/3.9/library/re.html?highlight=re#module-contents</a></p>
<p>re.findall(<em>pattern</em>, <em>string</em>, <em>flags&#x3D;0</em>)</p>
<p>返回字符串中模式的所有非重叠匹配项，作为字符串列表或元组。该字符串从左到右扫描，并按找到的顺序返回匹配项。结果中包含空匹配项。</p>
<p>结果取决于模式中捕获组的数量。如果没有组，则返回匹配整个模式的字符串列表。如果只有一个组，则返回匹配该组的字符串列表。如果存在多个组，则返回与组匹配的字符串元组列表。非捕获组不影响结果的形式。</p>
<pre class="language-none"><code class="language-none">&gt;&gt;&gt;re.findall(r&#39;\bf[a-z]*&#39;, &#39;which foot or hand fell fastest&#39;)
[&#39;foot&#39;, &#39;fell&#39;, &#39;fastest&#39;]
&gt;&gt;&gt; re.findall(r&#39;(\w+)&#x3D;(\d+)&#39;, &#39;set width&#x3D;20 and height&#x3D;10&#39;)
[(&#39;width&#39;, &#39;20&#39;), (&#39;height&#39;, &#39;10&#39;)]</code></pre>

<h3 id="re-sub-pattern-repl-string-count-x3D-0-flags-x3D-0"><a href="#re-sub-pattern-repl-string-count-x3D-0-flags-x3D-0" class="headerlink" title="re.sub(pattern, repl, string, count&#x3D;0, flags&#x3D;0)"></a>re.sub(<em>pattern</em>, <em>repl</em>, <em>string</em>, <em>count&#x3D;0</em>, <em>flags&#x3D;0</em>)</h3><p>返回通过使用 <em>repl</em> 替换在 <em>string</em> 最左边非重叠出现的 <em>pattern</em> 而获得的字符串。 如果样式没有找到，则不加改变地返回 <em>string</em>。 <em>repl</em> 可以是字符串或函数；如为字符串，则其中任何反斜杠转义序列都会被处理。 也就是说，<code>\n</code> 会被转换为一个换行符，<code>\r</code> 会被转换为一个回车符，依此类推。 未知的 ASCII 字符转义序列保留在未来使用，会被当作错误来处理。 其他未知转义序列例如 <code>\&amp;</code> 会保持原样。 向后引用像是 <code>\6</code> 会用样式中第 6 组所匹配到的子字符串来替换。 例如:</p>
<pre class="language-none"><code class="language-none">&gt;&gt;&gt; re.sub(r&#39;def\s+([a-zA-Z_][a-zA-Z_0-9]*)\s*\(\s*\):&#39;,
...        r&#39;static PyObject*\npy_\1(void)\n&#123;&#39;,
...        &#39;def myfunc():&#39;)
&#39;static PyObject*\npy_myfunc(void)\n&#123;&#39;</code></pre>

<p>如果 <em>repl</em> 是一个函数，那它会对每个非重复的 <em>pattern</em> 的情况调用。这个函数只能有一个 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.9/library/re.html?highlight=re#match-objects">匹配对象</a> 参数，并返回一个替换后的字符串。比如</p>
<pre class="language-none"><code class="language-none">&gt;&gt;&gt; def dashrepl(matchobj):
...     if matchobj.group(0) &#x3D;&#x3D; &#39;-&#39;: return &#39; &#39;
...     else: return &#39;-&#39;
&gt;&gt;&gt; re.sub(&#39;-&#123;1,2&#125;&#39;, dashrepl, &#39;pro----gram-files&#39;)
&#39;pro--gram files&#39;
&gt;&gt;&gt; re.sub(r&#39;\sAND\s&#39;, &#39; &amp; &#39;, &#39;Baked Beans And Spam&#39;, flags&#x3D;re.IGNORECASE)
&#39;Baked Beans &amp; Spam&#39;</code></pre>

<p>样式可以是一个字符串或者一个 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.9/library/re.html?highlight=re#re-objects">样式对象</a> 。</p>
<p>可选参数 <em>count</em> 是要替换的最大次数；<em>count</em> 必须是非负整数。如果省略这个参数或设为 0，所有的匹配都会被替换。 样式的空匹配仅在与前一个空匹配不相邻时才会被替换，所以 <code>sub(&#39;x*&#39;, &#39;-&#39;, &#39;abxd&#39;)</code> 返回 <code>&#39;-a-b--d-&#39;</code> 。</p>
<p>在字符串类型的 <em>repl</em> 参数里，如上所述的转义和向后引用中，<code>\g&lt;name&gt;</code> 会使用命名组合 <code>name</code>，（在 <code>(?P&lt;name&gt;…)</code> 语法中定义） <code>\g&lt;number&gt;</code> 会使用数字组；<code>\g&lt;2&gt;</code> 就是 <code>\2</code>，但它避免了二义性，如 <code>\g&lt;2&gt;0</code>。 <code>\20</code> 就会被解释为组20，而不是组2后面跟随一个字符 <code>&#39;0&#39;</code>。向后引用 <code>\g&lt;0&gt;</code> 把 <em>pattern</em> 作为一整个组进行引用。</p>
<h3 id="re-subn-pattern-repl-string-count-x3D-0-flags-x3D-0-¶"><a href="#re-subn-pattern-repl-string-count-x3D-0-flags-x3D-0-¶" class="headerlink" title="re.subn(pattern, repl, string, count&#x3D;0, flags&#x3D;0)¶"></a>re.subn(<em>pattern</em>, <em>repl</em>, <em>string</em>, <em>count&#x3D;0</em>, <em>flags&#x3D;0</em>)<a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.9/library/re.html?highlight=re#re.subn">¶</a></h3><p>行为与 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.9/library/re.html?highlight=re#re.sub"><code>sub()</code></a> 相同，但是返回一个元组 <code>(字符串, 替换次数)</code>.</p>
<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p><a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#nonlocal"><code>nonlocal</code></a> 语句会使得所列出的名称指向之前在最近的包含作用域中绑定的除全局变量以外的变量。</p>
<p><a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#global"><code>global</code></a> 语句是作用于整个当前代码块的声明。 它意味着所列出的标识符将被解读为全局变量。 要给全局变量赋值不可能不用到 <code>global</code> 关键字，不过自由变量也可以指向全局变量而不必声明为全局变量。</p>
<p>在 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#global"><code>global</code></a> 语句中列出的名称不得在同一代码块内该 <code>global</code> 语句之前的位置中使用。</p>
<p>在 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#global"><code>global</code></a> 语句中列出的名称不能被定义为形式参数，也不能被作为 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#with"><code>with</code></a> 语句或 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#except"><code>except</code></a> 子句的目标，以及 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#for"><code>for</code></a> 循环的目标列表、<a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#class"><code>class</code></a> 定义、函数定义、<a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#import"><code>import</code></a> 语句或变量标注等等。</p>
<pre class="language-none"><code class="language-none">def scope_test():
    def do_local():
        spam &#x3D; &quot;local spam&quot;

    def do_nonlocal():
        nonlocal spam
        spam &#x3D; &quot;nonlocal spam&quot;

    def do_global():
        global spam
        spam &#x3D; &quot;global spam&quot;

    spam &#x3D; &quot;test spam&quot;
    do_local()
    print(&quot;After local assignment:&quot;, spam)
    do_nonlocal()
    print(&quot;After nonlocal assignment:&quot;, spam)
    do_global()
    print(&quot;After global assignment:&quot;, spam)

scope_test()
print(&quot;In global scope:&quot;, spam)

输出：
After local assignment: test spam
After nonlocal assignment: nonlocal spam
After global assignment: nonlocal spam
In global scope: global spam</code></pre>



<h2 id="可迭代对象，迭代器，生成器"><a href="#可迭代对象，迭代器，生成器" class="headerlink" title="可迭代对象，迭代器，生成器"></a>可迭代对象，迭代器，生成器</h2><p>常见可迭代对象</p>
<ol>
<li>集合或序列类型（如<code>list</code>、<code>tuple</code>、<code>set</code>、<code>dict</code>、<code>str</code>）</li>
<li>文件对象</li>
<li>在类中定义了<code>__iter__()</code>方法的对象，可以被认为是 <code>Iterable</code>对象，但自定义的可迭代对象要能在<code>for</code>循环中正确使用，就需要保证<code>__iter__()</code>实现必须是正确的（即可以通过内置<code>iter()</code>函数转成<code>Iterator</code>对象。<code>iter()</code>函数是能够将一个可迭代对象转成迭代器对象，然后在<code>for</code>中使用）</li>
<li>在类中实现了如果只实现<code>__getitem__()</code>的对象可以通过<code>iter()</code>函数转化成迭代器但其本身不是可迭代对象。所以当一个对象能够在<code>for</code>循环中运行，但不一定是<code>Iterable</code>对象。</li>
</ol>
<p><code>可迭代对象（Iteratable Object）</code> 是能够一次返回其中一个成员的对象，<strong>都构建了 <code>__iter__</code> 方法</strong></p>
<p><code>迭代器（Iterator）</code> 是同时实现<code>__iter__() 与 __next__()</code> 方法的对象。</p>
<pre class="language-none"><code class="language-none">class IterObj:

    def __init__(self):
        self.a &#x3D; [3, 5, 7, 11, 13, 17, 19]

        self.n &#x3D; len(self.a)
        self.i &#x3D; 0

    def __iter__(self):
        return iter(self.a)

    def __next__(self):
        while self.i &lt; self.n:
            v &#x3D; self.a[self.i]
            self.i +&#x3D; 1
            return v
        else:
            self.i &#x3D; 0
            raise StopIteration()</code></pre>

<p>定义生成器两种方法：</p>
<ol>
<li>列表生成器——生成器表达式</li>
<li>使用<code>yield</code>定义生成器函数——生成器函数</li>
</ol>
<p>Python 中，包含 yield 关键词的普通函数就是生成器。</p>
<p>定义二维数组</p>
<pre class="language-python" data-language="python"><code class="language-python">list_three <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">]</span></code></pre>



<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>对象方法、静态方法、类方法等，归属权分别为obj、cls、cls</p>
<h3 id="基础-1"><a href="#基础-1" class="headerlink" title="基础"></a>基础</h3><p>当（从结尾处）正常离开类定义时，将创建一个 <em>类对象</em>。 这基本上是一个包围在类定义所创建命名空间内容周围的包装器，原始的（在进入类定义之前起作用的）局部作用域将重新生效，类对象将在这里被绑定到类定义头所给出的类名称</p>
<p>任何形式为 <code>__spam</code> 的标识符（至少带有两个前缀下划线，至多一个后缀下划线）的文本将被替换为 <code>_classname__spam</code>，其中 <code>classname</code> 为去除了前缀下划线的当前类名称。 这种改写不考虑标识符的句法位置，只要它出现在类定义内部就会进行。__init__类似构造函数</p>
<pre class="language-none"><code class="language-none">class Student(object):
    ...

    def set_score(self, score):
        self.__score &#x3D; score</code></pre>

<p>以双下划线开头，并且以双下划线结尾的，是特殊变量，特殊变量是可以直接访问的，不是private变量，所以，不能用<code>__name__</code>、<code>__score__</code>这样的变量名</p>
<p>t.ppr()等同于Test.ppr(t)</p>
<pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">ppr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span>

t <span class="token operator">=</span> Test<span class="token punctuation">(</span><span class="token punctuation">)</span>
t<span class="token punctuation">.</span>ppr<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">#Test.ppr(t)</span>

<span class="token comment">#没有传参数，error:</span>
Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>
  File <span class="token string">"cl.py"</span><span class="token punctuation">,</span> line <span class="token number">6</span><span class="token punctuation">,</span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">></span>
    t<span class="token punctuation">.</span>ppr<span class="token punctuation">(</span><span class="token punctuation">)</span>
TypeError<span class="token punctuation">:</span> ppr<span class="token punctuation">(</span><span class="token punctuation">)</span> takes <span class="token number">0</span> positional arguments but <span class="token number">1</span> was given</code></pre>

<p>ins，用来表示调用它的类实例</p>
<p>cls，类</p>
<p>类本身的方法是函数对象，实例的方法是方法对象，实现原理如下：</p>
<p>​	当一个实例的非数据属性被引用时，将搜索实例所属的类。 如果被引用的属性名称表示一个有效的类属性中的函数对象，会通过打包（指向）查找到的实例对象和函数对象到一个抽象对象的方式来创建方法对象：这个抽象对象就是方法对象。 当附带参数列表调用方法对象时，将基于实例对象和参数列表构建一个新的参数列表，并使用这个新参数列表调用相应的函数对象。</p>
<h3 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h3><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Parent</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">pprt</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span>

<span class="token keyword">class</span> <span class="token class-name">Child</span><span class="token punctuation">(</span>Parent<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">cprt</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span>
c <span class="token operator">=</span> Child<span class="token punctuation">(</span><span class="token punctuation">)</span>
c<span class="token punctuation">.</span>cprt<span class="token punctuation">(</span><span class="token punctuation">)</span>
c<span class="token punctuation">.</span>pprt<span class="token punctuation">(</span><span class="token punctuation">)</span>
p <span class="token operator">=</span> Parent<span class="token punctuation">(</span><span class="token punctuation">)</span>
p<span class="token punctuation">.</span>pprt<span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment">#output:</span>
<span class="token operator">&lt;</span>__main__<span class="token punctuation">.</span>Child <span class="token builtin">object</span> at <span class="token number">0x0000000002A47080</span><span class="token operator">></span>
<span class="token operator">&lt;</span>__main__<span class="token punctuation">.</span>Child <span class="token builtin">object</span> at <span class="token number">0x0000000002A47080</span><span class="token operator">></span>
<span class="token operator">&lt;</span>__main__<span class="token punctuation">.</span>Parent <span class="token builtin">object</span> at <span class="token number">0x0000000002A47240</span><span class="token operator">></span></code></pre>





<h3 id="类中的方法："><a href="#类中的方法：" class="headerlink" title="类中的方法："></a>类中的方法：</h3><ul>
<li><code>__init__</code>方法的第一参数永远是<code>self</code>，表示创建的类<strong>实例本身</strong>，因此，在<code>__init__</code>方法内部，就可以把各种属性绑定到self，因为self就指向创建的实例本身。（2）、有了<code>__init__</code>方法，在创建实例的时候，就不能传入空的参数了，必须传入与<code>__init__</code>方法匹配的参数，但self不需要传，Python解释器会自己把实例变量传进去：</li>
</ul>
<p>也分实例属性和类属性，后者所有实例共享</p>
<p><strong>实例属性访问优先级比类属性高</strong></p>
<p>千万不要在实例上修改类属性，它实际上并没有修改类属性，而是给实例绑定了一个实例属性。</p>
<h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><h3 id="解释器信息"><a href="#解释器信息" class="headerlink" title="解释器信息"></a>解释器信息</h3><p>#!&#x2F;usr&#x2F;bin&#x2F;python</p>
<p>分成两种情况：</p>
<p>（1）如果调用 python 脚本时，使用:</p>
<pre class="language-none"><code class="language-none">python script.py </code></pre>

<p>#!&#x2F;usr&#x2F;bin&#x2F;python 被忽略，等同于注释</p>
<p>（2）如果调用python脚本时，使用:</p>
<pre class="language-none"><code class="language-none">.&#x2F;script.py </code></pre>

<p>#!&#x2F;usr&#x2F;bin&#x2F;python 指定解释器的路径</p>
<p>PS：shell 脚本中在第一行也有类似的声明。</p>
<h3 id="复杂类型注解"><a href="#复杂类型注解" class="headerlink" title="复杂类型注解"></a>复杂类型注解</h3><p>List[int]即由int组成的列表，但是，实际中，只要这个列表中存在nt（其他的可以为任何类型），就不会出现警告</p>
<h3 id="模块信息"><a href="#模块信息" class="headerlink" title="模块信息"></a>模块信息</h3><p>__name__</p>
<p>直接执行一段脚本的时候，这段脚本的 **<strong>name</strong>**变量等于 <strong>‘<strong>main</strong>‘<strong>，当这段脚本被导入其他程序的时候，</strong><strong>name</strong></strong> 变量等于脚本本身的名字。</p>
<h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><p>anaconda</p>
<p>一、先创建一个新的虚拟环境</p>
<p>conda create –name my_test python&#x3D;3.7#创建一个名称为my_test的虚拟环境</p>
<p>二、激活虚拟环境</p>
<p>activate my_test</p>
<p>三、切换环境</p>
<p><a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=conda&spm=1001.2101.3001.7020">conda</a> info –env可以看到所有python环境，前面有个‘*’的代表当前环境：</p>
<p>1、查看已有的虚拟环境</p>
<p>conda env list</p>
<p><img src="/Python/v2-2855cfd302e331d8c9a1ee1dfd84d925_720w.webp" alt="img"></p>
<p>2、切换到想要的虚拟环境，这里我切换到my_test</p>
<p>conda activate my_test</p>
<p>3、在当前环境里安装ipykernel</p>
<p>conda install ipykernel</p>
<p><img src="/Python/v2-3fe468e3a7647d138d6054a0c1c641bb_720w.webp" alt="img"></p>
<p>4、python -m ipykernel install –name my_test</p>
<p><img src="/Python/v2-abb56915ea64e5583f1dea223876144c_720w.webp" alt="img"></p>
<p>5、打开jupyter新建一个notebook,如下所示：</p>
<p><img src="/Python/v2-b6ccaa26c129ca4d0e284b645f74bbde_720w.webp" alt="img"></p>
<p>克隆产生新环境，移除旧环境达到更改环境名称的目的</p>
<p><a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=conda&spm=1001.2101.3001.7020">conda</a> create –name python32（新名字） –clone python321（老名字）</p>
<p>conda remove –name old_name –all</p>
<h3 id="mamba"><a href="#mamba" class="headerlink" title="mamba"></a>mamba</h3><p>替代 conda 的包管理系统</p>
<p>Geemap has several optional dependencies, such as <a target="_blank" rel="noopener" href="https://geopandas.org/">GeoPandas</a>, <a target="_blank" rel="noopener" href="https://github.com/banesullivan/localtileserver">localtileserver</a>, <a target="_blank" rel="noopener" href="https://github.com/gboeing/osmnx">osmnx</a>, <a target="_blank" rel="noopener" href="https://github.com/corteva/rioxarray">rioxarray</a> and <a target="_blank" rel="noopener" href="https://github.com/cogeotiff/rio-cogeo">rio-cogeo</a>. It can be a bit cumbersome to install these optional dependencies individually. Luckily, these optional dependencies are available through the <a target="_blank" rel="noopener" href="https://github.com/giswqs/pygis">pygis</a> Python package, which can be installed with a single command. Since pygis has many dependencies, sometimes it can take a while for conda to resolve dependencies. Therefore, we highly recommend you to install <a target="_blank" rel="noopener" href="https://github.com/mamba-org/mamba">Mamba</a>, a fast, robust, and cross-platform package manager. It runs on Windows, macOS, and Linux, and is fully compatible with conda packages and supports most of conda’s commands. The following commands install Mamba and pygis:</p>
<pre class="language-none"><code class="language-none">conda install -c conda-forge mamba
mamba install -c conda-forge geemap pygis</code></pre><div class="post-tags"><a class="post-tag-link" href="/tags/Python/" rel="tag">#Python</a></div></article><div id="paginator"></div></div></div><div id="bottom-outer"><div id="bottom-inner"><hr><div><div><a>2023@ </a><a href="/atom.xml"><img src="/assets/rss.png"></a></div><div id="hexo"><a>Powered by&nbsp</a><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><a>&nbsp&&nbsp</a><a target="_blank" rel="noopener" href="https://github.com/qiantao94/hexo-theme-oasis">Oasis</a></div></div></div></div></div></body><script src="/js/oasis.js"></script></html>