<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><title>Frontend-Engineering │ hh-blog</title><link rel="stylesheet" href="/css/oasis.css"><meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="hh-blog" type="application/atom+xml">
</head><body><div id="content"><h1 id="title">Frontend-Engineering</h1><div id="menu-outer"><nav id="menu-inner"><a id="menu-back" href="javascript:history.back()">Back</a><time datetime="2022-11-02T17:24:13.000Z">2022-11-03</time></nav></div><div id="content-outer"><div id="content-inner"><article id="post"><blockquote>
<p>持续更新</p>
</blockquote>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h2 id="项目构建"><a href="#项目构建" class="headerlink" title="项目构建"></a>项目构建</h2><h3 id="vue-cli"><a href="#vue-cli" class="headerlink" title="vue cli"></a>vue cli</h3><pre class="language-none"><code class="language-none">npm install -g @vue&#x2F;cli
npm install vue@next

vue create project-name</code></pre>

<h3 id="vite"><a href="#vite" class="headerlink" title="vite"></a>vite</h3><pre class="language-none"><code class="language-none">npm create vite@latest
&#x2F;&#x2F;or
yarn create vite
&#x2F;&#x2F;or
pnpm create vite</code></pre>



<h2 id="包管理"><a href="#包管理" class="headerlink" title="包管理"></a>包管理</h2><p>版本号：x.x.x</p>
<ul>
<li><em>主版本号： 当API发生改变，并与之前的版本不兼容的时候</em></li>
<li><em>次版本号： 当增加了功能，但是向后兼容的时候</em></li>
<li><em>补丁版本号： 当做了向后兼容的缺陷修复的时候</em></li>
</ul>
<h3 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h3><p>Node Package Manager</p>
<p>dependencies（生产环境）和 devDependencies（开发环境），前者是项目运行时所需要的包，后者是开发时需要的包例如打包项目的 webpack </p>
<pre class="language-powershell" data-language="powershell"><code class="language-powershell">npm install <span class="token operator">--</span><span class="token function">save-dev</span> packageName
<span class="token comment"># 开发环境简写</span>
npm i <span class="token operator">-</span>D packageName

npm install <span class="token operator">--</span>save packageName
<span class="token comment"># 生产环境简写，也可以不带S</span>
npm i <span class="token operator">-</span>S packageName</code></pre>

<ul>
<li><code>devDependencies</code> 里面的依赖只用于开发环境，不用于生产环境。而 <code>dependencies</code> 依赖的包不仅开发环境能使用，生产环境也能使用。</li>
<li>两种环境的的指定方式是通过配置文件中的<code>NODE_ENV=developement</code>或<code>NODE_ENV=production</code>来指定是开发还是生产环境的。</li>
<li>使用的一些构建工具例如<code>glup、webpack</code>这些只是在开发中使用的包，上线以后就和他们没关系了，所以将它写入<code>devDependencies</code></li>
</ul>
<p>install的tag</p>
<p>标签可以用来提供一个别名，而不是版本号。</p>
<p>例如，一个项目可能会选择有多个开发流，并为每个开发流使用不同的标签，例如，stable、beta、dev、canary。</p>
<p>默认情况下，latest 标签被npm用来识别软件包的当前版本，npm install <pkg>（没有任何@<version>或@<tag>指定符）会安装 latest 标签。通常情况下，项目只对稳定的发布版本使用 latest 标签，而对不稳定的版本（如预发布）使用其他标签。</p>
<p>下一个标签被一些项目用来标识即将发布的版本。</p>
<p>除了 latest ，没有任何标签对npm本身有任何特殊意义。</p>
<p><strong>next标签</strong>：包如果还不够稳定，但是又想给别人测试使用，可以给这种即将上线的包的版本打上next标签。</p>
<p>install 的 package</p>
<p>A <code>package</code> is:</p>
<ul>
<li>a) a folder containing a program described by a <a target="_blank" rel="noopener" href="https://docs.npmjs.com/cli/v8/configuring-npm/package-json"><code>package.json</code></a> file</li>
<li>b) a gzipped tarball containing (a)</li>
<li>c) a url that resolves to (b)</li>
<li>d) a <code>&lt;name&gt;@&lt;version&gt;</code> that is published on the registry (see <a target="_blank" rel="noopener" href="https://docs.npmjs.com/cli/v8/using-npm/registry"><code>registry</code></a>) with (c)</li>
<li>e) a <code>&lt;name&gt;@&lt;tag&gt;</code> (see <a target="_blank" rel="noopener" href="https://docs.npmjs.com/cli/v8/commands/npm-dist-tag"><code>npm dist-tag</code></a>) that points to (d)</li>
<li>f) a <code>&lt;name&gt;</code> that has a “latest” tag satisfying (e)</li>
<li>g) a <code>&lt;git remote url&gt;</code> that resolves to (a)</li>
</ul>
<p>init package信息：</p>
<ul>
<li>“name”：全部小写，没有空格，可以使用下划线或者横线</li>
<li>“version”： x.x.x 的格式，符合 “语义化版本规则”</li>
<li>description：描述信息，有助于搜索</li>
<li>main：入口文件，一般都是 <code>index.js</code></li>
<li>scripts：支持的脚本，默认是一个空的 <code>test</code></li>
<li>keywords：关键字，有助于在人们使用 <code>npm search</code>搜索时发现你的项目<code>author</code> :作者信息</li>
<li>license ：默认是 <code>MIT</code></li>
<li>bugs：当前项目的一些错误信息，如果有的话</li>
</ul>
<p>npm run xxx到底干了什么</p>
<ol>
<li>运行 npm run xxx的时候，npm 会先在当前目录的 node_modules&#x2F;.bin 查找要执行的程序，如果找到则运行；</li>
<li>没有找到则从全局的 node_modules&#x2F;.bin 中查找，npm i -g xxx就是安装到到全局目录；</li>
<li>如果全局目录还是没找到，那么就从 path 环境变量中查找有没有其他同名的可执行程序。</li>
</ol>
<h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><ul>
<li><p>npm shrinkwrap</p>
<p>repurposes <code>package-lock.json</code> into a publishable <code>npm-shrinkwrap.json</code> or simply creates a new one; is unaware of workspaces.</p>
<ul>
<li>when run npm install: <code>npm-shrinkwrap.json</code>&gt;<code>package-lock.json</code>&gt;<code>yarn.lock</code></li>
</ul>
</li>
</ul>
<h4 id="npx"><a href="#npx" class="headerlink" title="npx"></a>npx</h4><p>一个 CLI 工具，其目的是使安装和管理托管在 npm 注册表中的依赖关系变得容易。</p>
<p>能够更方便地安装和运行二进制包，并且还能远程运行 **gist(**Github的一个子服务. 最简单的功能就是分享代码片段，例如把一些小型脚本放到Gist方便分享和管理) 和 <strong>github仓库</strong> 。</p>
<h3 id="yarn"><a href="#yarn" class="headerlink" title="yarn"></a>yarn</h3><ul>
<li><p>yarn upgrade–interactive</p>
<p>更新所有包</p>
</li>
<li></li>
</ul>
<h2 id="前端工程化"><a href="#前端工程化" class="headerlink" title="前端工程化"></a>前端工程化</h2><p>模块化开发，打包引用(分块引用加载速度慢，单块开发难度大，耦合性高)</p>
<ul>
<li><p>使用export default命令，为模块指定默认输出，在import导入时可以随意指定值</p>
<pre class="language-none"><code class="language-none">&#x2F;&#x2F; 文件 test.js
let k; export default k &#x3D; 12; 

&#x2F;&#x2F; 另一个文件
import m from &#39;.&#x2F;test&#39;; &#x2F;&#x2F; 由于 k 是默认导出，所以可以自由使用 import m 替代 import k
console.log(m);        &#x2F;&#x2F; 输出为 12 </code></pre></li>
</ul>
<p>打包(bundle)：常见打包工具webpack，rollup，可以根据模块间依赖关系将多个模块合并为一个文件</p>
<p>组件化：UI组件是一组视图及其交互行为的封装，组件化是将页面(或应用)，按组件拆分模块开发，通过组件的组合拼装实现页面。</p>
<p>Babel：JavaScript编译器，把ES 2015转成低版本JS语法</p>
<p>css预处理器：支持嵌套和格式复用，如Sass、Less、Stylus，在webpack中增加预处理器loader即可。</p>
<h3 id="TS编译相关"><a href="#TS编译相关" class="headerlink" title="TS编译相关"></a>TS编译相关</h3><p>搭配 Babel 和 tsc –watch 使用，前者做文件编译，后者负责类型检查</p>
<pre class="language-json" data-language="json"><code class="language-json"><span class="token comment">// package.json</span>
<span class="token punctuation">&#123;</span>
  ...
  <span class="token comment">// 指定输出文件 dist，指定扩展名 "ts,tsx"</span>
  <span class="token property">"scripts"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>
    <span class="token property">"build"</span><span class="token operator">:</span> <span class="token string">"babel src --out-dir dist --extensions \".ts,.tsx\""</span>
    ...
    <span class="token property">"check-type"</span><span class="token operator">:</span> <span class="token string">"tsc --watch"</span>
  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
  ...
  <span class="token property">"devDependencies"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>
    <span class="token property">"@babel/cli"</span><span class="token operator">:</span> <span class="token string">"^7.13.16"</span><span class="token punctuation">,</span>
    <span class="token property">"@babel/core"</span><span class="token operator">:</span> <span class="token string">"^7.13.16"</span><span class="token punctuation">,</span>
    <span class="token property">"@babel/plugin-proposal-class-properties"</span><span class="token operator">:</span> <span class="token string">"^7.13.0"</span><span class="token punctuation">,</span>  <span class="token comment">// 支持类属性</span>
    <span class="token property">"@babel/plugin-proposal-object-rest-spread"</span><span class="token operator">:</span> <span class="token string">"^7.13.8"</span><span class="token punctuation">,</span> <span class="token comment">// 支持剩余扩展操作符</span>
    <span class="token property">"@babel/preset-env"</span><span class="token operator">:</span> <span class="token string">"^7.13.15"</span><span class="token punctuation">,</span>
    <span class="token property">"@babel/preset-typescript"</span><span class="token operator">:</span> <span class="token string">"^7.13.0"</span> <span class="token comment">// 编译 ts 文件</span>
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// .babellrc</span>
<span class="token punctuation">&#123;</span>
  <span class="token property">"presets"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"@babel/preset-env"</span><span class="token punctuation">,</span> <span class="token string">"@babel/preset-typescript"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token property">"plugins"</span><span class="token operator">:</span> <span class="token punctuation">[</span>
    <span class="token string">"@babel/plugin-proposal-class-properties"</span><span class="token punctuation">,</span>
    <span class="token string">"@babel/plugin-proposal-object-rest-spread"</span>
  <span class="token punctuation">]</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// tsconfig.json</span>
<span class="token punctuation">&#123;</span>
  ...
  <span class="token property">"compilerOptions"</span><span class="token operator">:</span><span class="token punctuation">&#123;</span>
    <span class="token property">"noEmit"</span><span class="token operator">:</span><span class="token boolean">true</span> <span class="token comment">// 不输出文件，只做类型检查</span>
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>同时另开终端运行 npm run check-type 即可</p>
<h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><p>测试金字塔：从低到高是单元测试-&gt;服务测试-&gt;系统测试，越往上测试数量应该越少</p>
<p>测试框架：AVA、TAPE、Jasmine、Jest</p>
<p>测试框架衡量指标：Node端和Browser的支持，并发的支持，库的集成度，社区的活跃度。Jest最常用</p>
<p>三种编写测试用例形式：<code>xxx.test.js</code>, <code>xxx.spec.js</code>, 或者写到<code>__test__</code>文件夹下，正常<code>.js</code>后缀。</p>
<pre class="language-none"><code class="language-none">const delay&#x3D;require(&#39;..&#x2F;index&#39;);

describe(&#39;add 方法测试-__test__&#39;, ()&#x3D;&gt;&#123;
    test(&#39;1+1应该等于2&#39;, ()&#x3D;&gt;&#123;
        const res&#x3D;add(1,1);
        expect(res).toBe(2);
    &#125;)
&#125;)</code></pre>

<p>describe：将几个相关的测试放到一个组中，非必须</p>
<p>test：别名it，测试用例，是测试的最小单位</p>
<p>expect：提供大量matcher来判断方法返回值是否符合特定条件</p>
<p>异步测试避免没有执行到预期代码，在test的执行方法首行加上断言数<code>expect.assertions(num);</code>，主要是针对异步代码的测试。</p>
<p>并且为了避免过早结束在test末尾添加done()方法，并把test的执行方法调入参数done，表示执行到done()方法后才结束。</p>
<p>针对返回类型为 promise 直接 return 最后调用测试的结果即可。如下：</p>
<pre class="language-none"><code class="language-none">const delay&#x3D;require(&#39;..&#x2F;index&#39;);

test(&#39;calllback execute&#39;,done&#x3D;&gt;&#123;
    expect.assertions(1);
    const callback&#x3D;()&#x3D;&gt;&#123;
        console.log(&#39;callback exec&#39;);
        expect(true).toBe(true);
        done();
    &#125;;
    delay(callback);
&#125;);

test(&#39;calllback execute&#39;,()&#x3D;&gt;&#123;
    expect.assertions(1);
    const callback&#x3D;()&#x3D;&gt;1;
    return delayPromise(callback).then(res &#x3D;&gt; &#123;
        expect(res).toBe(1);
    &#125;);
&#125;);</code></pre>

<p>测试覆盖率：在 <code>package.json</code>文件中把<code>scripts</code>行进行修改</p>
<pre class="language-none"><code class="language-none">&quot;scripts&quot;: &#123;
  &quot;test&quot;: &quot;jest --coverage&quot;&#x2F;&#x2F;
&#125;,</code></pre>



<p>jest方法：</p>
<ul>
<li><p>const func &#x3D; jest.<strong>fn</strong>().<strong>mockReturnValue</strong>(1)，生成一个返回值为1的函数。</p>
</li>
<li><p>存在库依赖 jest.spyOn 监视库函数</p>
<pre class="language-none"><code class="language-none">let mockRandom&#x3D;null;
beforeEach(()&#x3D;&gt;&#123;
    mockRandom&#x3D;jest.spyOn(Math, &#39;random&#39;);
&#125;)

afterEach(()&#x3D;&gt;&#123;
    mockRandom.mockRestore();
&#125;)

&#x2F;&#x2F;设置库函数返回值
&#x2F;&#x2F;mockRandom.mockReturnValue(value);</code></pre>
</li>
<li><p>jest.<strong>mock</strong>(‘’)</p>
</li>
</ul>
<h3 id="代码规范"><a href="#代码规范" class="headerlink" title="代码规范"></a>代码规范</h3><p>Eslint 和 Prettier</p>
<h2 id="打包之webpack"><a href="#打包之webpack" class="headerlink" title="打包之webpack"></a>打包之webpack</h2><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p>webpack 默认支持处理 JS 与 JSON 文件，其他类型都处理不了，必须借助 Loader 来对不同类型的文件的进行处理。</p>
<h3 id="配置模块"><a href="#配置模块" class="headerlink" title="配置模块"></a>配置模块</h3><p>Entry：入口，指示 Webpack 应该使用哪个模块，来作为构建其内部 依赖图(dependency graph) 的开始。</p>
<p>Output：输出结果，告诉 Webpack 在哪里输出它所创建的 bundle，以及如何命名这些文件。</p>
<h4 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h4><p>模块，在 Webpack 里一切皆模块，一个模块对应着一个文件。Webpack 会从配置的 Entry 开始递归找出所有依赖的模块。</p>
<p>Chunk：代码块，一个 Chunk 由多个模块组合而成，用于代码合并与分割。</p>
<p>Loader：模块代码转换器，让webpack能够去处理除了JS、JSON之外的其他类型的文件，并将它们转换为有效 模块，以供应用程序使用，以及被添加到依赖图中。</p>
<p>Plugin：扩展插件。在webpack运行的生命周期中会广播出许多事件，plugin可以监听这些事件，在合适的时机通过webpack提供的api改变输出结果。常见的有：打包优化，资源管理，注入环境变量。</p>
<h4 id="Mode"><a href="#Mode" class="headerlink" title="Mode"></a>Mode</h4><p>模式，告知 webpack 使用相应模式的内置优化，默认为 production</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>development</td>
<td>开发模式，打包更加快速，省了代码优化步骤</td>
</tr>
<tr>
<td>production</td>
<td>生产模式，打包比较慢，会开启 tree-shaking 和 压缩代码</td>
</tr>
<tr>
<td>none</td>
<td>不使用任何默认优化选项</td>
</tr>
</tbody></table>
<p>Browser Compatibility：浏览器兼容性，Webpack 支持所有符合 ES5 标准 的浏览器（IE8以上版本）</p>
<h3 id="打包流程"><a href="#打包流程" class="headerlink" title="打包流程"></a>打包流程</h3><p>1、读取<code>webpack</code>的配置参数；</p>
<p>2、启动<code>webpack</code>，创建<code>Compiler</code>对象并开始解析项目；</p>
<p>3、从入口文件（<code>entry</code>）开始解析，并且找到其导入的依赖模块，递归遍历分析，形成依赖关系树；</p>
<p>4、对不同文件类型的依赖模块文件使用对应的<code>Loader</code>进行编译，最终转为<code>Javascript</code>文件；</p>
<p>5、整个过程中<code>webpack</code>会通过发布订阅模式，向外抛出一些<code>hooks</code>，而<code>webpack</code>的插件即可通过监听这些关键的事件节点，执行插件任务进而达到干预输出结果的目的。</p>
<h2 id="NodeJS"><a href="#NodeJS" class="headerlink" title="NodeJS"></a>NodeJS</h2><h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><ul>
<li><strong>__dirname</strong>: 返回当前模块文件解析过后所在的文件夹(目录)的绝对路径。</li>
<li><strong>__filename</strong>: 返回当前模块文件被解析过后的绝对路径。</li>
</ul>
<h2 id="设计架构，框架"><a href="#设计架构，框架" class="headerlink" title="设计架构，框架"></a>设计架构，框架</h2><p>设计系统：设计价值观&#x3D;&gt;设计原则&#x3D;&gt;设计风格规范、组件化	Design Token，实现样式代理、资源代理、结构化设计</p>
<p>框架的作用是为前端UI开发提供另外一种方式，提供良好的代码风格，易于添加测试，组件化开发，服务端和客户端路由</p>
<p>无极设计规范：原子设计方法论，拆解和组合</p>
<p>组件化中遇到的问题：组件化不彻底，无基础组件，复用程度低，单位不统一，语法版本规范弱</p>
<p>MVC，包括视图、控制器、模型</p>
<h3 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h3><p>开发者只需要关心	数据结构	和	视图，抽象层包括视图，视图模型和模型。</p>
<p>实际应用包括Vue、React、San、小程序</p>
<p>真正的区别在于，发布订阅模式实现的是一种多对多的关系，在发布者与订阅者之间需要有一个中介者，发布者发布事件名和参数到中间者，中间者向事件集中的订阅者发送参数。<br>而观察者是一种一对多的关系，所有的在同一被观察者身上绑定的观察者只能接受同一个被观察者的消息。</p>
<p>本质上，观察者模式和发布订阅模式都是对回调函数的松（解）耦合。回调函数是：事件A结束后，执行事件B。观察者模式实现的是：定义好事件A，事件B，通过“观察”这一行为，将事件A和B的因果先后关系关联起来。发布订阅模式实现的是：事件A结束后，发布到事件中心；事件B订阅A，连同后续回调托管到事件中心。事件中心将A和B关联起来。这一过程中，事件A和事件B完全不会受到对方是否存在的影响，是完全解耦合的。</p>
<h3 id="MTV"><a href="#MTV" class="headerlink" title="MTV"></a>MTV</h3><p>model templates view</p>
<p>比如 django </p>
<h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><h3 id="前端-x2F-后端路由"><a href="#前端-x2F-后端路由" class="headerlink" title="前端&#x2F;后端路由"></a>前端&#x2F;后端路由</h3><p>router和route，router 可以理解为一个容器，或者说一种机制，它管理了一组 route。简单来说，route 只是进行了URL和函数的映射，而在当接收到一个URL之后，去路由映射表中查找相应的函数，这个过程由 router 来处理。</p>
<p>服务器端路由和客户端路由：</p>
<ul>
<li>对于服务器来说，当接收到客户端发来的HTTP请求，会根据请求的URL，来找到相应的映射函数，然后执行该函数，并将函数的返回值发送给客户端。在 router 匹配 route 的过程中，不仅会根据URL来匹配，还会根据请求的方法来看是否匹配。如果通过 POST 方法来GET &#x2F;users的内容，就会找不到正确的路由。</li>
<li>对于客户端（通常为浏览器）来说，路由的映射函数通常是进行一些DOM的显示和隐藏操作。这样，当访问不同的路径的时候，会显示不同的页面组件。有基于Hash和History API两种</li>
</ul>
<p>上述路由和渲染概念相近。</p>
<p>前端路由——顾名思义，页面跳转的URL规则匹配由前端来控制。而前端路由主要是有两种显示方式：</p>
<ul>
<li>带有hash的前端路由，优点是兼容性高。缺点是URL带有<code>#</code>号不好看</li>
<li>不带hash的前端路由，优点是URL不带<code>#</code>号，好看。缺点是既需要浏览器支持也需要后端服务器支持</li>
</ul>
<h3 id="hash-x2F-history路由模式"><a href="#hash-x2F-history路由模式" class="headerlink" title="hash&#x2F;history路由模式"></a>hash&#x2F;history路由模式</h3><p>当在url栏中输入新网址，浏览器会直接向服务器请求网址对应的信息。而在已存在网页中点击链接路由时，会进行判断是否需要向服务器请求信息。</p>
<p><strong>hash</strong>：带 # 的url，浏览器向服务器请求 # 后的地址信息，仅向服务器请求url中 # 之前的地址，再由浏览器获取到的前端脚本处理#后的地址信息</p>
<p><strong>history</strong>：不带 # ，正常 &#x2F; 分隔，在已加载页面点击链接进行跳转时不会出现问题，当后端服务器不存在某个路由信息而直接在网址栏输入对其访问会404.</p>
<h2 id="前后端通信-Axios"><a href="#前后端通信-Axios" class="headerlink" title="前后端通信-Axios"></a>前后端通信-Axios</h2><p>基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。</p>
<p>一个通信框架，用于服务器交互；当然也可以使用jQuery提供的AJAX通信功能</p>
<ul>
<li>ajax最早出现的发送后端请求技术，利用用XMLHttpRequest对象。</li>
<li>$.ajax是jQuery中的发送后端请求技术，基于原生Ajax的封装。</li>
<li>Axios不是原生JS的，需要进行安装。它在client-side和server-side都可以使用。也可以在请求和响应阶段进行拦截。它是基于promise对象的。</li>
<li>Fetch号称是AJAX的替代品，使用了ES6中的promise对象。其参数有点像jQuery.ajax。但是fetch不是对ajax的封装，而是原生js实现的，并没有使用XMLHttpRequest对象。</li>
</ul>
<p>axios 中所谓的绝对路径，就是以 <code>&lt;scheme&gt;://</code>（协议头）或者 <code>//</code> 开头的URL，除此之外都算先对路径，都会在头部附加 baseURL</p>
<h3 id="结构信息"><a href="#结构信息" class="headerlink" title="结构信息"></a>结构信息</h3><p>request信息</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token punctuation">&#123;</span>
   <span class="token comment">// `url` 是用于请求的服务器 URL</span>
  <span class="token literal-property property">url</span><span class="token operator">:</span> <span class="token string">'/user'</span><span class="token punctuation">,</span>

  <span class="token comment">// `method` 是创建请求时使用的方法</span>
  <span class="token literal-property property">method</span><span class="token operator">:</span> <span class="token string">'get'</span><span class="token punctuation">,</span> <span class="token comment">// default</span>

  <span class="token comment">// `baseURL` 将自动加在 `url` 前面，除非 `url` 是一个绝对 URL。</span>
  <span class="token comment">// 它可以通过设置一个 `baseURL` 便于为 axios 实例的方法传递相对 URL</span>
  <span class="token literal-property property">baseURL</span><span class="token operator">:</span> <span class="token string">'https://some-domain.com/api/'</span><span class="token punctuation">,</span>

  <span class="token comment">// `transformRequest` 允许在向服务器发送前，修改请求数据</span>
  <span class="token comment">// 只能用在 'PUT', 'POST' 和 'PATCH' 这几个请求方法</span>
  <span class="token comment">// 后面数组中的函数必须返回一个字符串，或 ArrayBuffer，或 Stream</span>
  <span class="token literal-property property">transformRequest</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">data<span class="token punctuation">,</span> headers</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// 对 data 进行任意转换处理</span>
    <span class="token keyword">return</span> data<span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span><span class="token punctuation">]</span><span class="token punctuation">,</span>

  <span class="token comment">// `transformResponse` 在传递给 then/catch 前，允许修改响应数据</span>
  <span class="token literal-property property">transformResponse</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// 对 data 进行任意转换处理</span>
    <span class="token keyword">return</span> data<span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span><span class="token punctuation">]</span><span class="token punctuation">,</span>

  <span class="token comment">// `headers` 是即将被发送的自定义请求头</span>
  <span class="token literal-property property">headers</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span><span class="token string-property property">'X-Requested-With'</span><span class="token operator">:</span> <span class="token string">'XMLHttpRequest'</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>

  <span class="token comment">// `params` 是即将与请求一起发送的 URL 参数</span>
  <span class="token comment">// 必须是一个无格式对象(plain object)或 URLSearchParams 对象</span>
  <span class="token literal-property property">params</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>
    <span class="token constant">ID</span><span class="token operator">:</span> <span class="token number">12345</span>
  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>

   <span class="token comment">// `paramsSerializer` 是一个负责 `params` 序列化的函数</span>
  <span class="token comment">// (e.g. https://www.npmjs.com/package/qs, http://api.jquery.com/jquery.param/)</span>
  <span class="token function-variable function">paramsSerializer</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">params</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> Qs<span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>params<span class="token punctuation">,</span> <span class="token punctuation">&#123;</span><span class="token literal-property property">arrayFormat</span><span class="token operator">:</span> <span class="token string">'brackets'</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>
  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>

  <span class="token comment">// `data` 是作为请求主体被发送的数据</span>
  <span class="token comment">// 只适用于这些请求方法 'PUT', 'POST', 和 'PATCH'</span>
  <span class="token comment">// 在没有设置 `transformRequest` 时，必须是以下类型之一：</span>
  <span class="token comment">// - string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams</span>
  <span class="token comment">// - 浏览器专属：FormData, File, Blob</span>
  <span class="token comment">// - Node 专属： Stream</span>
  <span class="token literal-property property">data</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>
    <span class="token literal-property property">firstName</span><span class="token operator">:</span> <span class="token string">'Fred'</span>
  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>

  <span class="token comment">// `timeout` 指定请求超时的毫秒数(0 表示无超时时间)</span>
  <span class="token comment">// 如果请求话费了超过 `timeout` 的时间，请求将被中断</span>
  <span class="token literal-property property">timeout</span><span class="token operator">:</span> <span class="token number">1000</span><span class="token punctuation">,</span>

   <span class="token comment">// `withCredentials` 表示跨域请求时是否需要使用凭证</span>
  <span class="token literal-property property">withCredentials</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token comment">// default</span>

  <span class="token comment">// `adapter` 允许自定义处理请求，以使测试更轻松</span>
  <span class="token comment">// 返回一个 promise 并应用一个有效的响应 (查阅 [response docs](#response-api)).</span>
  <span class="token function-variable function">adapter</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">config</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">/* ... */</span>
  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>

 <span class="token comment">// `auth` 表示应该使用 HTTP 基础验证，并提供凭据</span>
  <span class="token comment">// 这将设置一个 `Authorization` 头，覆写掉现有的任意使用 `headers` 设置的自定义 `Authorization`头</span>
  <span class="token literal-property property">auth</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>
    <span class="token literal-property property">username</span><span class="token operator">:</span> <span class="token string">'janedoe'</span><span class="token punctuation">,</span>
    <span class="token literal-property property">password</span><span class="token operator">:</span> <span class="token string">'s00pers3cret'</span>
  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>

   <span class="token comment">// `responseType` 表示服务器响应的数据类型，可以是 'arraybuffer', 'blob', 'document', 'json', 'text', 'stream'</span>
  <span class="token literal-property property">responseType</span><span class="token operator">:</span> <span class="token string">'json'</span><span class="token punctuation">,</span> <span class="token comment">// default</span>

  <span class="token comment">// `responseEncoding` indicates encoding to use for decoding responses</span>
  <span class="token comment">// Note: Ignored for `responseType` of 'stream' or client-side requests</span>
  <span class="token literal-property property">responseEncoding</span><span class="token operator">:</span> <span class="token string">'utf8'</span><span class="token punctuation">,</span> <span class="token comment">// default</span>

   <span class="token comment">// `xsrfCookieName` 是用作 xsrf token 的值的cookie的名称</span>
  <span class="token literal-property property">xsrfCookieName</span><span class="token operator">:</span> <span class="token string">'XSRF-TOKEN'</span><span class="token punctuation">,</span> <span class="token comment">// default</span>

  <span class="token comment">// `xsrfHeaderName` is the name of the http header that carries the xsrf token value</span>
  <span class="token literal-property property">xsrfHeaderName</span><span class="token operator">:</span> <span class="token string">'X-XSRF-TOKEN'</span><span class="token punctuation">,</span> <span class="token comment">// default</span>

   <span class="token comment">// `onUploadProgress` 允许为上传处理进度事件</span>
  <span class="token function-variable function">onUploadProgress</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">progressEvent</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// Do whatever you want with the native progress event</span>
  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>

  <span class="token comment">// `onDownloadProgress` 允许为下载处理进度事件</span>
  <span class="token function-variable function">onDownloadProgress</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">progressEvent</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// 对原生进度事件的处理</span>
  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>

   <span class="token comment">// `maxContentLength` 定义允许的响应内容的最大尺寸</span>
  <span class="token literal-property property">maxContentLength</span><span class="token operator">:</span> <span class="token number">2000</span><span class="token punctuation">,</span>

  <span class="token comment">// `validateStatus` 定义对于给定的HTTP 响应状态码是 resolve 或 reject  promise 。如果 `validateStatus` 返回 `true` (或者设置为 `null` 或 `undefined`)，promise 将被 resolve; 否则，promise 将被 rejecte</span>
  <span class="token function-variable function">validateStatus</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">status</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> status <span class="token operator">>=</span> <span class="token number">200</span> <span class="token operator">&amp;&amp;</span> status <span class="token operator">&lt;</span> <span class="token number">300</span><span class="token punctuation">;</span> <span class="token comment">// default</span>
  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>

  <span class="token comment">// `maxRedirects` 定义在 node.js 中 follow 的最大重定向数目</span>
  <span class="token comment">// 如果设置为0，将不会 follow 任何重定向</span>
  <span class="token literal-property property">maxRedirects</span><span class="token operator">:</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token comment">// default</span>

  <span class="token comment">// `socketPath` defines a UNIX Socket to be used in node.js.</span>
  <span class="token comment">// e.g. '/var/run/docker.sock' to send requests to the docker daemon.</span>
  <span class="token comment">// Only either `socketPath` or `proxy` can be specified.</span>
  <span class="token comment">// If both are specified, `socketPath` is used.</span>
  <span class="token literal-property property">socketPath</span><span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token comment">// default</span>

  <span class="token comment">// `httpAgent` 和 `httpsAgent` 分别在 node.js 中用于定义在执行 http 和 https 时使用的自定义代理。允许像这样配置选项：</span>
  <span class="token comment">// `keepAlive` 默认没有启用</span>
  <span class="token literal-property property">httpAgent</span><span class="token operator">:</span> <span class="token keyword">new</span> <span class="token class-name">http<span class="token punctuation">.</span>Agent</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span> <span class="token literal-property property">keepAlive</span><span class="token operator">:</span> <span class="token boolean">true</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token literal-property property">httpsAgent</span><span class="token operator">:</span> <span class="token keyword">new</span> <span class="token class-name">https<span class="token punctuation">.</span>Agent</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span> <span class="token literal-property property">keepAlive</span><span class="token operator">:</span> <span class="token boolean">true</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>

  <span class="token comment">// 'proxy' 定义代理服务器的主机名称和端口</span>
  <span class="token comment">// `auth` 表示 HTTP 基础验证应当用于连接代理，并提供凭据</span>
  <span class="token comment">// 这将会设置一个 `Proxy-Authorization` 头，覆写掉已有的通过使用 `header` 设置的自定义 `Proxy-Authorization` 头。</span>
  <span class="token literal-property property">proxy</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>
    <span class="token literal-property property">host</span><span class="token operator">:</span> <span class="token string">'127.0.0.1'</span><span class="token punctuation">,</span>
    <span class="token literal-property property">port</span><span class="token operator">:</span> <span class="token number">9000</span><span class="token punctuation">,</span>
    <span class="token literal-property property">auth</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>
      <span class="token literal-property property">username</span><span class="token operator">:</span> <span class="token string">'mikeymike'</span><span class="token punctuation">,</span>
      <span class="token literal-property property">password</span><span class="token operator">:</span> <span class="token string">'rapunz3l'</span>
    <span class="token punctuation">&#125;</span>
  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>

  <span class="token comment">// `cancelToken` 指定用于取消请求的 cancel token</span>
  <span class="token comment">// （查看后面的 Cancellation 这节了解更多）</span>
  <span class="token literal-property property">cancelToken</span><span class="token operator">:</span> <span class="token keyword">new</span> <span class="token class-name">CancelToken</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">cancel</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>response信息</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token punctuation">&#123;</span>
  <span class="token comment">// `data` 由服务器提供的响应</span>
  <span class="token literal-property property">data</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>

  <span class="token comment">// `status` 来自服务器响应的 HTTP 状态码</span>
  <span class="token literal-property property">status</span><span class="token operator">:</span> <span class="token number">200</span><span class="token punctuation">,</span>

  <span class="token comment">// `statusText` 来自服务器响应的 HTTP 状态信息</span>
  <span class="token literal-property property">statusText</span><span class="token operator">:</span> <span class="token string">'OK'</span><span class="token punctuation">,</span>

  <span class="token comment">// `headers` 服务器响应的头</span>
  <span class="token literal-property property">headers</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>

   <span class="token comment">// `config` 是为请求提供的配置信息</span>
  <span class="token literal-property property">config</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
 <span class="token comment">// 'request'</span>
  <span class="token comment">// `request` is the request that generated this response</span>
  <span class="token comment">// It is the last ClientRequest instance in node.js (in redirects)</span>
  <span class="token comment">// and an XMLHttpRequest instance the browser</span>
  <span class="token literal-property property">request</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code></pre>







<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><ul>
<li><p>changeOrigin：Boolean</p>
<p>为false时通过前端访问，devServer转发请求时，http request的host头值不会改变，为true时会把host值改为target指定的host</p>
</li>
</ul>
<h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>要求：</p>
<ol>
<li>正常请求该有的（跨域携带cookie，token，超时设置）</li>
<li>请求响应拦截器<ul>
<li>请求成功，业务状态码200，解析result给我，我不想一层一层的去判断拿数据</li>
<li>http请求200， 业务状态码非200，说明逻辑判断这是不成功的，那就全局message提示服务端的报错</li>
<li>http请求非200， 说明http请求都有问题，也全局message提示报错</li>
<li>http请求或者业务状态码401都做注销操作</li>
</ul>
</li>
<li>全局的loading配置，默认开启，可配置关闭（由于后端的问题，经常会让前端加防抖节流或者loading不让用户在界面上疯狂乱点，行吧行吧，你们的问题前端帮你们解决，你的规矩就是规矩是吧🍜）</li>
<li>统一文件下载处理 （不要再去各写各的下载了，你写一个，他写一个，一个项目就是这样整的跟屎一样）</li>
</ol>
<h2 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h2><p>动态网页的生成是基于动态web server的。一个动态网络服务器首先是一台计算机，这个计算机上包含了产生这个网页所需的HTML模板，样式表，其它托管文件和负责调动这些文件的静态HTTP服务器软件，应用服务器软件和数据库软件(通常情况)。后两者会对HTTP服务器打算传送的托管文件进行更新。</p>
<p>Nginx优点：负载均衡、反向代理、处理静态文件优势。nginx处理静态请求的速度高于apache；</p>
<p>Apache优点：相对于Tomcat服务器来说处理静态文件是它的优势，速度快。Apache是静态解析，适合静态HTML、图片等。</p>
<p>Tomcat：动态解析容器，处理动态请求，是编译JSP\Servlet的容器，Nginx有动态分离机制，静态请求直接就可以通过Nginx处理，动态请求才转发请求到后台交由Tomcat进行处理。 </p>
<p>　　Apache在处理动态有优势，Nginx并发性比较好，CPU内存占用低，如果rewrite频繁，那还是Apache较适合。</p>
<p>localStorage生命周期是永久，除非主动清除localStorage信息，否则这些信息将永远存在。存放数据大小为一般为5MB,而且它仅在客户端（即浏览器）中保存，不参与和服务器的通信。</p>
<p>sessionStorage仅在当前会话下有效，关闭页面或浏览器后被清除。存放数据大小为一般为5MB,而且它仅在客户端（即浏览器）中保存，不参与和服务器的通信。</p>
<p>cookie机制：如果不在浏览器中设置过期事件，cookie被保存在内存中，生命周期随浏览器的关闭而结束，这种cookie简称为会话cookie。如果在浏览器中设置了cookie的过期事件，cookie会被保存在硬盘中，关闭浏览器后，cookie数据仍然存在，直到过期事件结束才消失。cookie是服务端发给客户端的特殊信息，cookie是以文本的方式保存在客户端，每次请求时都带上它</p>
<div class="post-tags"><a class="post-tag-link" href="/tags/Engineering/" rel="tag">#Engineering</a>, <a class="post-tag-link" href="/tags/Web/" rel="tag">#Web</a></div></article><div id="paginator"></div></div></div><div id="bottom-outer"><div id="bottom-inner"><hr><div><div><a>2022@ </a><a href="/atom.xml"><img src="/assets/rss.png"></a></div><div id="hexo"><a>Powered by&nbsp</a><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><a>&nbsp&&nbsp</a><a target="_blank" rel="noopener" href="https://github.com/qiantao94/hexo-theme-oasis">Oasis</a></div></div></div></div></div></body><script src="/js/oasis.js"></script></html>