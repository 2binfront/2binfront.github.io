<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><title>前端基础 │ hh-blog</title><link rel="stylesheet" href="/css/oasis.css"><meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="hh-blog" type="application/atom+xml">
</head><body><div id="content"><h1 id="title">前端基础</h1><div id="menu-outer"><nav id="menu-inner"><a id="menu-back" href="javascript:history.back()">Back</a><time datetime="2022-11-01T16:40:14.000Z">2022-11-02</time></nav></div><div id="content-outer"><div id="content-inner"><article id="post"><blockquote>
<p>持续更新</p>
</blockquote>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h2 id="web基础知识"><a href="#web基础知识" class="headerlink" title="web基础知识"></a>web基础知识</h2><h3 id="url到页面"><a href="#url到页面" class="headerlink" title="url到页面"></a>url到页面</h3><p>浏览器中的进程</p>
<table>
<thead>
<tr>
<th>进程</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>浏览器进程</td>
<td>负责浏览器各个子进程的通信，处理浏览器界面，包括地址栏等</td>
</tr>
<tr>
<td>渲染进程</td>
<td>也就是我们看到的图中的标签页进程，也就是我们常说的浏览器内核，v8就在这个进程。主要负责解析html、js、css渲染页面等</td>
</tr>
<tr>
<td>网络进程</td>
<td>负责发起网络请求，解析返回头信息</td>
</tr>
<tr>
<td>GUI进程</td>
<td>负责将渲染进程生成的图块转化成位图</td>
</tr>
<tr>
<td>插件进程</td>
<td></td>
</tr>
</tbody></table>
<p>从输入页面URL到页面渲染完成大致流程为：</p>
<ul>
<li><p>地址栏输入信息处理</p>
<p>判断输入信息是检索信息还是请求URL</p>
<ul>
<li>如果是检索的信息，就构建请求搜索的URL，调用浏览器默认的搜索引擎进行检索。</li>
<li>如果符合URL格式，浏览器主进程就通过IPC通信机制将URL发送给网络进程。<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/c1015f5ffa74">进程间通信IPC (InterProcess Communication)</a></li>
</ul>
</li>
<li><p>网络进程发起网络请求</p>
<ul>
<li>解析URL，解码</li>
<li>查找浏览器本地缓存</li>
<li>无缓存则DNS解析</li>
<li>建立TCP&#x2F;IP连接</li>
<li>发送HTTP请求</li>
<li>服务器处理请求并返回HTTP报文</li>
</ul>
</li>
<li><p>服务器返回对应资源</p>
<ul>
<li>浏览器接收到服务器返回的资源信息，网络进程首先会解析返回的头信息，查看是否有Location字段，如果有的话，再次发起请求，常见例子：请求http的站点，然后重定向到https。</li>
<li>通过返回头字段<code>Content-Type</code>判断文件类型，如果其他类型，就调用不同的进程处理，如果是html类型，继续处理。</li>
<li>浏览器根据深度遍历的方式把html节点遍历构建DOM树</li>
<li>遇到CSS外链，异步加载解析CSS，构建CSS规则树</li>
<li><strong>遇到script标签，如果是普通JS标签则同步加载并执行，阻塞页面渲染，如果标签上有defer &#x2F; async属性则异步加载JS资源</strong></li>
<li>将dom树和CSS DOM树构造成render树</li>
<li>渲染render树</li>
</ul>
</li>
<li><p>四次挥手，资源传输完毕，断开连接</p>
</li>
</ul>
<p><img src="/Frontend/%E6%B8%B2%E6%9F%93%E8%BF%9B%E7%A8%8B-1668873382169.png" alt="渲染进程"></p>
<h3 id="MIME类型"><a href="#MIME类型" class="headerlink" title="MIME类型"></a>MIME类型</h3><table>
<thead>
<tr>
<th><code>text</code></th>
<th>表明文件是普通文本，理论上是人类可读</th>
<th><code>text/plain</code>, <code>text/html</code>, <code>text/css, text/javascript</code></th>
</tr>
</thead>
<tbody><tr>
<td><code>image</code></td>
<td>表明是某种图像。不包括视频，但是动态图（比如动态 gif）也使用 image 类型</td>
<td><code>image/gif</code>, <code>image/png</code>, <code>image/jpeg</code>, <code>image/bmp</code>, <code>image/webp</code>, <code>image/x-icon</code>, <code>image/vnd.microsoft.icon</code></td>
</tr>
<tr>
<td><code>audio</code></td>
<td>表明是某种音频文件</td>
<td><code>audio/midi</code>, <code>audio/mpeg, audio/webm, audio/ogg, audio/wav</code></td>
</tr>
<tr>
<td><code>video</code></td>
<td>表明是某种视频文件</td>
<td><code>video/webm</code>, <code>video/ogg</code></td>
</tr>
<tr>
<td><code>application</code></td>
<td>表明是某种二进制数据</td>
<td><code>application/octet-stream</code>, <code>application/pkcs12</code>, <code>application/vnd.mspowerpoint</code>, <code>application/xhtml+xml</code>, <code>application/xml</code>, <code>application/pdf</code></td>
</tr>
</tbody></table>
<p>由类型与子类型两个字符串中间用<code>&#39;/&#39;</code>分隔而组成。不允许空格存在。不敏感大小写。</p>
<p>对于 text 文件类型若没有特定的 subtype，就使用 <code>text/plain</code>。类似的，二进制文件没有特定或已知的 subtype，即使用 <code>application/octet-stream</code>。</p>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/MIME_types#applicationoctet-stream">application&#x2F;octet-stream</a>这是应用程序文件的默认值。意思是 <em>未知的应用程序文件 ，</em>浏览器一般不会自动执行或询问执行。</p>
<p>text&#x2F;plain文本文件默认值。即使它<em>意味着未知的文本文件</em>，但浏览器认为是可以直接展示的。</p>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/MIME_types#textjavascript">text&#x2F;javascript </a> text&#x2F;html text&#x2F;css</p>
<p><code>multipart/byteranges</code> 用于把部分的响应报文发送回浏览器</p>
<h3 id="session和cookie、token"><a href="#session和cookie、token" class="headerlink" title="session和cookie、token"></a>session和cookie、token</h3><p>Session（会话机制，能识别哪个请求由哪个用户发起的机制，生成的能识别用户身份信息的字符串称为 sessionId）是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中；</p>
<p><strong>客户端请求后，由<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%99%A8&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2064471064%7D">负载均衡器</a>（如 Nginx）来决定到底打到哪台机器</strong></p>
<p>对应三种解决方案：</p>
<ul>
<li>session复制：所有服务器都有，都一样，性能消耗大，冗余大</li>
<li>session粘连：不同的session（根据ID）放在不同机器上，可靠性低</li>
<li>session共享：将 session 保存在 redis，<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=memcached&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2064471064%7D">memcached</a> 等中间件中，请求到来时，各个机器去这些中间件取一下 session ，多了一次内部连接，消耗了一点性能</li>
</ul>
<p>Cookie是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现Session的一种方式。每当客户端要与服务端通信时，附送 cookie 可以让服务端识别用户身份，找到对应用户之前保留在服务端的信息。一般由第一次客户端访问服务端时，服务端生成并发送给客户端。</p>
<p>token：请求方输入自己的用户名，密码，然后 server 据此生成 token，客户端拿到 token 后会保存到本地，之后向 server 请求时在请求头带上此 token 即可。</p>
<ul>
<li>server 会有一套校验机制，校验这个 token 是否合法。</li>
<li>token 本身可以带 uid 信息，解密后就可以获取</li>
</ul>
<p>jwt token 主要由三部分组成 ——base64编码</p>
<ol>
<li>header：指定了签名算法 </li>
<li>payload：可以指定用户 id，过期时间等非敏感数据 </li>
<li>Signature: 签名，server 根据 header 知道它该用哪种签名算法，再用密钥根据此签名算法对 head + payload 生成签名，这样一个 token 就生成了。</li>
</ol>
<p>Token 一般是放在 header 的 Authorization 自定义头里，不是放在 Cookie 里的，这主要是为了解决跨域不能共享 Cookie 的问题 ——单点登录SSO，向其中一个网站发送请求，获得token，可以用该token发送给其它信任组网站，方便快捷。</p>
<p>缺点：太长了，不太安全，<strong>适合一次性的命令认证，设置一个比较短的有效期</strong></p>
<p>CSRF 攻击的根本原因在于对于同样域名的每个请求来说，它的 cookie 都会被自动带上，这个是浏览器的机制决定的，所以很多人据此认定 cookie 不安全。<em>CSRF</em>（<em>Cross-site request forgery</em>）跨站请求伪造</p>
<p>cookie和token都保存在local storage，会被js读取，前者是存储方式，后者是验证方式</p>
<h3 id="浏览器缓存"><a href="#浏览器缓存" class="headerlink" title="浏览器缓存"></a>浏览器缓存</h3><p>在浏览器中，浏览器会在js和图片等文件解析执行后直接存入内存缓存中，那么当刷新页面时只需直接从内存缓存中读取；而css文件则会存入硬盘文件中，所以每次渲染页面都需要从硬盘读取缓存。</p>
<p><img src="/Frontend/web%E7%BC%93%E5%AD%98%E7%B1%BB%E5%9E%8B-1668873382170.png" alt="web缓存类型"></p>
<p>所谓浏览器缓存其实就是指在本地使用的计算机中开辟一个内存区，同时也开辟一个硬盘区作为数据传输的缓冲区，然后用这个缓冲区来暂时保存用户以前访问过的信息。</p>
<h4 id="Web-Storage"><a href="#Web-Storage" class="headerlink" title="Web Storage"></a>Web Storage</h4><ul>
<li><code>sessionStorage</code> 为每一个给定的源（given origin）维持一个独立的存储区域，该存储区域在页面会话期间可用（即只要浏览器处于打开状态，包括页面重新加载和恢复）。</li>
<li><code>localStorage</code> 同样的功能，但是在浏览器关闭，然后重新打开后数据仍然存在。</li>
</ul>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//以下均可设置localStorage</span>
localStorage<span class="token punctuation">.</span>colorSetting <span class="token operator">=</span> <span class="token string">'#a4509b'</span><span class="token punctuation">;</span>
localStorage<span class="token punctuation">[</span><span class="token string">'colorSetting'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'#a4509b'</span><span class="token punctuation">;</span>
localStorage<span class="token punctuation">.</span><span class="token function">setItem</span><span class="token punctuation">(</span><span class="token string">'colorSetting'</span><span class="token punctuation">,</span> <span class="token string">'#a4509b'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>

<p>storage常用方法</p>
<pre class="language-none"><code class="language-none">Storage.key()
该方法接受一个数值 n 作为参数，并返回存储中的第 n 个键名。

Storage.getItem()
该方法接受一个键名作为参数，返回键名对应的值。

Storage.setItem()
该方法接受一个键名和值作为参数，将会把键值对添加到存储中，如果键名存在，则更新其对应的值。

Storage.removeItem()
该方法接受一个键名作为参数，并把该键名从存储中删除。

Storage.clear()
调用该方法会清空存储中的所有键名。</code></pre>

<p>浏览器缓存细节：</p>
<ul>
<li>浏览器每次发起请求，都会<code>先在浏览器缓存中查找该请求的结果以及缓存标识</code></li>
<li>浏览器每次拿到返回的请求结果都会<code>将该结果和缓存标识存入浏览器缓存中</code></li>
</ul>
<p>强制缓存和协商缓存情况：</p>
<ul>
<li>浏览器请求在缓存中找不到缓存结果和缓存标识，则向服务器请求文件，服务器返回文件同时带上缓存标识，客户端把文件缓存到浏览器缓存中，此时是强制缓存范畴。</li>
<li>浏览器请求在缓存中能找到缓存结果和标识但已经过期，于是携带缓存标识向服务器请求，服务器决定客户端的浏览器缓存是否仍然可用有两种情况：<ul>
<li>仍可用，返回304，客户端再到浏览器缓存请求读取，返回。</li>
<li>不可用，返回200和请求结果，客户端再更新浏览器缓存。</li>
</ul>
</li>
<li>能找到浏览器缓存结果和标识且未过期，直接使用。-强制缓存</li>
</ul>
<h4 id="强制缓存中的HTTP响应报文字段："><a href="#强制缓存中的HTTP响应报文字段：" class="headerlink" title="强制缓存中的HTTP响应报文字段："></a>强制缓存中的HTTP响应报文字段：</h4><p>expires 和 cache-control，作用相似，后者优先级高</p>
<ul>
<li><h5 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h5><p>Expires是HTTP&#x2F;1.0控制网页缓存的字段，其值为服务器返回该请求结果<code>缓存的到期时间</code>，即再次发起该请求时，如果客户端的时间小于Expires的值时，直接使用缓存结果。</p>
</li>
<li><h5 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h5><p>在HTTP&#x2F;1.1中，Cache-Control是最重要的规则，主要用于控制网页缓存，主要取值为：</p>
<ul>
<li>public：所有内容都将被缓存（客户端和代理服务器都可缓存）</li>
<li>private：所有内容只有客户端可以缓存，Cache-Control的默认取值</li>
<li>no-cache：客户端缓存内容，但是是否使用缓存则需要经过协商缓存来验证决定</li>
<li>no-store：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存</li>
<li>max-age&#x3D;xxx (xxx is numeric)：缓存内容将在xxx秒后失效</li>
</ul>
</li>
</ul>
<h4 id="协商缓存的两对字段："><a href="#协商缓存的两对字段：" class="headerlink" title="协商缓存的两对字段："></a>协商缓存的两对字段：</h4><p>Last-Modified &#x2F; If-Modified-Since和 Etag &#x2F; If-None-Match，两对中的每一对的两个字段分别为响应header字段和请求header字段，后面这一对优先级高</p>
<ul>
<li><p>Last-Modified &#x2F; If-Modified-Since</p>
<p>Last-Modified 是服务器响应报文中记录返回资源最后在服务器中修改时间是的值， If-Modified-Since 是客户端在浏览器缓存中找到的已过期缓存的 Last-Modified 值，携带向服务器请求资源，服务器检查 If-Modified-Since 记录的值是否和自身对应资源的 Last-Modified 相同，如果相同返回304未更改，不相同则返回200和新资源及Last-Modified。</p>
</li>
<li><p>Etag &#x2F; If-None-Match</p>
<p>Etag 是服务器响应报文返回资源的唯一标识，If-None-Match 是客户端请求向服务器时携带的对应资源在浏览器缓存中记录的 Etag，该资源在浏览器缓存中已过期。服务器收到后比对 If-None-Match 和服务器资源 Etag 是否相同，相同则返回304资源未修改，否则返回200和新资源及对应新 Etag。</p>
</li>
</ul>
<h4 id="刷新对于强缓存和协商缓存的影响"><a href="#刷新对于强缓存和协商缓存的影响" class="headerlink" title="刷新对于强缓存和协商缓存的影响"></a>刷新对于强缓存和协商缓存的影响</h4><ol>
<li>当ctrl+f5强制刷新网页时，直接从服务器加载，跳过强缓存和协商缓存。</li>
<li>当f5刷新网页时，跳过强缓存，但是会检查协商缓存。</li>
<li>浏览器地址栏中写入URL，回车 浏览器发现缓存中有这个文件了，不用继续请求了，直接去缓存拿。（最快）</li>
</ol>
<h3 id="Location"><a href="#Location" class="headerlink" title="Location"></a>Location</h3><p>http中的头部字段</p>
<p><strong><code>Location</code></strong> 首部指定的是需要将页面重新定向至的地址。一般在响应码为 3xx 的响应中才会有意义。</p>
<p>发送新请求，获取 Location 指向的新页面所采用的方法与初始请求使用的方法以及重定向的类型相关：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/303"><code>303</code></a> (See Also) 始终引致请求使用 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/GET"><code>GET</code></a> 方法，而，而 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/307"><code>307</code></a> (Temporary Redirect) 和 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/308"><code>308</code></a> (Permanent Redirect) 则不转变初始请求中的所使用的方法；</li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/301"><code>301</code></a> (Permanent Redirect) 和 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/302"><code>302</code></a> (Found) 在大多数情况下不会转变初始请求中的方法，不过一些比较早的用户代理可能会引发方法的变更（所以你基本上不知道这一点）。</li>
</ul>
<p>状态码为上述之一的所有响应都会带有一个 Location 首部。</p>
<p>除了重定向响应之外，状态码为 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/201"><code>201</code></a> (Created) 的消息也会带有 Location 首部。它指向的是新创建的资源的地址。</p>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Location"><code>Location</code></a> 与 <code>Content-Location</code>是不同的，前者（<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Location"><code>Location</code></a> ）指定的是一个重定向请求的目的地址（或者新创建的文件的 URL），而后者（ <code>Content-Location</code>）指向的是经过内容协商后的资源的直接地址，不需要进行进一步的内容协商。Location 对应的是响应，而 Content-Location 对应的是要返回的实体。</p>
<h3 id="网络安全"><a href="#网络安全" class="headerlink" title="网络安全"></a>网络安全</h3><h4 id="跨域攻击"><a href="#跨域攻击" class="headerlink" title="跨域攻击"></a>跨域攻击</h4><p><strong>Cross-site request forgery</strong>, also known as <strong>one-click attack</strong> or <strong>session riding</strong> and abbreviated as <strong>CSRF</strong> (sometimes pronounced <em>sea-surf</em>[<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Cross-site_request_forgery#cite_note-Shiflett-1">1]</a>) or <strong>XSRF</strong>, is a type of malicious <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Exploit_(computer_security)">exploit</a> of a <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Website">website</a> where unauthorized commands are submitted from a <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/User_(computing)">user</a> that the web application trusts.</p>
<p><strong>CSRF</strong>&#x2F;<strong>XSRF</strong></p>
<p>同源策略：同域名、同协议、同端口</p>
<h4 id="内容安全策略"><a href="#内容安全策略" class="headerlink" title="内容安全策略"></a>内容安全策略</h4><p>content-security-policy</p>
<p>配置内容安全策略涉及到添加 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Security-Policy"><code>Content-Security-Policy</code></a> HTTP 头部到一个页面，并配置相应的值，以控制用户代理（浏览器等）可以为该页面获取哪些资源。</p>
<p>一个策略由一系列策略指令所组成，每个策略指令都描述了一个针对某个特定类型资源以及生效范围的策略。你的策略应当包含一个<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Security-Policy/default-src"><code>default-src</code></a>策略指令，在其他资源类型没有符合自己的策略时应用该策略 (有关完整列表查看<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Security-Policy/default-src"><code>default-src</code></a> )。一个策略可以包含 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Security-Policy/default-src"><code>default-src</code></a> 或者 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/script-src">script-src (en-US)</a> 指令来防止内联脚本运行，并杜绝<code>eval()</code>的使用。 一个策略也可包含一个 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Security-Policy/default-src"><code>default-src</code></a> 或 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/style-src">style-src </a> 指令去限制来自一个 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/style"><code>style</code></a> 元素或者 style 属性的內联样式。</p>
<p>例如：</p>
<p>一个网站管理者想要所有内容均来自站点的同一个源 (不包括其子域名)</p>
<pre class="language-none"><code class="language-none">Content-Security-Policy: default-src &#39;self&#39;</code></pre>



<p>一个网站管理者允许内容来自信任的域名及其子域名 (域名不必须与 CSP 设置所在的域名相同)</p>
<pre class="language-none"><code class="language-none">Content-Security-Policy: default-src &#39;self&#39; *.trusted.com</code></pre>



<p>一个网站管理者允许网页应用的用户在他们自己的内容中包含来自任何源的图片，但是限制音频或视频需从信任的资源提供者 (获得)，所有脚本必须从特定主机服务器获取可信的代码。</p>
<pre class="language-none"><code class="language-none">Content-Security-Policy: default-src &#39;self&#39;; img-src *; media-src media1.com media2.com; script-src userscripts.example.com</code></pre>

<p>在这里，各种内容默认仅允许从文档所在的源获取，但存在如下例外：</p>
<ul>
<li>图片可以从任何地方加载 (注意 “*” 通配符)。</li>
<li>多媒体文件仅允许从 media1.com 和 media2.com 加载 (不允许从这些站点的子域名)。</li>
<li>可运行脚本仅允许来自于 userscripts.example.com。</li>
</ul>
<p>一个线上银行网站的管理者想要确保网站的所有内容都要通过 SSL 方式获取，以避免攻击者窃听用户发出的请求。</p>
<pre class="language-none"><code class="language-none">Content-Security-Policy: default-src https:&#x2F;&#x2F;onlinebanking.jumbobank.com</code></pre>

<p>该服务器仅允许通过 HTTPS 方式并仅从<code>onlinebanking.jumbobank.com</code>域名来访问文档。</p>
<p>类似的有Content-Security-Policy-Report-Only头部信息，做测试用途，不会阻止访问但会发送违规信息到 report-uri 指令内容的地址。这意味着两种头部启用报告功能需要在指令中加上 report-uri ，但不加 Report-Only 不仅会发送报告也能同时阻止访问。</p>
<p>可以有效防止XSS(cross-site scripting)攻击和数据注入攻击。</p>
<h4 id="OWASP"><a href="#OWASP" class="headerlink" title="OWASP"></a>OWASP</h4><p>是Open Web Application Security Project的缩写，它是一个在线社区，在网络应用安全领域发表文章、方法、文档、工具和技术。</p>
<p>The Top 10 OWASP vulnerabilities in 2021 are:</p>
<ul>
<li>Injection</li>
<li>Broken authentication</li>
<li>Sensitive data exposure</li>
<li>XML external entities (XXE)</li>
<li>Broken access control</li>
<li>Security misconfigurations</li>
<li>Cross site scripting (XSS)</li>
<li>Insecure deserialization</li>
<li>Using components with known vulnerabilities</li>
<li>Insufficient logging and monitoring</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://sucuri.net/guides/owasp-top-10-security-vulnerabilities-2020/">https://sucuri.net/guides/owasp-top-10-security-vulnerabilities-2020/</a></p>
<h2 id="http相关"><a href="#http相关" class="headerlink" title="http相关"></a>http相关</h2><h3 id="cookie操作"><a href="#cookie操作" class="headerlink" title="cookie操作"></a>cookie操作</h3><p>服务器使用 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Set-Cookie"><code>Set-Cookie</code></a> 响应头部向用户代理（一般是浏览器）发送 Cookie 信息。一个简单的 Cookie 可能像这样：</p>
<pre class="language-none"><code class="language-none">Set-Cookie: &lt;cookie 名&gt;&#x3D;&lt;cookie 值&gt;</code></pre>

<p>服务器响应信息，该头部告知客户端保存 Cookie 信息。</p>
<pre class="language-none"><code class="language-none">HTTP&#x2F;1.0 200 OK
Content-type: text&#x2F;html
Set-Cookie: yummy_cookie&#x3D;choco
Set-Cookie: tasty_cookie&#x3D;strawberry

[页面内容]</code></pre>

<p>现在，对该服务器发起的每一次新请求，浏览器都会将之前保存的 Cookie 信息通过 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cookie"><code>Cookie</code></a> 请求头部再发送给服务器。</p>
<pre class="language-none"><code class="language-none">GET &#x2F;sample_page.html HTTP&#x2F;1.1
Host: www.example.org
Cookie: yummy_cookie&#x3D;choco; tasty_cookie&#x3D;strawberry</code></pre>

<h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><p>Cookie 的生命周期可以通过两种方式定义：</p>
<ul>
<li>会话期 Cookie 是最简单的 Cookie：浏览器关闭之后它会被自动删除，也就是说它仅在会话期内有效。会话期 Cookie 不需要指定过期时间（<code>Expires</code>）或者有效期（<code>Max-Age</code>）。需要注意的是，有些浏览器提供了会话恢复功能，这种情况下即使关闭了浏览器，会话期 Cookie 也会被保留下来，就好像浏览器从来没有关闭一样，这会导致 Cookie 的生命周期无限期延长。</li>
<li>持久性 Cookie 的生命周期取决于过期时间（<code>Expires</code>）或有效期（<code>Max-Age</code>）指定的一段时间。</li>
</ul>
<pre class="language-none"><code class="language-none">Set-Cookie: id&#x3D;a3fWa; Expires&#x3D;Wed, 21 Oct 2015 07:28:00 GMT;</code></pre>

<p>还有限制访问、作用域等，详见<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Cookies">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Cookies</a></p>
<h2 id="websocket"><a href="#websocket" class="headerlink" title="websocket"></a>websocket</h2><p><a target="_blank" rel="noopener" href="https://www.ruanyifeng.com/blog/2017/05/websocket.html%E5%85%A5%E9%97%A8">https://www.ruanyifeng.com/blog/2017/05/websocket.html入门</a></p>
<p>用于服务端向客户端推送信息，改变传统客户端为了获取服务端频繁更新而需轮询的资源浪费</p>
<p>它的最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Push_technology">服务器推送技术</a>的一种。</p>
<p>其他特点包括：</p>
<p>（1）建立在 TCP 协议之上，服务器端的实现比较容易。</p>
<p>（2）与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。</p>
<p>（3）数据格式比较轻量，性能开销小，通信高效。</p>
<p>（4）可以发送文本，也可以发送二进制数据。</p>
<p>（5）没有同源限制，客户端可以与任意服务器通信。</p>
<p>（6）协议标识符是<code>ws</code>（如果加密，则为<code>wss</code>），服务器网址就是 URL。</p>
<p>WebSocket 服务器的实现，可以查看维基百科的<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Comparison_of_WebSocket_implementations">列表</a>。</p>
<p>常用的 Node 实现有以下三种。</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/uWebSockets/uWebSockets">µWebSockets</a></li>
<li><a target="_blank" rel="noopener" href="http://socket.io/">Socket.IO</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/theturtle32/WebSocket-Node">WebSocket-Node</a></li>
</ul>
<h2 id="html"><a href="#html" class="headerlink" title="html"></a><code>html</code></h2><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><p><code>&amp;lt &lt;  &amp;gt &gt;    &amp;nbsp/&amp;emsp 空格  &amp;copy 版权   &amp;trade-&amp;reg 商标</code></p>
<p>清浮动 <code>clear:left/right/both</code> <code>overflow</code>:产生块级作用域</p>
<p>块级元素block：可以设定宽高，换行排列	行内元素inline：只能由内容撑开，同一行排列	行内块级元素inline-block：可以摆在同一行且能设定宽高</p>
<p>calc计算中不同表达式元素必须间隔空格，以区分变量名称和运算符。并且支持混合单位运算。vh单位是视窗大小的百分比。</p>
<p>布局视口和视觉视口。视口基本上是当前文档的可见部分，</p>
<p>box-sizing属性可分配值：content box(default)，border box；当指定宽度或高度时分别指内容高宽和内容+内边距+边界高宽</p>
<h3 id="常用标签"><a href="#常用标签" class="headerlink" title="常用标签"></a>常用标签</h3><h4 id="a标签"><a href="#a标签" class="headerlink" title="a标签"></a>a标签</h4><p>&lt;a&gt; 标签的 target 属性规定在何处打开链接文档。</p>
<p>如果在一个 &lt;a&gt; 标签内包含一个 target 属性，浏览器将会载入和显示用这个标签的 href 属性命名的、名称与这个目标吻合的框架或者窗口中的文档。如果这个指定名称或 id 的框架或者窗口不存在，浏览器将打开一个新的窗口，给这个窗口一个指定的标记，然后将新的文档载入那个窗口。从此以后，超链接文档就可以指向这个新的窗口。</p>
<h5 id="特殊的目标"><a href="#特殊的目标" class="headerlink" title="特殊的目标"></a>特殊的目标</h5><p>有 4 个保留的目标名称用作特殊的文档重定向操作：</p>
<p>_blank</p>
<p>浏览器总在一个新打开、未命名的窗口中载入目标文档。</p>
<p>_self</p>
<p>这个目标的值对所有没有指定目标的 <a> 标签是默认目标，它使得目标文档载入并显示在相同的框架或者窗口中作为源文档。这个目标是多余且不必要的，除非和文档标题 <base> 标签中的 target 属性一起使用。</p>
<p>_parent</p>
<p>这个目标使得文档载入父窗口或者包含来超链接引用的框架的框架集。如果这个引用是在窗口或者在顶级框架中，那么它与目标 _self 等效。</p>
<p>_top</p>
<p>这个目标使得文档载入包含这个超链接的窗口，用 _top 目标将会清除所有被包含的框架并将文档载入整个浏览器窗口。</p>
<p><strong>提示：</strong>这些 target 的所有 4 个值都以下划线开始。任何其他用一个下划线作为开头的窗口或者目标都会被浏览器忽略，因此，不要将下划线作为文档中定义的任何框架 name 或 id 的第一个字符。</p>
<h4 id="form标签"><a href="#form标签" class="headerlink" title="form标签"></a>form标签</h4><p>form标签的action属性是一个表单当中必须的属性，action属性规定当提交表单时，向何处发送表单数据。</p>
<h4 id="input标签"><a href="#input标签" class="headerlink" title="input标签"></a>input标签</h4><pre class="language-none"><code class="language-none">&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;catphotourl&quot; placeholder&#x3D;&quot;cat photo URL&quot; required&gt;
长下面这样；type限制输入类型，name作为变量名称方便本地调用，placeholder给用户输入暗示，required规定必须有输入元素才能提交表单</code></pre>

<p><img src="/Frontend/input%E6%A0%87%E7%AD%BE-1668873382170.png" alt="input标签"></p>
<p>input标签种类繁多，功能强大，详见<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/Input">https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/Input</a></p>
<p>type属性对应值及其作用：<a target="_blank" rel="noopener" href="https://blog.csdn.net/VickyTsai/article/details/94839889">https://blog.csdn.net/VickyTsai/article/details/94839889</a></p>
<table>
<thead>
<tr>
<th>属性值</th>
<th>用于</th>
</tr>
</thead>
<tbody><tr>
<td>① text</td>
<td>定义 <strong>单行的 输入文本</strong> 字段，用户可在其中输入文本。默认宽度为 20 个字符。单行文本字段。换行符 将自动 从输入值中删除。</td>
</tr>
<tr>
<td>② checkbox</td>
<td>定义 <strong>复选框</strong>。 允许 选择&#x2F;取消选择 单个值 的复选框。</td>
</tr>
<tr>
<td>③ password</td>
<td>定义 <strong>密码</strong> 字段。该字段中的字符 被掩码。值被隐藏的 单行文本字段。使用<code>maxlength</code>和<code>minlength</code>属性指定 可输入值的最大长度。</td>
</tr>
<tr>
<td>④ hidden</td>
<td><strong>隐藏的 输入值</strong>: 定义 隐藏的 输入字段。不显示 但其值 提交给服务器的控件。</td>
</tr>
<tr>
<td>⑤ file</td>
<td><strong>选择文件</strong>. 定义输入字段和 “浏览”按钮，供 文件上传。允许用户 选择文件的控件。使用<code>accept</code>属性 定义控件 可以选择的 文件类型。</td>
</tr>
<tr>
<td>⑥ button</td>
<td><strong>无 默认行为的按钮</strong>: 定义 可点击<strong>按钮</strong>（多数情况下，用于通过 JavaScript 启动脚本）。一个没有默认行为的按钮。</td>
</tr>
<tr>
<td>⑦ radio</td>
<td>定义 <strong>单选 按钮</strong>。一个单选按钮，允许 从多个选项中 选择一个值。</td>
</tr>
<tr>
<td>⑧ reset</td>
<td>定义 <strong>重置按钮</strong>。重置按钮会 清除表单中的 所有数据。将表单内容重 置为默认值的按钮。</td>
</tr>
<tr>
<td>⑨ submit</td>
<td>定义 <strong>提交按钮</strong>。提交按钮 会把表单 数据发送到 服务器。提交表单的 按钮。</td>
</tr>
<tr>
<td>⑩ image</td>
<td><strong>图片提交按钮</strong>: 定义 图像形式的 提交按钮。 一个图形化的 提交按钮。必须使用<code>src</code>属性 定义图像的源，使用<code>alt</code>属性定义 替代文本。可以使用<code>height</code>高度和<code>width</code>宽度属性 以像素为单位 定义图像的大小。</td>
</tr>
</tbody></table>
<p>html5还有新增</p>
<p>value 属性为 input 元素设定值。</p>
<p>对于不同的输入类型，value 属性的用法也不同：</p>
<ul>
<li>type&#x3D;”button”, “reset”, “submit” - 定义按钮上的显示的文本</li>
<li>type&#x3D;”text”, “password”, “hidden” - 定义输入字段的初始值</li>
<li>type&#x3D;”checkbox”, “radio”, “image” - 定义与输入相关联的值</li>
</ul>
<p><strong>注释：</strong>&lt;input type&#x3D;”checkbox”&gt; 和 &lt;input type&#x3D;”radio”&gt; 中必须设置 value 属性。</p>
<p><strong>注释：</strong>value 属性无法与 <input type="file"> 一同使用。</p>
<h4 id="label标签"><a href="#label标签" class="headerlink" title="label标签"></a>label标签</h4><p>label标签可以把input包裹起来，让点击文本和点击按钮都让按钮被点击生效。</p>
<ul>
<li>属性for可以将label绑定到for对应value为ID的标签，但是仅表示关联且需和绑定标签相邻，没有什么特殊效果。</li>
</ul>
<pre class="language-markup" data-language="markup"><code class="language-markup">For the styling of the page to look similar on mobile as it does on a desktop or laptop, you need to add a meta element with a special content attribute.
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>width=device-width, initial-scale=1.0<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span></code></pre>

<h4 id="link标签"><a href="#link标签" class="headerlink" title="link标签"></a>link标签</h4><p><code>rel</code>属性：此属性命名链接文档与当前文档的关系。type属性：这个属性被用于定义链接的内容的类型。这个属性的值应该是像 text&#x2F;html，text&#x2F;css 等 MIME 类型。这个属性常用的用法是定义链接的样式表，最常用的值是表明了 CSS 的 text&#x2F;css。</p>
<h3 id="meta"><a href="#meta" class="headerlink" title="meta"></a>meta</h3><p>详见<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/meta">https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/meta</a></p>
<ul>
<li>如果设置了 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/meta#attr-name"><code>name</code></a> 属性，<code>meta</code> 元素提供的是文档级别（<em>document-level</em>）的元数据，应用于整个页面。</li>
<li>如果设置了 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/meta#attr-http-equiv"><code>http-equiv</code></a> 属性，<code>meta</code> 元素则是编译指令，提供的信息与类似命名的 HTTP 头部相同。</li>
<li>如果设置了 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/meta#attr-charset"><code>charset</code></a> 属性，<code>meta</code> 元素是一个字符集声明，告诉文档使用哪种字符编码。</li>
<li>如果设置了 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Global_attributes#itemprop"><code>itemprop</code></a> 属性，<code>meta</code> 元素提供用户定义的元数据。</li>
</ul>
<p>meta 元素可用于提供 名称 - 值 对形式的文档元数据，<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/meta#attr-name"><code>name</code></a> 属性为元数据条目提供名称，而 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/meta#attr-content"><code>content</code></a> 属性提供值。</p>
<ul>
<li><code>author</code>：文档作者的名字。</li>
<li><code>description</code>：一段简短而精确的、对页面内容的描述。一些浏览器，比如 Firefox 和 Opera，将其用作书签的默认描述。</li>
<li><code>generator</code>：生成此页面的软件的标识符（identifier）。</li>
<li><code>keywords</code>：与页面内容相关的关键词，使用逗号分隔。</li>
<li><code>referrer</code>：控制由当前文档发出的请求的 HTTP <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Referer"><code>Referer</code></a> 请求头。也就是请求页面的主机地址信息</li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/meta/name/theme-color"><code>theme-color</code></a>：表示当前页面的建议颜色，在自定义当前页面从或页面周围的用户界面的显示时，用户代理应当使用此颜色。<code>content</code> 属性应当包含一个有效的 CSS <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/color_value">&#96;&#96;</a> 值。</li>
</ul>
<h4 id="select和option"><a href="#select和option" class="headerlink" title="select和option"></a>select和option</h4><p>select和option搭配使用</p>
<pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>label</span> <span class="token attr-name">for</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>pet-select<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Choose a pet:<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>label</span><span class="token punctuation">></span></span>
//注意 multiple 和 disable 的用法
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>pets<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>pet-select<span class="token punctuation">"</span></span> <span class="token attr-name">multiple</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>option</span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token punctuation">"</span></span> <span class="token attr-name">disabled</span><span class="token punctuation">></span></span>--Please choose an option--<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>option</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>option</span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>dog<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Dog<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>option</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>option</span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>cat<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Cat<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>option</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>option</span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>hamster<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Hamster<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>option</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>option</span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>parrot<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Parrot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>option</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>option</span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>spider<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Spider<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>option</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>option</span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>goldfish<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Goldfish<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>option</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span></code></pre>









<h2 id="css"><a href="#css" class="headerlink" title="css"></a>css</h2><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p>块级元素之间的外边距会发生折叠。这意味着，如果一个具有上边距的元素排在在一个具有下边距的元素之下时，他们之间的间距不会是这两个外边距的和，即外边距会发生折叠，简单来说就是，间距与两个外边距中的较大者一样大。</p>
<p>外边距叠加：相邻元素间距会按照两者各自外边距大的算</p>
<p>内联盒子的宽度和高度被忽略了。外边距、内边距和边框是生效的，但它们不会改变其他内容与内联盒子的关系，因此内边距和边框会与段落中的其他单词重叠。</p>
<p>inline-block却能在设置宽高、内外边距的同时推开其它内联盒子</p>
<p>盒子四边缩写是从顶边顺时针</p>
<h3 id="常用长度单位"><a href="#常用长度单位" class="headerlink" title="常用长度单位"></a>常用长度单位</h3><p>相对长度单位</p>
<table>
<thead>
<tr>
<th align="left">单位</th>
<th align="left">相对于</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>em</code></td>
<td align="left">在 font-size 中使用是相对于父元素的字体大小，在其他属性中使用是相对于自身的字体大小，如 width</td>
</tr>
<tr>
<td align="left"><code>ex</code></td>
<td align="left">字符“x”的高度</td>
</tr>
<tr>
<td align="left"><code>ch</code></td>
<td align="left">数字“0”的宽度</td>
</tr>
<tr>
<td align="left"><code>rem</code></td>
<td align="left">根元素的字体大小，html文档中默认字体大小为 16px</td>
</tr>
<tr>
<td align="left"><code>lh</code></td>
<td align="left">元素的 line-height</td>
</tr>
<tr>
<td align="left"><code>vw</code></td>
<td align="left">视窗<strong>宽度</strong>的 1%</td>
</tr>
<tr>
<td align="left"><code>vh</code></td>
<td align="left">视窗<strong>高度</strong>的 1%</td>
</tr>
<tr>
<td align="left"><code>vmin</code></td>
<td align="left">视窗较小尺寸的 1%</td>
</tr>
<tr>
<td align="left"><code>vmax</code></td>
<td align="left">视图大尺寸的 1%</td>
</tr>
</tbody></table>
<h3 id="常用属性"><a href="#常用属性" class="headerlink" title="常用属性"></a>常用属性</h3><h4 id="box-shadow"><a href="#box-shadow" class="headerlink" title="box-shadow"></a>box-shadow</h4><p>用于在元素的框架上添加阴影效果，两个长度值为x、y轴偏移量，三个时第三个为blur-radius，第四个为spread-radius</p>
<ul>
<li>可选，<code>inset</code>关键字。</li>
<li>可选，<code>&lt;color&gt;</code>值。</li>
<li>若要对同一个元素添加多个阴影效果，请使用逗号将每个阴影规则分隔开。</li>
</ul>
<pre class="language-css" data-language="css"><code class="language-css"><span class="token comment">/* x 偏移量 | y 偏移量 | 阴影颜色 */</span>
<span class="token property">box-shadow</span><span class="token punctuation">:</span> 60px -16px teal<span class="token punctuation">;</span>

<span class="token comment">/* x 偏移量 | y 偏移量 | 阴影模糊半径 | 阴影颜色 */</span>
<span class="token property">box-shadow</span><span class="token punctuation">:</span> 10px 5px 5px black<span class="token punctuation">;</span>

<span class="token comment">/* x 偏移量 | y 偏移量 | 阴影模糊半径 | 阴影扩散半径 | 阴影颜色 */</span>
<span class="token property">box-shadow</span><span class="token punctuation">:</span> 2px 2px 2px 1px <span class="token function">rgba</span><span class="token punctuation">(</span>0<span class="token punctuation">,</span> 0<span class="token punctuation">,</span> 0<span class="token punctuation">,</span> 0.2<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">/* 插页 (阴影向内) | x 偏移量 | y 偏移量 | 阴影颜色 */</span>
<span class="token property">box-shadow</span><span class="token punctuation">:</span> inset 5em 1em gold<span class="token punctuation">;</span>

<span class="token comment">/* 任意数量的阴影，以逗号分隔 */</span>
<span class="token property">box-shadow</span><span class="token punctuation">:</span> 3px 3px red<span class="token punctuation">,</span> -1em 0 0.4em olive<span class="token punctuation">;</span>

<span class="token comment">/* 全局关键字 */</span>
<span class="token property">box-shadow</span><span class="token punctuation">:</span> inherit<span class="token punctuation">;</span>
<span class="token property">box-shadow</span><span class="token punctuation">:</span> initial<span class="token punctuation">;</span>
<span class="token property">box-shadow</span><span class="token punctuation">:</span> unset<span class="token punctuation">;</span></code></pre>

<p>元素设置了border-radius时，转变为圆角阴影</p>
<h3 id="盒模型、正常流"><a href="#盒模型、正常流" class="headerlink" title="盒模型、正常流"></a>盒模型、正常流</h3><p>盒子模型：外边距（<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=margin&spm=1001.2101.3001.7020">margin</a>）+ border（边框） + 内边距（padding）+ content（内容）</p>
<pre class="language-none"><code class="language-none">标准盒子模型，一般浏览器也都默认为标准盒子模型。即：
	box-sizing:content-box
怪异盒子模型，一般根据实际项目需要自行设置。即：
	box-sizing:border-box	padding和border的值就不会影响元素的宽高，相当于把padding和border的值都算在content里</code></pre>





<h3 id="浏览器前缀"><a href="#浏览器前缀" class="headerlink" title="浏览器前缀"></a>浏览器前缀</h3><ul>
<li><code>-webkit-</code> （谷歌，Safari，新版 Opera 浏览器，以及几乎所有 iOS 系统中的浏览器（包括 iOS 系统中的火狐浏览器）；基本上所有基于 WebKit 内核的浏览器）</li>
<li><code>-moz-</code> （火狐浏览器）</li>
<li><code>-o-</code> （旧版 Opera 浏览器）</li>
<li><code>-ms-</code> （IE 浏览器 和 Edge 浏览器）</li>
</ul>
<h3 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h3><h4 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h4><p>最近的祖先样式比其他祖先样式优先级高。</p>
<p>“直接样式”比”祖先样式”优先级高。</p>
<p>内联样式 &gt; ID 选择器# &gt; 类选择器.class &#x3D; 属性选择器 &#x3D; 伪类选择器 &gt; 标签选择器element &#x3D; 伪元素选择器</p>
<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p><strong>伪类</strong> 是添加到选择器的关键字，指定要选择的元素的特殊状态。例如，<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:hover"><code>:hover</code></a> 可被用于在用户将鼠标悬停在按钮上时改变按钮的颜色。</p>
<p><strong>伪元素</strong>以类似方式表现，不过表现得是像你往标记文本中加入全新的 HTML 元素一样，而不是向现有的元素上应用类。例如<code>::first-line</code></p>
<h4 id="参考节"><a href="#参考节" class="headerlink" title="参考节"></a><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/Building_blocks/Selectors/Pseudo-classes_and_pseudo-elements#%E5%8F%82%E8%80%83%E8%8A%82">参考节</a></h4><h3 id="flex布局"><a href="#flex布局" class="headerlink" title="flex布局"></a>flex布局</h3><p>flexbox	弹性布局，一维布局模型	display:flex</p>
<p>容器属性</p>
<p>flex-direction：四种摆放方向，垂直和水平的正反</p>
<ul>
<li><code>row</code></li>
<li><code>row-reverse</code></li>
<li><code>column</code></li>
<li><code>column-reverse</code></li>
</ul>
<p>flex-wrap：指定 flex 元素单行显示还是多行显示。如果允许换行，这个属性允许你控制行的堆叠方向。</p>
<ul>
<li><p>nowrap</p>
<p>flex 的元素被摆放到到一行，这可能导致 flex 容器溢出。<strong>cross-start</strong> 会根据 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/flex-direction"><code>flex-direction</code></a> 的值等价于 <strong>start</strong> 或 <strong>before</strong>。为该属性的默认值。</p>
</li>
<li><p>wrap</p>
<p>flex 元素 被打断到多个行中。<strong>cross-start</strong> 会根据 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/flex-direction"><code>flex-direction</code></a> 的值等价于 <strong>start</strong> 或<strong>before</strong>。<strong>cross-end</strong> 为确定的 <strong>cross-start</strong> 的另一端。</p>
</li>
<li><p>wrap-reverse</p>
<p>和 wrap 的行为一样，但是 <strong>cross-start</strong> 和 <strong>cross-end</strong> 互换。</p>
</li>
</ul>
<p>flex-flow：前两个属性的结合</p>
<p>justify-content：主轴对齐方式。它可能取5个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。</p>
<blockquote>
<ul>
<li><code>flex-start</code>（默认值）：左对齐</li>
<li><code>flex-end</code>：右对齐</li>
<li><code>center</code>： 居中</li>
<li><code>space-between</code>：两端对齐，项目之间的间隔都相等。</li>
<li><code>space-around</code>：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。</li>
</ul>
</blockquote>
<p>align-items：交叉轴对齐方式，它可能取5个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。</p>
<blockquote>
<ul>
<li><code>flex-start</code>：与交叉轴的起点对齐。</li>
<li><code>flex-end</code>：与交叉轴的终点对齐。</li>
<li><code>center</code>：与交叉轴的中点对齐。</li>
<li><code>space-between</code>：与交叉轴两端对齐，轴线之间的间隔平均分布。</li>
<li><code>space-around</code>：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。</li>
<li><code>stretch</code>（默认值）：轴线占满整个交叉轴。</li>
</ul>
</blockquote>
<p>align-content：定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。</p>
<p>​	五种对齐方式：这里的左右是相对于轴方向而言</p>
<ul>
<li><code>flex-start</code>（默认值）：左对齐</li>
<li><code>flex-end</code>：右对齐</li>
<li><code>center</code>： 居中</li>
<li><code>space-between</code>：两端对齐，项目之间的间隔都相等。</li>
<li><code>space-around</code>：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。</li>
</ul>
<p>内部元素属性</p>
<p>order：<code>order</code>属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。</p>
<p>flex-grow：对容器内剩余空间的处理，为容器内的每个元素进行分配，分配的值依此属性值而定。定义项目的放大比例，默认为<code>0</code>，即如果存在剩余空间，也不放大。</p>
<p>flex-shrink：对溢出空间的处理，对容器内每个元素的压缩的值依此属性的值而定。属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。</p>
<p>flex-basis：定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为<code>auto</code>，即项目的本来大小。</p>
<p>flex：flex属性是<code>flex-grow</code>, <code>flex-shrink</code> 和 <code>flex-basis</code>的简写，默认值为<code>0 1 auto</code>。后两个属性可选。</p>
<p>align-self：<code>align-self</code>属性允许单个项目有与其他项目不一样的对齐方式，可覆盖<code>align-items</code>属性。默认值为<code>auto</code>，表示继承父元素的<code>align-items</code>属性，如果没有父元素，则等同于<code>stretch</code>。</p>
<h3 id="grid布局"><a href="#grid布局" class="headerlink" title="grid布局"></a>grid布局</h3><p>二维布局。container 和 item</p>
<h4 id="container属性："><a href="#container属性：" class="headerlink" title="container属性："></a>container属性：</h4><ul>
<li>display：我们通过在元素上声明 <code>display：grid</code> 或 <code>display：inline-grid</code> 来创建一个网格容器。声明 <code>display：grid</code> 则该容器是一个块级元素，设置成 <code>display: inline-grid</code> 则容器元素为行内元素</li>
<li></li>
</ul>
<h4 id="item属性："><a href="#item属性：" class="headerlink" title="item属性："></a>item属性：</h4><h3 id="定位position"><a href="#定位position" class="headerlink" title="定位position"></a>定位position</h3><ul>
<li>static静态定位，默认属性</li>
<li>relative相对定位，相对于为static父标签的偏移，同时需要指定偏移方向和位移</li>
<li>absolute绝对定位，相对于不为static父标签的偏移</li>
<li>fixed固定定位，相对于浏览器窗口的偏移，不随父标签的属性改变而改变</li>
<li>sticky粘性定位，未滚动到预定位置就是relative，到预定位置就是fixed，实现比如固定在页面顶部的导航栏</li>
</ul>
<p>页面的普通流，static 和 relative 都不会更改元素的正常文档流，block 元素还是width 为100%，inline 元素还是宽高无效</p>
<pre class="language-css" data-language="css"><code class="language-css"><span class="token comment">/*relative示例*/</span>
<span class="token selector">span</span> <span class="token punctuation">&#123;</span> 
    <span class="token property">background</span><span class="token punctuation">:</span> #b6ff00<span class="token punctuation">;</span> 
    <span class="token property">position</span><span class="token punctuation">:</span> relative<span class="token punctuation">;</span> 
    <span class="token property">top</span><span class="token punctuation">:</span> 10px<span class="token punctuation">;</span> 
    <span class="token property">left</span><span class="token punctuation">:</span> 10px<span class="token punctuation">;</span> 
    <span class="token property">width</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span> 
<span class="token punctuation">&#125;</span></code></pre>



<h3 id="浮动float"><a href="#浮动float" class="headerlink" title="浮动float"></a>浮动float</h3><p>float 属性定义元素在哪个方向浮动，常用属性值有 left、right，即向左浮动和向右浮动。设置了 float 的元素，会脱离文档流，然后向左或向右移动，直到碰到父容器的边界或者碰到另一个浮动元素。块级元素会忽略 float 元素，文本和行内元素却会环绕</p>
<p>会影响自身及后面的元素，不推荐使用	有相对应的clear属性，清除浮动，也能影响自身及后面的元素</p>
<ul>
<li>left</li>
<li>right</li>
</ul>
<h3 id="规则"><a href="#规则" class="headerlink" title="@规则"></a>@规则</h3><p>一个 <strong>at-rule</strong> 是一个<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en/CSS/Syntax#CSS_statements">CSS 语句，</a>以 at 符号开头， ‘<code>@</code>‘ (<code>U+0040 COMMERCIAL AT</code>), 后跟一个标识符，并包括直到下一个分号的所有内容， ‘<code>;</code>‘ (<code>U+003B SEMICOLON</code>), 或下一个 CSS 块，以先到者为准。</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/@charset"><code>@charset</code></a>, 定义样式表使用的字符集。</li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/@import"><code>@import</code></a>, 告诉 CSS 引擎引入一个外部样式表。</li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/@namespace"><code>@namespace</code></a>, 告诉 CSS 引擎必须考虑 XML 命名空间。</li>
<li>嵌套 @规则，是嵌套语句的子集，不仅可以作为样式表里的一个语句，也可以用在条件规则组里：<ul>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/@media"><code>@media</code></a>, 如果满足媒介查询的条件则条件规则组里的规则生效。</li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/@page"><code>@page</code></a>, 描述打印文档时布局的变化。</li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/@font-face"><code>@font-face</code></a>, 描述将下载的外部的字体。 Experimental</li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/@keyframes"><code>@keyframes</code></a>, 描述 CSS 动画的中间步骤 . Experimental</li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/@supports"><code>@supports</code></a>, 如果满足给定条件则条件规则组里的规则生效。 Experimental</li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/@document"><code>@document</code></a>, 如果文档样式表满足给定条件则条件规则组里的规则生效。 <em>(推延至 CSS Level 4 规范)</em></li>
</ul>
</li>
</ul>
<p><strong>条件规则组</strong>. 这些语句使用相同的语法。它们都嵌套语句，或者是<em>规则</em>或者是*@规则*。它们都表达：它们所指的条件 (类型不同) 总等效于 <strong>true</strong> 或者 <strong>false</strong>，如果为 <strong>true</strong> 那么它们里面的语句生效。</p>
<h3 id="scss"><a href="#scss" class="headerlink" title="scss"></a>scss</h3><p>sass3.0之后的进步版本，采用花括号分段而非缩进</p>
<p><a target="_blank" rel="noopener" href="https://sass-lang.com/">Sass: Syntactically Awesome Style Sheets</a></p>
<p>css的超集</p>
<p>变量开头是$</p>
<h4 id="mixin"><a href="#mixin" class="headerlink" title="mixin"></a>mixin</h4><p>类似函数，变量参数以 $ 开头，定义用@mixin前缀，调用用@include 前缀</p>
<pre class="language-none"><code class="language-none">&lt;style type&#x3D;&#39;text&#x2F;scss&#39;&gt;
@mixin border-radius($radius)&#123;
  -webkit-border-radius:$radius;
  -moz-border-radius:$radius;
  -ms-border-radius:$radius;
  border-radius:$radius;
&#125;


  #awesome &#123;
    width: 150px;
    height: 150px;
    background-color: green;
    @include border-radius(15px);
  &#125;
&lt;&#x2F;style&gt;

&lt;div id&#x3D;&quot;awesome&quot;&gt;&lt;&#x2F;div&gt;</code></pre>

<h3 id="Less"><a href="#Less" class="headerlink" title="Less"></a>Less</h3><h4 id="Variables"><a href="#Variables" class="headerlink" title="Variables"></a>Variables</h4><p>变量，@开头，在最外层定义</p>
<pre class="language-less" data-language="less"><code class="language-less"><span class="token variable">@width<span class="token punctuation">:</span></span> 10px<span class="token punctuation">;</span>
<span class="token variable">@height<span class="token punctuation">:</span></span> <span class="token variable">@width</span> <span class="token operator">+</span> 10px<span class="token punctuation">;</span>

<span class="token selector">#header</span> <span class="token punctuation">&#123;</span>
  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token variable">@width</span><span class="token punctuation">;</span>
  <span class="token property">height</span><span class="token punctuation">:</span> <span class="token variable">@height</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">//编译为</span>
<span class="token selector">#header</span><span class="token punctuation">&#123;</span>
    <span class="token property">width</span><span class="token punctuation">:</span>10px<span class="token punctuation">;</span>
    <span class="token property">height</span><span class="token punctuation">:</span>20px<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>



<h4 id="Mixins"><a href="#Mixins" class="headerlink" title="Mixins"></a>Mixins</h4><p>混合</p>
<h4 id="Nesting"><a href="#Nesting" class="headerlink" title="Nesting"></a>Nesting</h4><p>嵌套</p>
<p><code>&amp;</code> 表示当前选择器的父级</p>
<pre class="language-less" data-language="less"><code class="language-less"><span class="token selector">.clearfix</span> <span class="token punctuation">&#123;</span>
  <span class="token property">display</span><span class="token punctuation">:</span> block<span class="token punctuation">;</span>
  <span class="token property">zoom</span><span class="token punctuation">:</span> 1<span class="token punctuation">;</span>

  <span class="token selector">&amp;:after</span> <span class="token punctuation">&#123;</span>
    <span class="token property">content</span><span class="token punctuation">:</span> <span class="token string">" "</span><span class="token punctuation">;</span>
    <span class="token property">display</span><span class="token punctuation">:</span> block<span class="token punctuation">;</span>
    <span class="token property">font-size</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>
    <span class="token property">height</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>
    <span class="token property">clear</span><span class="token punctuation">:</span> both<span class="token punctuation">;</span>
    <span class="token property">visibility</span><span class="token punctuation">:</span> hidden<span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code></pre>





<h3 id="Stylus"><a href="#Stylus" class="headerlink" title="Stylus"></a><strong><code>Stylus</code></strong></h3><h2 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h2><p>document object model 文档对象模型，HTML的节点树</p>
<p>接口：Document，Window，Element，</p>
<p>基本操作分四类：增、删、查、改</p>
<p>查的方法：获取DOM节点</p>
<ul>
<li><p>js中执行document上的成员函数，传入 id、class、tagName等指定条件，获取DOM结点</p>
</li>
<li><p>通过css选择器查询DOM结点</p>
</li>
<li><p>通过已访问到的DOM节点对象访问其它相关的父子兄弟结点。</p>
</li>
<li><p><code>document.getElementById(id)</code></p>
</li>
<li><p><code>document.getElementsByTagName(name)</code>，参数是标签名，返回nodelist，类数组</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document/getElementsByClassName"><code>Document.getElementsByClassName()</code></a>，参数类名，返回nodelist</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document/querySelector"><code>document.querySelector()</code></a>，参数是css选择器语法，加引号，返回第一个符合选择器语法的element</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document/querySelectorAll"><code>document.querySelectorAll()</code></a>，参数同上，但返回nodelist</p>
</li>
</ul>
<p>增(例如定位element对象，为其增加子节点)、删(element.remove())、改(Element对象的方法)</p>
<h3 id="document属性"><a href="#document属性" class="headerlink" title="document属性"></a>document属性</h3><h4 id="documentelement和body"><a href="#documentelement和body" class="headerlink" title="documentelement和body"></a>documentelement和body</h4><h5 id="DTD"><a href="#DTD" class="headerlink" title="DTD"></a>DTD</h5><p>DTD告诉浏览器当前文档用的是什么标记语言，然后浏览器才能正确的根据W3C标准解析文档代码。</p>
<p>目前htmlDTD有三种类型：</p>
<ul>
<li><p>Strict DTD：严格的文档类型定义</p>
<p>不能包含已过时的元素（或属性）和框架元素。</p>
</li>
<li><p>Transitional DTD：过渡的文档类型定义</p>
<p>能包含已过时的元素和属性但不能包含框架元素。</p>
</li>
<li><p>Frameset DTD: 框架集文档类型定义</p>
<p>能包含已过时的元素和框架元素。</p>
</li>
</ul>
<p>在html文档中定义DTD就是通过！doctype定义，如下，是一个html4.0的过渡DTDhtml文档：</p>
<pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span> <span class="token name">PUBLIC</span> <span class="token string">"-//W3C//DTD XHTML1.0 Transitional//EN"</span> <span class="token string">"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"</span><span class="token punctuation">></span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span>
</code></pre>

<p>或在html5中：</p>
<pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">doctype</span> <span class="token name">html</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span></code></pre>

<h5 id="document-documentElement与document-body"><a href="#document-documentElement与document-body" class="headerlink" title="document.documentElement与document.body"></a>document.documentElement与document.body</h5><ul>
<li>document代表的是整个文档(对于一个网页来说包括整个网页结构)，document.documentElement是整个文档节点树的根节点，在网页中即html标签；</li>
<li>document.body是整个文档DOM节点树里的body节点，网页中即为body标签元素。</li>
</ul>
<p>我们常看见如下这种写法获取页面滚动条滚过的长度：</p>
<pre class="language-dart" data-language="dart"><code class="language-dart"><span class="token keyword">var</span> top <span class="token operator">=</span> document<span class="token punctuation">.</span>documentElement<span class="token punctuation">.</span>scrollTop <span class="token operator">||</span> document<span class="token punctuation">.</span>body<span class="token punctuation">.</span>scrollTop<span class="token punctuation">;</span>
或
<span class="token keyword">var</span> top <span class="token operator">=</span> document<span class="token punctuation">.</span>documentElement<span class="token punctuation">.</span>scrollTop <span class="token operator">?</span> document<span class="token punctuation">.</span>documentElement<span class="token punctuation">.</span>scrollTop <span class="token punctuation">:</span> document<span class="token punctuation">.</span>body<span class="token punctuation">.</span>scrollTop<span class="token punctuation">;</span></code></pre>

<p>在文档使用了DTD时，document.body.scrollTop的值为0，此时需要使用document.documentElement.scrollTop来获取滚动条滚过的长度；在未使用DTD定义文档时，使用document.body.scrollTop获取值。</p>
<h4 id="scrollHeight"><a href="#scrollHeight" class="headerlink" title="scrollHeight"></a>scrollHeight</h4><p>scrollHeight 属性是一个只读属性，它返回该元素的像素高度，高度包含内边距（padding），不包含外边距（margin）、边框（border），是一个整数，单位是像素 px。</p>
<p>获取 div 元素的高度和宽度，包含内边距（padding）:</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> elmnt <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"content"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token keyword">var</span> y <span class="token operator">=</span> elmnt<span class="token punctuation">.</span>scrollHeight<span class="token punctuation">;</span> 
<span class="token keyword">var</span> x <span class="token operator">=</span> elmnt<span class="token punctuation">.</span>scrollWidth<span class="token punctuation">;</span></code></pre>







<h3 id="DOM事件"><a href="#DOM事件" class="headerlink" title="DOM事件"></a>DOM事件</h3><p>0级(其实并不存在这个标准)，1级(映射文档结构，特定于HTML的对象和方法)，2级(增加模块以支持新的接口：追踪文档不同视图的接口、事件及事件处理接口、处理元素css样式的接口、遍历和操作DOM树的接口)，3级(增加了以统一的方式加载和保存文档的方法（包含在一个叫 DOM  Load and Save 的新模块中），还有验证文档的方法（DOM Validation）)，4级(替代 Mutation Events 的 Mutation Observers)</p>
<ul>
<li>事件发生，触发设定好的应对函数(事件监听函数)，是js和HTML的交互基础，常用的有鼠标事件、触摸事件、键盘事件、媒体事件、剪切板事件、资源事件等</li>
<li>事件流，三个阶段：事件捕获Capture-&gt;目标事件Target-&gt;事件冒泡Bubbling      onclick和addEventListener的区别，前者不支持一个事件绑定多个事件处理函数，后者支持</li>
</ul>
<p>addEventListener的第三个参数为指定事件是否在捕获或冒泡阶段执行，<u>设置为true表示事件在捕获阶段执行，而设置为false表示事件在冒泡阶段执行。</u>默认值为true</p>
<p>event属性</p>
<ul>
<li><code>event.target</code>指向<strong>引起触发事件的元素</strong>，而<code>event.currentTarget</code>则是<strong>事件绑定的元素</strong>。</li>
</ul>
<pre class="language-none"><code class="language-none">target.addEventListener(type, listener[, useCapture]);
target.removeEventListener(type, listener[, useCapture]);
&#x2F;*
	方法中包含3个参数，分别是绑定的事件处理属性名称（不包含on）、事件处理函数、是否在捕获时执行事件处理函数
*&#x2F;
</code></pre>

<p>event方法</p>
<ul>
<li><p>stopPropagation方法主要用于阻止事件的进一步传播，配合addeventlistener第三个参数可以实现在事件捕获阶段阻止事件向下传播或在事件冒泡阶段阻止事件向上传播</p>
</li>
<li><p>preventDefault方法用于取消事件的默认操作，比如a链接的跳转行为和表单自动提交行为就可以用preventDefault方法来取消。</p>
</li>
<li><p>和stopPropagation相比，stopImmediatePropagation同样可以阻止事件的传播，不同点在于其还可以把这个元素绑定的同类型事件也阻止了。</p>
</li>
</ul>
<h3 id="虚拟DOM"><a href="#虚拟DOM" class="headerlink" title="虚拟DOM"></a>虚拟DOM</h3><p>Virtual dom, 即虚拟DOM节点。它通过JS的Object对象模拟DOM中的节点，然后再通过特定的render方法将其渲染成真实的DOM节点。</p>
<p>包含了<code>tag</code>、<code>props</code>、<code>children</code>三个属性。分别代表当前元素的标签名称字符串，当前标签的属性对象，子元素对象数组，也就是说可以无限嵌套。</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript">render方法
转换属性时要考虑多种情况。像value、style等属性需要做特殊处理

<span class="token keyword">function</span> <span class="token function">createElement</span><span class="token punctuation">(</span><span class="token parameter">type<span class="token punctuation">,</span> props<span class="token punctuation">,</span> children</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Element</span><span class="token punctuation">(</span>type<span class="token punctuation">,</span> props<span class="token punctuation">,</span> children<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">class</span> <span class="token class-name">Element</span> <span class="token punctuation">&#123;</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">type<span class="token punctuation">,</span> props<span class="token punctuation">,</span> children</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>type <span class="token operator">=</span> type<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>props <span class="token operator">=</span> props<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>children <span class="token operator">=</span> children<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">function</span> <span class="token function">render</span><span class="token punctuation">(</span><span class="token parameter">eleObj</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">let</span> el <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span>eleObj<span class="token punctuation">.</span>type<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 创建元素</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> key <span class="token keyword">in</span> eleObj<span class="token punctuation">.</span>props<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">// 设置属性的方法</span>
        <span class="token function">setAttr</span><span class="token punctuation">(</span>el<span class="token punctuation">,</span> key<span class="token punctuation">,</span> eleObj<span class="token punctuation">.</span>props<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#125;</span>
    eleObj<span class="token punctuation">.</span>children<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">child</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
        <span class="token comment">// 判断子元素是否是Element类型，是则递归，不是则创建文本节点</span>
        child <span class="token operator">=</span> <span class="token punctuation">(</span>child <span class="token keyword">instanceof</span> <span class="token class-name">Element</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token function">render</span><span class="token punctuation">(</span>child<span class="token punctuation">)</span> <span class="token operator">:</span> document<span class="token punctuation">.</span><span class="token function">createTextNode</span><span class="token punctuation">(</span>child<span class="token punctuation">)</span><span class="token punctuation">;</span>
        el<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>child<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> el<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">function</span> <span class="token function">setAttr</span><span class="token punctuation">(</span><span class="token parameter">node<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">switch</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">case</span> <span class="token string">'value'</span><span class="token operator">:</span> <span class="token comment">// node是一个input或者textarea</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>tagName<span class="token punctuation">.</span><span class="token function">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token string">'INPUT'</span> <span class="token operator">||</span> node<span class="token punctuation">.</span>tagName<span class="token punctuation">.</span><span class="token function">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token string">'TEXTAREA'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                node<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 普通属性</span>
                node<span class="token punctuation">.</span><span class="token function">setAttribute</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token keyword">case</span> <span class="token string">'style'</span><span class="token operator">:</span>
            node<span class="token punctuation">.</span>style<span class="token punctuation">.</span>cssText <span class="token operator">=</span> value<span class="token punctuation">;</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token keyword">default</span><span class="token operator">:</span>
            node<span class="token punctuation">.</span><span class="token function">setAttribute</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>


<span class="token comment">//renderDom接受 el 真实DOM和target 渲染目标两个参数，负责将真实DOM添加到浏览器上</span>
<span class="token keyword">function</span> <span class="token function">renderDom</span><span class="token punctuation">(</span><span class="token parameter">el<span class="token punctuation">,</span> target</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    target<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>el<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>



<h3 id="DOM-Diff"><a href="#DOM-Diff" class="headerlink" title="DOM Diff"></a>DOM Diff</h3><p>通过<code>JS</code>层面的计算，返回一个patch对象，即补丁对象，再通过特定的操作解析<code>patch</code>对象，完成页面的重新渲染。</p>
<p>1.用JS对象模拟DOM（虚拟DOM）<br>2.把此虚拟DOM转成真实DOM并插入页面中（render）<br>3.如果有事件发生修改了虚拟DOM，比较两棵虚拟DOM树的差异，得到差异对象（diff）<br>4.把差异对象应用到真正的DOM树上（patch）</p>
<h2 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h2><p>Browser Object Model 浏览器对象模型，控制浏览器的行为的接口</p>
<p>window是浏览器对象模型</p>
<h3 id="window-history"><a href="#window-history" class="headerlink" title="window.history"></a>window.history</h3><p>详见<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/History_API">https://developer.mozilla.org/zh-CN/docs/Web/API/History_API</a></p>
<p>History 对象主要有两个属性。</p>
<ul>
<li><code>History.length</code>：当前窗口访问过的网址数量（包括当前网页）</li>
<li><code>History.state</code>：History 堆栈最上层的状态值（详见下文）</li>
</ul>
<pre class="language-none"><code class="language-none">&#x2F;&#x2F; 当前窗口访问过多少个网页
window.history.length &#x2F;&#x2F; 1

&#x2F;&#x2F; History 对象的当前状态
&#x2F;&#x2F; 通常是 undefined，即未设置
window.history.state &#x2F;&#x2F; undefined</code></pre>

<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>History.back()、History.forward()、History.go()</p>
<h3 id="window-location"><a href="#window-location" class="headerlink" title="window.location"></a>window.location</h3><p>window.location 对象所包含的属性</p>
<table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">hash</td>
<td align="left">从井号 (#) 开始的 URL（锚）</td>
</tr>
<tr>
<td align="left">host</td>
<td align="left">主机名和当前 URL 的端口号</td>
</tr>
<tr>
<td align="left">hostname</td>
<td align="left">当前 URL 的主机名</td>
</tr>
<tr>
<td align="left">href</td>
<td align="left">完整的 URL</td>
</tr>
<tr>
<td align="left">pathname</td>
<td align="left">当前 URL 的路径部分</td>
</tr>
<tr>
<td align="left">port</td>
<td align="left">当前 URL 的端口号</td>
</tr>
<tr>
<td align="left">protocol</td>
<td align="left">当前 URL 的协议</td>
</tr>
<tr>
<td align="left">search</td>
<td align="left">从问号 (?) 开始的 URL（查询部分）</td>
</tr>
</tbody></table>
<h4 id="hash属性"><a href="#hash属性" class="headerlink" title="hash属性"></a>hash属性</h4><p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Location"><code>Location</code></a> 接口的 <strong><code>hash</code></strong> 属性返回一个 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String"><code>USVString</code></a>，其中会包含 URL 标识中的 <code>&#39;#&#39;</code> 和 后面 URL 片段标识符。这里 fragment 不会经过<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Glossary/percent-encoding">百分比编码</a>（URL 编码）。如果 URL 中没有 fragment，该属性会包含一个空字符串，<code>&quot;&quot;</code></p>
<p>通过监听 window 对象的 hashChange 事件实现简单的路由</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript">window<span class="token punctuation">.</span><span class="token function-variable function">onhashchange</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">var</span> hash <span class="token operator">=</span> window<span class="token punctuation">.</span>location<span class="token punctuation">.</span>hash
  <span class="token keyword">var</span> path <span class="token operator">=</span> hash<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>

  <span class="token keyword">switch</span> <span class="token punctuation">(</span>path<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">case</span> <span class="token string">'/'</span><span class="token operator">:</span>
      <span class="token function">showHome</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
      <span class="token keyword">break</span>
    <span class="token keyword">case</span> <span class="token string">'/users'</span><span class="token operator">:</span>
      <span class="token function">showUsersList</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
      <span class="token keyword">break</span>
    <span class="token keyword">default</span><span class="token operator">:</span>
      <span class="token function">show404NotFound</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code></pre>



<h3 id="window-onload"><a href="#window-onload" class="headerlink" title="window.onload"></a>window.onload</h3><h4 id="什么是-window-onload"><a href="#什么是-window-onload" class="headerlink" title="什么是 window.onload"></a>什么是 window.onload</h4><p>window.onload()方法用于在页面加载完毕后立刻执行的操作，即当HTML文档加载完毕后，立刻执行的某个方法。</p>
<p><strong>window.onload()</strong> 通常用于 元素，在页面完全载入后(包括图片、css文件等等)执行window.onload()里面的函数。</p>
<ol>
<li><p>只有一个要执行的函数：</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript">window<span class="token punctuation">.</span>onload <span class="token operator">=</span> funcRef<span class="token punctuation">;</span></code></pre>

<ul>
<li>funcRef：函数类型的对象引用或者匿名函数</li>
</ul>
<p>在页面加载完成后，调用funcRef方法</p>
</li>
<li><p>有多个要执行的函数：</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript">window<span class="token punctuation">.</span><span class="token function-variable function">onload</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token function">Func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">Func2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">Func3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">...</span><span class="token operator">...</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>在页面加载完成后依次执行 Func1、Func2、Func3</p>
</li>
</ol>
<h4 id="使用window-onload-的好处"><a href="#使用window-onload-的好处" class="headerlink" title="使用window.onload()的好处"></a>使用window.onload()的好处</h4><p>JavaScript 中的函数方法需要在 HTML 文档渲染完成后才可以使用，如果没有渲染完成，此时的 DOM 树是不完整的，这样在调用一些 JavaScript 代码时就可能报出”undefined”错误。</p>
<h3 id="window-onscroll"><a href="#window-onscroll" class="headerlink" title="window.onscroll"></a>window.onscroll</h3><p>滚动当前页面的时候，添加事件处理函数。</p>
<p>语法：</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript">window<span class="token punctuation">.</span>onscroll <span class="token operator">=</span> funcRef<span class="token punctuation">;</span></code></pre>

<ul>
<li>funcRef是个函数类型的对象引用或者匿名函数.</li>
</ul>
<div class="post-tags"><a class="post-tag-link" href="/tags/Web/" rel="tag">#Web</a></div></article><div id="paginator"></div></div></div><div id="bottom-outer"><div id="bottom-inner"><hr><div><div><a>2022@ </a><a href="/atom.xml"><img src="/assets/rss.png"></a></div><div id="hexo"><a>Powered by&nbsp</a><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><a>&nbsp&&nbsp</a><a target="_blank" rel="noopener" href="https://github.com/qiantao94/hexo-theme-oasis">Oasis</a></div></div></div></div></div></body><script src="/js/oasis.js"></script></html>