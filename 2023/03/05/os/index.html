<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><title>Operating System │ hh-blog</title><link rel="stylesheet" href="/css/oasis.css"><meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="hh-blog" type="application/atom+xml">
</head><body><div id="content"><h1 id="title">Operating System</h1><div id="menu-outer"><nav id="menu-inner"><a id="menu-back" href="javascript:history.back()">Back</a><time datetime="2023-03-04T16:03:53.000Z">2023-03-05</time></nav></div><div id="content-outer"><div id="content-inner"><article id="post"><blockquote>
<p>持续更新</p>
<p>lab待更新</p>
</blockquote>
<h2 id="操作系统概论"><a href="#操作系统概论" class="headerlink" title="操作系统概论"></a>操作系统概论</h2><h3 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h3><h3 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h3><h4 id="abstraction"><a href="#abstraction" class="headerlink" title="abstraction"></a>abstraction</h4><p>• <strong>Threads</strong> abstract the CPU.<br>• <strong>Address spaces</strong> abstract memory.<br>• <strong>Files</strong> abstract the disk.<br>• <strong>Processes</strong> abstract of the computer.<br>• <strong>Input&#x2F;Outputs</strong> abstract the devices</p>
<p>抽象是简化复杂事务，虚拟化是凭空创造不存在的东西</p>
<h4 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h4><p>文件描述符在形式上是一个非负整数。 实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。 当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。 在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。</p>
<p>文件类型：普通文件（包含用户信息的文件，用户可以对这些文件进行各种操作-添加、修改、删除等），目录文件（包含文件名列表和这些文件相关的其他信息），特殊文件（设备文件，device files，printers，tapes）</p>
<h3 id="计算机启动"><a href="#计算机启动" class="headerlink" title="计算机启动"></a>计算机启动</h3><p>加电置固定指令地址，执行BIOS固件自检，加载mbr，loader在其中被成功加载，loader加载kernel</p>
<p>• —&gt; Start BIOS (Basic Input Output System)<br>• —&gt; Check the RAM and basic devices, e.g., keyboard<br>• —&gt; Scan the PCIe and PCI buses to detect all the<br>other devices.<br>• —&gt; Select boot device from CMOS<br>• —&gt; The boot loader starts to find the OS<br>• —&gt; OS is loaded, configures necessary information,<br>and gets the control of the computer</p>
<h3 id="保护"><a href="#保护" class="headerlink" title="保护"></a>保护</h3><h4 id="cpu保护"><a href="#cpu保护" class="headerlink" title="cpu保护"></a>cpu保护</h4><h4 id="memory保护"><a href="#memory保护" class="headerlink" title="memory保护"></a>memory保护</h4><h4 id="中断保护"><a href="#中断保护" class="headerlink" title="中断保护"></a>中断保护</h4><h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><h4 id="中断处理"><a href="#中断处理" class="headerlink" title="中断处理"></a>中断处理</h4><h5 id="实模式和保护模式"><a href="#实模式和保护模式" class="headerlink" title="实模式和保护模式"></a>实模式和保护模式</h5><p>8086内置4个段寄存器（代码段CS，数据段DS，堆栈段SS，附加段ES），每个段寄存器可以存放一个16位的段地址，在寻址时，处理器首先将段地址左移4位，然后再加上偏移地址，由此得到20位的物理地址（如 1234H:5678H所对应的物理地址为12340H+5678H&#x3D;179B8H，其中， 1234H:5678H称作逻辑地址或虚地址）。当地址有溢出时（FFFFH:FFFFH 对应的物理地址是FFFF0H+FFFFH&#x3D;10FFEFH，大于FFFFFH），会发生<strong>回卷</strong>（10FFEFH &#x3D; FFF0H）。</p>
<p>如此寻址会产生很多问题。一个段大小最大为2^16&#x3D;64KiB，并且，所有的段都是可读写的。这意味着不同的段存在着重叠部分（即不同的逻辑地址可以映射到相同的物理地址），无法保证程序的安全性（程序段可被修改），也不具有权限分级（大家都有读写权限，另，那时真的有权限这个概念么）。</p>
<p>在实模式中，段寄存器保存的是段首地址（左移4位以后），而在保护模式，其中保存的内容称作选择器（selector），其本质是索引（13位，即在表中的偏移量）加TI位（1位，表示是使用GDT还是LDT）和优先级信息（2位，0~3值越小优先级越高）。</p>
<p>　　在寻址时，首先拿出选择器（段寄存器）的高13位作为偏移量（索引），结合TI位找到描述符。取出其中24位长的段首地址信息，再加上偏移量（这个偏移量是段地址:偏移量 中的偏移量，前面提到的描述符表的偏移量是段地址的高13位），得到实际物理地址。</p>
<p>　　简单来说，286保护模式下的寻址步骤是：拿到段寄存器高14位（13+1），查描述符表，得到24位段地址，加上偏移量，得到物理地址。当然，其中还有保护机制，这里没有说明。</p>
<p>段选择子存在段寄存器中，16位&#x3D;13位index+1位TI+2位privilege，TI -table indicator位表示该段选择子为全局段还是局部段，RPL 表示该段选择子的特权等级，13位Index表示描述符表中的编号（下标），拿index去段描述符表找段描述符，根据段描述符结构找段基址加偏移量即可。</p>
<h3 id="顶级会议期刊"><a href="#顶级会议期刊" class="headerlink" title="顶级会议期刊"></a>顶级会议期刊</h3><p>会议</p>
<p>(SOSP)  ACM Symposium on Operating Systems Principles<br>(OSDI)  USENIX symposium on Operating Systems Design and Implementation<br>(ASPLOS) ACM International Conference on Architectural Support for Programming<br>Languages and Operating Systems<br>(ATC) USENIX Annual Technical Conference<br>(FAST) USENIX Conference on File and Storage Technologies<br>(Eurosys)  Proceedings of the European Conference on Computer Systems<br>(NSDI) USENIX Symposium on Networked Systems Design and Implementation<br>(ISCA) International Symposium on Computer Architecture<br>(MICRO) International Symposium on Microarchitecture</p>
<p>期刊</p>
<p>(TOCS) ACM Transactions on Computer Systems<br>(OSR)   ACM SIGOPS Operating Systems Review<br>(TOC)   IEEE Transactions on Computer<br>(TPDS) IEEE Transactions on Parallel and Distributed Systems</p>
<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>进程状态</p>
<ul>
<li><code>R</code>(TASK_RUNNING，可执行状态)，这个进程是可运行的——要么它正在运行，要么在运行队列中等待运行；</li>
<li><code>S</code>(TASK_INTERRUPTIBLE，中断状态)，这个状态的进程因为等待某事件的发生（比如等待socket连接、等待信号量等）而被挂起，然后当这些事件发生或完成后，对应的等待队列中的一个或多个进程将被唤醒。</li>
<li><code>D</code>(TASK_UNINTERRUPTIBLE，不可中断状态)，在进程接收到信号时，不会被唤醒变成可运行的。除了这一点，该状态和TASK_INTERRUPTIBLE其他部分完全一样，这个状态通常用于进程必须不间断等待或者事件发生的频率很快，并且无法用kill命令关闭处于TASK_UNINTERRUPTIBLE状态的进程。</li>
<li><code>T</code>(TASK_STOPPED或TASK_TRACED，暂停状态或跟踪状态)，该状态表示该进程已经停止执行，并且不具有再次执行的条件。向进程发送一个SIGSTOP信号，它就会因响应该信号而进入TASK_STOPPED状态（除非该进程本身处于TASK_UNINTERRUPTIBLE状态而不响应信号）。而当进程正在被跟踪时，它处于TASK_TRACED状态。</li>
<li><code>Z</code>(TASK_DEAD或EXIT_ZOMBIE，退出状态)，进程在退出的过程中，处于TASK_DEAD状态，如果它的父进程没有收到SIGCHLD信号，故未调用wait（如wait4、waitid）处理函数等待子进程结束，又没有显式忽略该信号，它就一直保持EXIT_ZOMBIE状态。只要父进程不退出，这个EXIT_ZOMBIE状态的子进程就一直存在，这也就是所谓的”僵尸”进程。</li>
<li><code>X</code>(TASK_DEAD - EXIT_DEAD，退出状态)，进程即将被销毁。EXIT_DEAD状态是非常短暂的，几乎不可能通过ps命令捕捉到。</li>
</ul>
<p>对应状态码</p>
<table>
<thead>
<tr>
<th>状态</th>
<th>定义</th>
</tr>
</thead>
<tbody><tr>
<td>R</td>
<td>Running.运行中</td>
</tr>
<tr>
<td>S</td>
<td>Interruptible Sleep.等待调用</td>
</tr>
<tr>
<td>D</td>
<td>Uninterruptible Sleep.等待磁盘IO</td>
</tr>
<tr>
<td>T</td>
<td>Stoped.暂停或者跟踪状态</td>
</tr>
<tr>
<td>X</td>
<td>Dead.即将被撤销</td>
</tr>
<tr>
<td>Z</td>
<td>Zombie.进程已经结束，仅映像名留存，所谓的僵尸进程</td>
</tr>
<tr>
<td>W</td>
<td>Paging.内存交换</td>
</tr>
<tr>
<td>N</td>
<td>优先级低的进程</td>
</tr>
<tr>
<td>&lt;</td>
<td>优先级高的进程</td>
</tr>
<tr>
<td>s</td>
<td>进程的领导者</td>
</tr>
<tr>
<td>L</td>
<td>锁定状态</td>
</tr>
<tr>
<td>l</td>
<td>多线程状态</td>
</tr>
<tr>
<td>+</td>
<td>前台进程</td>
</tr>
</tbody></table>
<p><img src="/os/image-20230220203818283.png" alt="image-20230220203818283"></p>
<p><img src="/os/image-20230220203847820.png" alt="image-20230220203847820"></p>
<h4 id="fork和exec"><a href="#fork和exec" class="headerlink" title="fork和exec"></a>fork和exec</h4><p><strong>父进程中调用fork之前打开的所有描述符在fork返回之后由子进程分享</strong>。我们将看到网络服务器利用了这个特性：父进程调用accept之后调用fork。所接受的已连接套接字随后就在进程与子进程之间共享。通常情况下，子进程接着读写这个已连接套接字，父进程则关闭这个已连接套接字。</p>
<p>fork的两个典型用法：</p>
<p>（1）一个进程创建一个自身的副本，这样每个副本都可以在另一个副本执行其他任务的同时处理各自的某个操作。这是网络服务器的典型用法。</p>
<p>（2）一个进程想要执行另一个程序。既然创建新进程的唯一方法是调用fork，该进程于是首先调用fork创建一个自身的副本，然后其中一个副本（通常是子进程）调用exec把自身替换成新的程序。这是诸如shell之类程序的典型用法。</p>
<p> fork() 函数用于创建一个新的子进程，该子进程几乎复制了父进程的全部内容，但是，这个新创建的子进程如何执行呢？exec 函数族就提供了一个在进程中启动另一个程序执行的方法。它可以根据指定的文件名或目录名找到可执行文件，并用它来取代原调用进程的数据段、代码段和堆栈段，在执行完之后，原调用进程的内容除了进程号外，其他全部被新的进程替换了。另外，这里的可执行文件既可以是二进制文件，也可以是Linux下任何可执行的脚本文件。</p>
<p>pid&#x3D;fork()后，父进程中pid&gt;0，子进程pid&#x3D;0</p>
<p> 在 Linux 中使用exec函数族主要有两种情况：</p>
<p> ● 当进程认为自己不能再为系统和用户做出任何贡献时，就可以调用 exec 函数族中的任意一个函数让自己重生。</p>
<p> ● 如果一个进程想执行另一个程序，那么它就可以调用 fork() 函数新建一个进程，然后调用 exec 函数族中的任意一个函数，这样看起来就像通过执行应用程序而产生了一个新进程（这种情况非常普遍）。</p>
<p>exec函数族的6个函数的区别在于：（a）待执行的程序文件是由文件名（filename）还是由路径名（pathname）指定；（b）新程序的参数是一一列出还是由一个指针数组来引用；（c）把调用进程的环境传递给新程序还是给新程序指定新的环境。</p>
<p>  事实上，这6个函数中真正的系统调用只有execve()，其他5个都是库函数，它们最终都会调用execve()这个系统调用。在使用exec函数族时，一定要加上错误判断语句。exec 很容易执行失败，其中最常见的原因有：</p>
<p>  ① 找不到文件或路径，此时 errno 被设置为 ENOENT。</p>
<p>  ② 数组argv 和envp 忘记用NULL结束，此时，errno被设置为 EFAUL。</p>
<p>  ③ 没有对应可执行文件的运行权限，此时 errno 被设置为EACCES。</p>
<p>这些函数只有在出错时才返回到调用者，否则，控制将被传递给新程序的起始点，通常就是main函数。</p>
<p><img src="/os/img_482b1b02600a23a91f60ec4b6a5b3d93.png" alt="img"></p>
<p><img src="/os/img_2c2d6737253b339a8e36de68ecb8f5f7.png" alt="img"></p>
<p>exec可以更改和继承的包括以下单不限于以下的上下文内容：</p>
<p>• File descriptors<br>• User&#x2F;group ID<br>• Process group and session IDs<br>• Current directory<br>• Resource limits<br>• Scheduling priority and affinity</p>
<h4 id="IDLE进程"><a href="#IDLE进程" class="headerlink" title="IDLE进程"></a>IDLE进程</h4><p>没有处于<code>RUNNABLE</code>状态的进程时切换至内核IDLE进程，该进程调⽤ <code>waitForInterrupt()</code> 执⾏ <code>hlt</code> 指令， <code>hlt</code> 会使得CPU进⼊暂停状态，直到外部硬件中断产⽣</p>
<p>执⾏流在bootloader中加载并跳转到内核， 然后执⾏⼀系列 的初始化⼯作，等到初始化结束后将会打开中断，此时执⾏流摇身⼀变，成为了实验中 的IDLE进程，等待中断的到来</p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">waitForInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
 <span class="token keyword">asm</span> <span class="token keyword">volatile</span><span class="token punctuation">(</span><span class="token string">"hlt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
 <span class="token function">waitForInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<h4 id="Modeling-Multiprogramming"><a href="#Modeling-Multiprogramming" class="headerlink" title="Modeling Multiprogramming"></a>Modeling Multiprogramming</h4><p>多道程序设计模型</p>
<h4 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h4><p>context switch &amp; CPU switch</p>
<p><img src="/os/image-20230220215650198.png" alt="image-20230220215650198"></p>
<h4 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h4><p>interprocess communication</p>
<p>典型进程间通信模式</p>
<ul>
<li>生产者-消费者模式</li>
<li>生产者只写，消费者只读</li>
<li>缓冲区无限大时：生产者不停写，消费者只在缓冲区存在内容时读</li>
<li>缓冲区有限大：生产者在缓冲区未满时写，消费者只在缓冲区存在内容时读</li>
</ul>
<p>两种通信方法：</p>
<p><img src="/os/image-20230222155244306.png" alt="image-20230222155244306"></p>
<ul>
<li><p>共享内存</p>
<p>通信由用户程序控制而非操作系统，难点在于内存一致性（同步）</p>
<p>可用循环数组和两个逻辑指针来表示</p>
<pre class="language-c" data-language="c"><code class="language-c">item next_produced<span class="token punctuation">;</span>  
<span class="token keyword">while</span> <span class="token punctuation">(</span>true<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> 
  <span class="token comment">/* produce an item in next produced */</span> 
  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>in <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> BUFFER_SIZE<span class="token punctuation">)</span> <span class="token operator">==</span> out<span class="token punctuation">)</span> <span class="token comment">//buffer full</span>
  <span class="token punctuation">;</span> <span class="token comment">/* do nothing */</span> 
  buffer<span class="token punctuation">[</span>in<span class="token punctuation">]</span> <span class="token operator">=</span> next_produced<span class="token punctuation">;</span> 
  in <span class="token operator">=</span> <span class="token punctuation">(</span>in <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> BUFFER_SIZE<span class="token punctuation">;</span> 
<span class="token punctuation">&#125;</span>

item next_consumed<span class="token punctuation">;</span>  
<span class="token keyword">while</span> <span class="token punctuation">(</span>true<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> 
  <span class="token keyword">while</span> <span class="token punctuation">(</span>in <span class="token operator">==</span> out<span class="token punctuation">)</span> <span class="token comment">//buffer empty</span>
  <span class="token punctuation">;</span> <span class="token comment">/* do nothing */</span> 
  next_consumed <span class="token operator">=</span> buffer<span class="token punctuation">[</span>out<span class="token punctuation">]</span><span class="token punctuation">;</span> 
  out <span class="token operator">=</span> <span class="token punctuation">(</span>out <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> BUFFER_SIZE<span class="token punctuation">;</span> 
  <span class="token comment">/* consume the item in next consumed */</span> 
<span class="token punctuation">&#125;</span></code></pre>

<p>或者用个计数器counter（不能循环）</p>
<ul>
<li><p>race condition</p>
<p>竞争危害&#x2F;条件，在计算机系统中实现时，可能会因为生产者与消费者采用不同寄存器短时间内调取同一counter值增加和减少而产生counter的错误修改，但第一种方法不会产生这种危害，两个process的工作是解耦的，没有counter联系</p>
</li>
</ul>
</li>
<li><p>消息传递</p>
<p>建立通信链接（</p>
<p>•Hardware bus<br>•Network<br>•Shared memory），通过send&#x2F;receive传递信息</p>
<p>直接通信：•send (P , message) – send a message to process P<br>•receive(Q, message) – receive a message from process Q<br>​	链接自动建立，一个链接对应一对通信进程</p>
<p>间接通信：mailboxes (also referred to as ports)，共享特定端口通信，端口可关联多个进程，每对进程可共享多个通信链路</p>
<p>链路均可全双工，也可半双工</p>
<p>阻塞（同步，发送后等待收到才再次发送），非阻塞（异步，send and continue），可搭配组合，接收发送全阻塞时可称为rendezvous（约定）</p>
<p>异常情况</p>
</li>
<li><p>比较：内存共享更快，消息传递需要重复sys调用，但消息传递在分布式系统中更容易实现，不用考虑内存冲突、一致性问题，适用于交换少量数据，多核系统中也更实用</p>
</li>
<li><p>例子：POSIX-内存共享，sockets，pipes，named pipes ，signals</p>
</li>
</ul>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>fork() 等同于 clone(2)，2代指SIGCHILD</p>
<p><code>pthread_atfork(3)</code></p>
<p>Native POSIX Thread Library (NPTL), a Linux implementation of POSIX thread library</p>
<p>线程是代表一个独立、可调度任务的一个可执行指令序列的抽象</p>
<h4 id="motivation-and-usage"><a href="#motivation-and-usage" class="headerlink" title="motivation and usage"></a>motivation and usage</h4><p>解决MTAO（multiple things at once）</p>
<p>操作系统提供的<strong>并发单位</strong>，抽象来说就是并发（concurrency）机制的体现</p>
<p>并发不一定并行（parallelism），但是并行一定并发</p>
<p>semi-process，轻型进程，不同线程共享地址空间，共享所有数据</p>
<h4 id="model"><a href="#model" class="headerlink" title="model"></a>model</h4><p>一个进程中所有线程共享的item：address space，global variables，open files ，child processes，pending alarms（未决警报），signals and signal handlers，accounting info</p>
<p>线程单独享有item：program counter（pc），registers，stack，state</p>
<p><img src="/os/image-20230223140243880.png" alt="image-20230223140243880"></p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">/*basic options*/</span>

<span class="token function">thread_create</span><span class="token punctuation">(</span>thread<span class="token punctuation">,</span> func<span class="token punctuation">,</span> arg<span class="token punctuation">)</span> 
<span class="token comment">//creates a new thread in thread, which will execute function func with arguments arg.</span>
    
<span class="token function">thread_yield</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 
<span class="token comment">//calling thread gives up the processor. </span>
    
<span class="token function">thread_join</span><span class="token punctuation">(</span>thread<span class="token punctuation">)</span> 
<span class="token comment">//wait for thread to finish, get the value thread returned. </span>
    
<span class="token function">thread_exit</span><span class="token punctuation">(</span>ret<span class="token punctuation">)</span> 
<span class="token comment">//quit the current thread and clean up, make ret available to any successful join (wait for this thread).	</span></code></pre>

<p>TCB（thread control block）</p>
<p>五个状态：</p>
<ul>
<li><p>init</p>
<p>TCB: Ready List<br>Registers: In TCB</p>
</li>
<li><p>ready</p>
<p>TCB: Ready List<br>Registers: In TCB</p>
</li>
<li><p>TCB: Running List<br>Registers: Processor</p>
</li>
<li><p>running</p>
<p>TCB: Running List<br>Registers: Processor</p>
</li>
<li><p>waiting</p>
<p>TCB: Synchronization waiting list<br>Registers: TCB</p>
</li>
<li><p>finished</p>
<p>TCB: Finished List (to pass exit value), then deleted<br>Registers: TCB</p>
</li>
</ul>
<p><img src="/os/image-20230223162027236.png" alt="image-20230223162027236"></p>
<h4 id="POSIX"><a href="#POSIX" class="headerlink" title="POSIX"></a>POSIX</h4><p><img src="/os/image-20230223182454862.png" alt="image-20230223182454862"></p>
<h4 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h4><p>user-level：<img src="/os/image-20230224004956083.png" alt="image-20230224004956083">thread call，context switch均在user-level，快、可用户自定义调度线程、kernel复杂度低，kernel 单线程；</p>
<p>缺点在于一个线程阻塞，整个进程阻塞，kernel只能做<strong>次</strong>优化决策（ OS modifications to  overcome this. ），没有时间中断，当一个进程运行只能yield&#x2F;exit，其它线程才能切入执行</p>
<p>kernel-level：<img src="/os/image-20230224005424349.png" alt="image-20230224005424349"></p>
<p>内核能掌控线程信息，实现更好调度等优化，当线程频繁阻塞时很重要</p>
<p>缺点在于 High overhead ，OS更复杂</p>
<p>hybrid：<img src="/os/image-20230224005624816.png" alt="image-20230224005624816"></p>
<p>1对1，多对一</p>
<p>context switch in kernel threads：</p>
<p>thread running-&gt;switch to kernel-&gt;save thread state to TCB-&gt;choose new thread(policy decision left to scheduler)-&gt;load thread state from TCB-&gt;thread running</p>
<p>引起上下文切换的可能：内部系统调用&#x2F;异常，外部中断<img src="/os/image-20230224010419087.png" alt="image-20230224010419087"></p>
<p>context switch in user threads：</p>
<p><strong>没有操作系统支持</strong></p>
<p>•TCBs，就绪列表，完成列表，等待列表-在用户空间</p>
<p>•线程库调用只是过程调用</p>
<p>有OS支持：</p>
<p>•使用上行调用（upcalls）虚拟化中断和异常</p>
<p>​	•使用系统调用注册一个信号处理程序（signal handler）</p>
<p>​	•中断时，内核暂停进程执行，保存进程P状态并运行内核处理器；完成后：</p>
<p>​		•将P的保存状态复制到P的信号堆栈中</p>
<p>​		•在信号处理程序中恢复P的执行(load state with PC &#x3D; &amp;signal_handler;SP -&gt; state on stack)</p>
<p>​		•信号处理器将状态从堆栈移动到TCB</p>
<p>​		•在就绪列表中恢复其他一些TCB的状态</p>
<h4 id="Pop-Up"><a href="#Pop-Up" class="headerlink" title="Pop-Up"></a>Pop-Up</h4><p>使用这种弹出式线程的优点是每个新请求都将被快速处理，几乎是即时的(这取决于服务器的当前负载)。<img src="/os/image-20230224011409711.png" alt="image-20230224011409711"></p>
<p>To see thread information<br><code>ps -m</code></p>
<p><code>ps m –o pid,tid,command</code> </p>
<h2 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Simplified view of scheduling:  </p>
<ul>
<li>Save process state (to PCB)  </li>
<li><strong>Pick a process to run next</strong>  </li>
<li>Dispatch process</li>
</ul>
<h4 id="调度时机"><a href="#调度时机" class="headerlink" title="调度时机"></a>调度时机</h4><p>1.新进程产生</p>
<p>2.进程死亡并返回exit状态</p>
<p>3.进程阻塞</p>
<p>4.I&#x2F;O 中断</p>
<p>5.时钟中断，例-抢占式调度程序使用它来替换正在运行的进程</p>
<h4 id="调度算法类别"><a href="#调度算法类别" class="headerlink" title="调度算法类别"></a>调度算法类别</h4><p>抢占式&#x2F;非抢占式</p>
<ol>
<li>Batch. </li>
<li>Interactive. </li>
<li>Real time</li>
</ol>
<h4 id="调度算法目标"><a href="#调度算法目标" class="headerlink" title="调度算法目标"></a>调度算法目标</h4><p>总的来说：公平性，cpu高利用率<img src="/os/image-20230224014748060.png" alt="image-20230224014748060"></p>
<p>针对不同的系统又有不同的要求</p>
<h4 id="不同系统下的调度"><a href="#不同系统下的调度" class="headerlink" title="不同系统下的调度"></a>不同系统下的调度</h4><h5 id="批处理系统调度"><a href="#批处理系统调度" class="headerlink" title="批处理系统调度"></a>批处理系统调度</h5><p>• First-Come First-Served<br>• Shortest Job First<br>• Shortest Remaining Time Next</p>
<h5 id="交互式系统调度"><a href="#交互式系统调度" class="headerlink" title="交互式系统调度"></a>交互式系统调度</h5><p>• Round-Robin Scheduling<br>• Priority Scheduling<br>• Multilevel Queues<br>• Multilevel Feedback Queue<br>• Guaranteed Scheduling<br>• Lottery Scheduling</p>
<h5 id="实时系统调度"><a href="#实时系统调度" class="headerlink" title="实时系统调度"></a>实时系统调度</h5><p> Time plays an essential role </p>
<ul>
<li>having the right answer but having it too late is<br>often just as bad as not having it at all.</li>
</ul>
<h4 id="策略和机制"><a href="#策略和机制" class="headerlink" title="策略和机制"></a>策略和机制</h4><h3 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h3><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><h4 id="评估"><a href="#评估" class="headerlink" title="评估"></a>评估</h4><h2 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>进程&#x2F;线程同步（并发控制）和数据同步（数据一致性，完整性）</p>
<p>为什么需要同步？</p>
<ul>
<li>线程调度不确定，每次运行程序都可能产生不一样的情况，比如出现不同的并发情况，调度器做出不同决策，cpu以不同频率运行，缓存命中率不同</li>
<li>编译器&#x2F;硬件优化，指令重排，影响多线程程序（对单线程基本安全）</li>
</ul>
<p>多字操作不是原语（atomic）</p>
<h3 id="竞争条件"><a href="#竞争条件" class="headerlink" title="*竞争条件"></a>*竞争条件</h3><p>生产者和消费者并发，不同寄存器调用counter旧值</p>
<h3 id="临界区（Critical-Sections-）"><a href="#临界区（Critical-Sections-）" class="headerlink" title="临界区（Critical Sections ）"></a>临界区（Critical Sections ）</h3><p>每个进程中访问共享数据资源的一段代码，称为临界区</p>
<p>当有进程正在执行自己的临界区代码（访问共享数据）时，其它进程不能执行临界区代码</p>
<p>避免竞态条件的要求：</p>
<p>1.没有两个进程可以同时在它们的关键区域内。(safety)</p>
<p>2.对于速度或cpu的数量，不做任何假设（即考虑速度和CPU数量为任何的情况）。</p>
<p>3.任何运行在其临界区之外的进程都不能阻塞其他进程。（可发展的-progress）</p>
<p>4.任何进程都不应该永远等待进入临界区域。(活性-liveness)</p>
<p><img src="/os/image-20230224204802503.png" alt="image-20230224204802503"></p>
<h3 id="忙等待互斥（Mutual-Exclusion-with-Busy-Waiting-）"><a href="#忙等待互斥（Mutual-Exclusion-with-Busy-Waiting-）" class="headerlink" title="*忙等待互斥（Mutual Exclusion with Busy Waiting ）"></a>*忙等待互斥（Mutual Exclusion with Busy Waiting ）</h3><h4 id="实现忙等待互斥的方法"><a href="#实现忙等待互斥的方法" class="headerlink" title="实现忙等待互斥的方法"></a>实现忙等待互斥的方法</h4><ul>
<li><p>在一个进程进入临界区时禁用中断（弊大于利，长时间禁用中断会产生很多麻烦）</p>
</li>
<li><p>设置锁-变量（Lock Variables ），进程进入临界区时把锁变量置为1，把集中在共享变量的问题转移到锁变量上而已</p>
</li>
<li><p>Strict Alternation，严格交替<img src="/os/image-20230224210033056.png" alt="image-20230224210033056">但是也存在问题：当一个进程执行特别快，在另一个进程仍在执行非临界区代码时，这个进程已经接过接力棒执行完自身临界区代码和非临界区代码，回到下一轮临界区入口前，它此时需要阻塞自己等待另一个进程执行完当前轮次和下一轮次（仅有两个进程时的讨论），这就违背了避免竞态条件第三原则——任何执行非临界区进程&#x2F;线程不得阻塞其它进程&#x2F;线程。</p>
</li>
<li><p>Peterson’s Solution：皮特森方案，连接两个思想：严格交替和锁变量。<img src="/os/image-20230224212834124.png" alt="image-20230224212834124"></p>
<p>核心在于turn&#x3D;&#x3D;process&amp;&amp;interested[other]==true时等待，前者保证多个进程并发时，最先改写turn值的进程会进入临界区，另一个会阻塞，后者保证进入非临界区时，interest会置为false，不会阻塞其它进程</p>
<p><strong>扩展到N个线程互斥访问一个资源的filter算法[维基百科]</strong></p>
<pre class="language-none"><code class="language-none">&#x2F;&#x2F; initialization
level[N] &#x3D; &#123; -1 &#125;;     &#x2F;&#x2F; current level of processes 0...N-1
waiting[N-1] &#x3D; &#123; -1 &#125;; &#x2F;&#x2F; the waiting process of each level 0...N-2

&#x2F;&#x2F; code for process #i
for(l &#x3D; 0; l &lt; N-1; ++l) &#123; &#x2F;&#x2F; go through each level
    level[i] &#x3D; l;
    waiting[l] &#x3D; i;
    while(waiting[l] &#x3D;&#x3D; i &amp;&amp;
          (there exists k ≠ i, such that level[k] ≥ l)) &#123;
        &#x2F;&#x2F; busy wait
    &#125;
&#125;

&#x2F;&#x2F; critical section

level[i] &#x3D; -1; &#x2F;&#x2F; exit section</code></pre>

<p>数组level表示每个线程的等待级别，最小为0，最高为N-1，-1表示未设置。数组waiting模拟了一个阻塞（忙等待）的线程队列，从位置0为入队列，位置越大则入队列的时间越长。每个线程为了进入临界区，需要在队列的每个位置都经过一次，如果没有更高优先级的线程（考察数组level），cd 或者被后入队列的线程推着走（上述程序waiting[l] ≠ i），则当前线程在队列中向前走过一个位置。可见该算法满足互斥性。</p>
<p>由filter算法去反思Peterson算法，可见其中的flags（interested）数组表示两个进程的等待级别，而turn变量则是阻塞（忙等待）的线程队列，这个队列只需要容纳一个元素。</p>
</li>
</ul>
<h4 id="TSL指令：忙互斥的硬件实现"><a href="#TSL指令：忙互斥的硬件实现" class="headerlink" title="TSL指令：忙互斥的硬件实现"></a>TSL指令：忙互斥的硬件实现</h4><p>test and set lock (TSL)，硬件层面对“test” and “set” the flag的原子性实现</p>
<p>这个指令读取一个内存地址的内容，存到寄存器中，并在原地址存一个非零值，保证指令过程中其它进程不能访问该内存地址</p>
<pre class="language-asm" data-language="asm"><code class="language-asm">enter_region: 
tsl register, flag ; copy flag to register and set flag to 1 
cmp register, #0 ;was flag zero? 
jnz enter_region ;if flag was non zero, lock was set , so loop 
ret ;return (and enter critical region)

leave_region: 
mov flag, #0 ; store zero in flag 
ret ;return</code></pre>

<p>x86中采用XCHG作为代替（原子地交换两个变量的值），作用基本一致<img src="/os/image-20230224221753125.png" alt="image-20230224221753125"></p>
<p>以上方法本质都是忙等待：进入临界区前检查，不符合条件循环忙等待。</p>
<p>会出现priority inversion problem（优先级反转）的问题。</p>
<p>解决方法：优先级继承协议，允许一个任务继承它正在阻塞的最高优先级任务的优先级</p>
<p>eg.</p>
<table>
<thead>
<tr>
<th align="center">Job Name</th>
<th align="center">Priority</th>
</tr>
</thead>
<tbody><tr>
<td align="center">H</td>
<td align="center">High</td>
</tr>
<tr>
<td align="center">M</td>
<td align="center">Medium</td>
</tr>
<tr>
<td align="center">L</td>
<td align="center">Low</td>
</tr>
</tbody></table>
<p>假定L获取到共享资源后，H申请该资源不得而被阻塞。优先级继承协议把L的优先级升级到H的级别。M将不能<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%8A%A2%E5%8D%A0%E5%BC%8F%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%A4%84%E7%90%86">抢先</a>L因而M被阻塞。当L释放资源后，恢复到低优先级并唤醒H。H有高优先级因而抢先了L的执行权。随后M、L依次恢复执行。</p>
<h3 id="睡眠和唤醒"><a href="#睡眠和唤醒" class="headerlink" title="睡眠和唤醒"></a>睡眠和唤醒</h3><p>sleep, wakeup 不忙等待，不占用cpu</p>
<p>均含有参数——匹配sleep和wakeup的内存地址（指定进程）</p>
<p>生产者和消费者例子：</p>
<p>生产者向buffer增加item时（消费者减少item）检查buffer中的item count是不是等于n（0），如果是则sleep，否则正常操作；当从0到1（从n到n-1）时wakeup消费者（生产者）</p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> BUFFER_SIZE <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span> 
<span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">producer</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> 
  <span class="token keyword">int</span> item<span class="token punctuation">;</span> 
  <span class="token keyword">while</span><span class="token punctuation">(</span>TRUE<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> 
    <span class="token function">produce_item</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// generate next item </span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>count <span class="token operator">==</span> BUFFER_SIZE<span class="token punctuation">)</span> <span class="token function">sleep</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// if buffer full, go to sleep </span>
    <span class="token function">enter_item</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// put item in buffer </span>
    count<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment">// increment count </span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>count <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token function">wakeup</span><span class="token punctuation">(</span>consumer<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// was buffer empty? </span>
  <span class="token punctuation">&#125;</span> 
<span class="token punctuation">&#125;</span>
<span class="token keyword">void</span> <span class="token function">consumer</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> 
  <span class="token keyword">int</span> item<span class="token punctuation">;</span> 
  <span class="token keyword">while</span><span class="token punctuation">(</span>TRUE<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> 
    <span class="token keyword">if</span><span class="token punctuation">(</span>count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token function">sleep</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// if buffer is empty, sleep </span>
    <span class="token function">remove_item</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// remove item from buffer </span>
    count<span class="token operator">--</span><span class="token punctuation">;</span> <span class="token comment">// decrement count </span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>count <span class="token operator">==</span> BUFFER_SIZE <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token function">wakeup</span><span class="token punctuation">(</span>producer<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// was buffer full? </span>
    <span class="token function">consume_item</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// print item </span>
  <span class="token punctuation">&#125;</span> 
<span class="token punctuation">&#125;</span></code></pre>

<p>对于唯一的count，会产生类似的竞态条件问题</p>
<p>The Producer-Consumer Problem with spin lock protect，互斥锁的保护</p>
<pre class="language-asm" data-language="asm"><code class="language-asm">mutex_lock: 
TSL REGISTER,MUTEX  ;| copy mutex to register and set mutex to 1 
CMP REGISTER,#0  ;| was mutex zero? 
JNE mutex_ lock ;| mutex is busy; loop 
RET ;| return to caller; critical section entered 

mutex_unlock: 
MOVE MUTEX,#0  ;| store a 0 in mutex 
RET ;| return to caller </code></pre>

<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> BUFFER_SIZE <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span> 
<span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> 
<span class="token keyword">int</span> mutex <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  
<span class="token keyword">void</span> <span class="token function">producer</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> 
  <span class="token keyword">int</span> item<span class="token punctuation">;</span> 
  <span class="token keyword">while</span><span class="token punctuation">(</span>TRUE<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> 
    <span class="token function">produce_item</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// generate next item </span>
    <span class="token function">mutex_lock</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span> 
    <span class="token keyword">if</span><span class="token punctuation">(</span>count <span class="token operator">==</span> BUFFER_SIZE<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> 
        <span class="token function">mutex_unlock</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>  
        <span class="token function">sleep</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
        <span class="token function">mutex_lock</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span> 
    <span class="token punctuation">&#125;</span> <span class="token comment">// if buffer full, go to sleep </span>
    <span class="token function">enter_item</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// put item in buffer </span>
    count<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment">// increment count </span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>count <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token function">wakeup</span><span class="token punctuation">(</span>consumer<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// was buffer empty? </span>
    <span class="token function">mutex_unlock</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span> 
  <span class="token punctuation">&#125;</span> 
<span class="token punctuation">&#125;</span>
<span class="token comment">//...consumer略</span></code></pre>

<h3 id="条件变量"><a href="#条件变量" class="headerlink" title="*条件变量"></a>*条件变量</h3><p>一个自动unlock和sleep的原语</p>
<p>一个同步对象，使线程有效地等待由锁保护的共享状态的更改</p>
<p>含有三种方法：</p>
<p>•Wait(ConditionVariable *cv, Lock * lock):自动释放锁(解锁)，挂起调用线程的执行(sleep) -唤醒时重新获取锁</p>
<p>•Signal(ConditionVariable *cv):唤醒一个等待这个条件变量的等待者。如果等待列表中没有线程，则信号不起作用。</p>
<p>•Broadcast(ConditionVariable *cv):如果有，唤醒所有的等待者</p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> BUFFER_SIZE <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span> 
<span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> 
condition empty<span class="token punctuation">;</span> 
Condition full<span class="token punctuation">;</span> 
<span class="token keyword">int</span> mutex <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  
<span class="token keyword">void</span> <span class="token function">producer</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> 
  <span class="token keyword">int</span> item<span class="token punctuation">;</span> 
  <span class="token keyword">while</span><span class="token punctuation">(</span>TRUE<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> 
    <span class="token function">produce_item</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// generate next item </span>
    <span class="token function">mutex_lock</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span> 
    <span class="token keyword">if</span><span class="token punctuation">(</span>count <span class="token operator">==</span> BUFFER_SIZE<span class="token punctuation">)</span>  
        <span class="token function">wait</span><span class="token punctuation">(</span>full<span class="token punctuation">,</span> mutex<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// if buffer full, unlock, and go to sleep, when wakened -> lock </span>
    <span class="token function">enter_item</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// put item in buffer </span>
    count<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment">// increment count </span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>count <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token function">signal</span><span class="token punctuation">(</span>empty<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// was buffer empty? </span>
    <span class="token function">mutex_unlock</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span> 
  <span class="token punctuation">&#125;</span> 
<span class="token punctuation">&#125;</span>
<span class="token comment">//...consumer略</span></code></pre>

<p>条件变量没有memory，如果一个信号被发送到一个没有线程等待的条件变量，这个信号就会丢失。</p>
<p>Linux中的实现：an FUTEX (Fast User-space muTEX) approach</p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">//当且仅当地址addr的值等于val时，该操作使调用线程进入睡眠状态</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdatomic.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;time.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/futex.h></span></span>
<span class="token keyword">int</span> <span class="token function">futex_wait</span><span class="token punctuation">(</span>atomic_int <span class="token operator">*</span>addr<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> <span class="token function">sys_futex</span><span class="token punctuation">(</span>addr<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">//该操作唤醒在地址addr的futex上等待的线程</span>
<span class="token keyword">int</span> <span class="token function">futex_wake</span><span class="token punctuation">(</span>atomic_int <span class="token operator">*</span>addr<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> <span class="token function">sys_futex</span><span class="token punctuation">(</span>addr<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<p><img src="/os/image-20230225013245753.png" alt="image-20230225013245753"></p>
<p><img src="/os/image-20230225013301538.png" alt="image-20230225013301538"></p>
<p>锁的规则-Rules for locks：</p>
<ul>
<li><p>Lock is initially free </p>
</li>
<li><p>Always acquire before acces sing shared data structure </p>
</li>
<li><p>Beginning of procedure! </p>
</li>
<li><p>Always release after finishing with shared data </p>
<ul>
<li><p>End of procedure! </p>
</li>
<li><p>Only the lock holder can release </p>
<p>DO NOT throw lock for someone else to release</p>
</li>
</ul>
</li>
<li><p>Never access shared data without lock </p>
</li>
<li><p>Danger!</p>
</li>
</ul>
<p>Rules for Condition Variables：</p>
<ul>
<li>ALWAYS hold lock when calling wait, signal, broadcast <ul>
<li>Condition variable is sync FOR shared state </li>
<li>ALWAYS hold lock when accessing shared state</li>
</ul>
</li>
<li>Condition variable is memoryless <ul>
<li>If signal when no one is waiting, no operation </li>
<li>If wait before signal, waiter wakes up</li>
</ul>
</li>
<li>Wait atomically releases lock</li>
</ul>
<h3 id="信号量Semaphores"><a href="#信号量Semaphores" class="headerlink" title="*信号量Semaphores"></a>*信号量Semaphores</h3><p>同步变量，一个整数值，无法通过外界访问，只能通过Semaphore操作：初始化，PV原语（P(), (or down() or wait())，检验，V() (or up() or signal())，自增;）</p>
<p>•如果信号量为正值，则将其视为跟踪有多少“资源”或“未激活的解除阻塞”可用</p>
<p>•如果信号量为负值，则跟踪有多少线程正在等待资源或解除阻塞</p>
<p>•提供排序和计数(“剩余”事件&#x2F;资源)</p>
<h4 id="P（检验操作）"><a href="#P（检验操作）" class="headerlink" title="P（检验操作）"></a>P（检验操作）</h4><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">//阻塞版本：递减s，如果结果小于0 则阻塞</span>
<span class="token function">P</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">--</span>s <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> 
		  <span class="token function">block</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">//自旋版本：等s增到正值开始递减</span>
<span class="token function">P</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>s <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		s<span class="token operator">--</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<h4 id="V（自增操作）"><a href="#V（自增操作）" class="headerlink" title="V（自增操作）"></a>V（自增操作）</h4><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">//阻塞版本：递增s，如果结果小于等于0 则解除阻塞（代表此时无可用资源，有线程正在阻塞）</span>
<span class="token function">V</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">++</span>s <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> 
		  <span class="token function">unblock</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">//自旋版本：等s增到正值开始递减</span>
<span class="token function">V</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
	s<span class="token operator">++</span>
<span class="token punctuation">&#125;</span></code></pre>

<h4 id="生产者消费者版本"><a href="#生产者消费者版本" class="headerlink" title="生产者消费者版本"></a>生产者消费者版本</h4><pre class="language-c" data-language="c"><code class="language-c">semaphore empty <span class="token operator">=</span> N<span class="token punctuation">;</span> <span class="token comment">//可以理解为等待线程队列？</span>
semaphore full <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> 
<span class="token keyword">int</span> mutex <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  

<span class="token keyword">void</span> <span class="token function">producer</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> 
  <span class="token keyword">int</span> item<span class="token punctuation">;</span> 
  <span class="token keyword">while</span><span class="token punctuation">(</span>TRUE<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> 
    <span class="token function">produce_item</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token function">P</span><span class="token punctuation">(</span>empty<span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token function">mutex_lock</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span> 
    <span class="token function">enter_item</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token function">mutex_unlock</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span> 
    <span class="token function">V</span><span class="token punctuation">(</span>full<span class="token punctuation">)</span><span class="token punctuation">;</span> 
    <span class="token punctuation">&#125;</span> 
<span class="token punctuation">&#125;</span>

<span class="token keyword">void</span> <span class="token function">consumer</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> 
  <span class="token keyword">int</span> item<span class="token punctuation">;</span> 
  <span class="token keyword">while</span><span class="token punctuation">(</span>TRUE<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> 
    <span class="token function">P</span><span class="token punctuation">(</span>full<span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token function">mutex_lock</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span> 
    <span class="token function">remove_item</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token function">mutex_unlock</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span> 
    <span class="token function">V</span><span class="token punctuation">(</span>empty<span class="token punctuation">)</span><span class="token punctuation">;</span> 
    <span class="token function">consume_item</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span> 
    <span class="token punctuation">&#125;</span> 
<span class="token punctuation">&#125;</span></code></pre>

<p>使用了条件变量和互斥锁的信号量版本</p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;pthread.h></span></span>

<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">int</span> val<span class="token punctuation">;</span>
	<span class="token keyword">int</span> mutex<span class="token punctuation">;</span>
	condition cond<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>semaphore<span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span>semaphore <span class="token operator">*</span>s<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
 	s<span class="token operator">-></span>val <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">void</span> <span class="token function">P</span><span class="token punctuation">(</span>semaphore <span class="token operator">*</span>s<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	<span class="token function">mutex_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token punctuation">(</span>s<span class="token operator">-></span>mutex<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token operator">-></span>val <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token comment">//wait(ConditionVariables *cv, Lock *lock)</span>
		<span class="token function">wait</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token punctuation">(</span>s<span class="token operator">-></span>cond<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span>s<span class="token operator">-></span>mutex<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	s<span class="token operator">-></span>val<span class="token operator">--</span><span class="token punctuation">;</span>
	<span class="token function">mutex_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token punctuation">(</span>s<span class="token operator">-></span>mutex<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">void</span> <span class="token function">V</span><span class="token punctuation">(</span>semaphore <span class="token operator">*</span>s<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
        <span class="token function">mutex_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token punctuation">(</span>s<span class="token operator">-></span>mutex<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  	s<span class="token operator">-></span>val<span class="token operator">++</span><span class="token punctuation">;</span>
  	<span class="token function">singal</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token punctuation">(</span>s<span class="token operator">-></span>cond<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  	<span class="token function">mutex_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token punctuation">(</span>s<span class="token operator">-></span>mutex<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<h4 id="互斥锁、条件变量和信号量之间的区别"><a href="#互斥锁、条件变量和信号量之间的区别" class="headerlink" title="互斥锁、条件变量和信号量之间的区别"></a>互斥锁、条件变量和信号量之间的区别</h4><p>互斥锁用于进入临界区</p>
<p>条件变量用于睡眠和唤醒，以避免繁忙等待。</p>
<p>条件变量应该通过互斥锁来使用</p>
<p>信号量是一种更高的抽象，由条件变量、互斥锁和计数数(表示资源的数量，count number)实现</p>
<p>信号量可用于I&#x2F;O设备和等待I&#x2F;O完成的线程之间的同步通信。</p>
<p>—通常，硬件通过共享内存数据结构与设备驱动程序通信。</p>
<p>—该数据结构由硬件和内核同时读写</p>
<p>如果硬件设备需要提示（attention），例如，因为一个需要处理的网络数据包已经到达，或者磁盘请求已经完成，硬件就会更新共享数据结构并启动中断处理程序。</p>
<p>—中断处理程序通常很简单：它只是唤醒一个等待的线程并返回。</p>
<p>一个常见的解决方案是设备中断使用信号量。对于每个设备，分配一个信号量，初始值为0。</p>
<p>线程(进程)调用P，等待(挂起)设备完成某事。</p>
<p>设备完成后，中断将调用V，然后线程将再次准备好</p>
<h4 id="信号量的隐含危害"><a href="#信号量的隐含危害" class="headerlink" title="信号量的隐含危害"></a>信号量的隐含危害</h4><p>使用单独的锁和条件变量类使代码更具自文档性，更易于阅读。(既可以表示锁变量又可以表示条件变量的信号量可能不具有此优势)。</p>
<p>绑定到锁上的无状态条件变量比信号量(使用整数记录唤醒、休眠或资源的数量)是更好的广义等待抽象。</p>
<p>在使用信号量、锁、条件变量时，我们应该小心，因为简单的重新排序或缺少解锁都会导致非常糟糕的影响，导致程序行为的不正确。</p>
<h3 id="Monitors"><a href="#Monitors" class="headerlink" title="Monitors"></a>Monitors</h3><p>一个锁和零个或多个条件变量，用于管理对共享数据的并发访问</p>
<p>embedded in language：</p>
<p>​	•高级数据抽象，统一处理：共享数据，对它的操作，同步和调度</p>
<p>​		-数据结构上的所有操作都有一个(隐式)锁</p>
<p>​		-一个操作可以放弃控制并等待一个条件</p>
<p>​	•监视器是简单和安全的</p>
<p>​		-编译器可以检查，锁是隐式的(不能忘记)</p>
<p>​	•监视器有两种“等待”队列</p>
<p>​		-进入监视器：有一个线程队列等待获得互斥和进入</p>
<p>​		-条件变量：每个条件变量有一个线程队列等待相关的条件</p>
<p>…</p>
<h3 id="Barriers"><a href="#Barriers" class="headerlink" title="Barriers"></a>Barriers</h3><p>等待所有进程&#x2F;线程都到达计算点（at point in computation）后再继续</p>
<p>separate phases of a multi-phase algorithm （多阶段算法的分离阶段）</p>
<p>二元性和互斥：包括其余所有而非排除其余所有</p>
<p><img src="/os/image-20230225124327953.png" alt="image-20230225124327953"></p>
<p>…</p>
<h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><h4 id="作家读者问题"><a href="#作家读者问题" class="headerlink" title="作家读者问题"></a>作家读者问题</h4><p>特点</p>
<ul>
<li><p>允许多个线程同时read数据</p>
</li>
<li><p>同一时间仅能有一个writer写数据</p>
</li>
<li><p>writer写数据时不能有reader</p>
</li>
</ul>
<p>读写锁（RWLock）用来保护共享数据，实现了任意writer间的互斥和任意writer和reader间的互斥</p>
<p>…</p>
<ul>
<li><p>Avoiding Locks: Read-Copy-Update </p>
<p>reader应当可以选择查看旧值或writer实时更新的新值</p>
<p>RCU：reader与writer并发运，不显式地与writer同步</p>
<p>三大基本机制：发布-订阅机制，等待已存在的reader完成，维护最近更新对象的多个版本</p>
<p>…</p>
<p>宽限期：等reader读取完数据再删除（覆盖）旧数据</p>
<p>实现</p>
<pre class="language-none"><code class="language-none">•Readers disable interrupts on entry
           –Guarantees they complete critical section in a timely fashion
           –No read or write lock
•Writer
           –Acquire write lock
           –Compute new data structure
           –Publish new version with atomic instruction
           –Release write lock
           –Wait for Ume slice on each CPU
           –Only then, garbage collect old version of data structure</code></pre>

<p>RCU的局限：</p>
<p>它适用于Publish-Subscribe更新模式，当数据比较复杂时(比如双链表，需要同时更新两个指针)，使用RCU可能比较困难。</p>
<p>宽限期（grace period）可能太长(RCU提供了一个异步回调函数call_rcu())</p>
</li>
</ul>
<h4 id="哲学家就餐问题"><a href="#哲学家就餐问题" class="headerlink" title="哲学家就餐问题"></a>哲学家就餐问题</h4><p>圆桌，五个哲学家就坐，五盘意大利面，五个叉子放在间隙，每个哲学家需要两个叉子就餐</p>
<p>每个哲学家会进行以下循环：</p>
<p>– Think for a while<br>– Get 2 forks<br>– Eat for a while<br>– Put down the forks<br>– Repeat</p>
<p>设计Get 2 forks的方案</p>
<p>deadlock和starvation，死锁一定饿死，饿死不一定是死锁，死锁条件更强 。在饥饿状态下，线程在一段不确定的时间内无法取得进展。死锁是饥饿的一种形式，但条件更强:一组线程形成一个循环，其中没有一个线程取得进展，因为每个线程都在等待循环中的其他线程采取行动。</p>
<p>随即回退值</p>
<p>哲学家应当能互相沟通，当邻居哲学家正在吃时不应该拿叉子，沟通饿的意愿</p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">N</span> <span class="token expression"><span class="token number">5</span>  </span><span class="token comment">/* number of philosophers */</span> </span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">LEFT</span> <span class="token expression"><span class="token punctuation">(</span>i−<span class="token number">1</span><span class="token operator">+</span>N<span class="token punctuation">)</span><span class="token operator">%</span>N  </span><span class="token comment">/* number of i’s left neighbor */</span> </span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">RIGHT</span> <span class="token expression"><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span>N  </span><span class="token comment">/* number of i’s right neighbor */</span> </span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">THINKING</span> <span class="token expression"><span class="token number">0</span> </span><span class="token comment">/* philosopher is thinking */</span> </span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">HUNGRY</span> <span class="token expression"><span class="token number">1</span> </span><span class="token comment">/* philosopher is trying to get forks */</span>  </span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">EATING</span> <span class="token expression"><span class="token number">2</span>  </span><span class="token comment">/* philosopher is eating */</span></span>

<span class="token keyword">int</span> state<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token comment">/* array to keep track of everyone’s state */</span>
semaphore mutex <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>   <span class="token comment">/* mutual exclusion for critical regions */</span> 
semaphore s<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">/* one semaphore per philosopher */</span> 
 
<span class="token keyword">void</span> <span class="token function">philosopher</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  
   <span class="token keyword">while</span> <span class="token punctuation">(</span>TRUE<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> 
      <span class="token function">think</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
      <span class="token function">take_forks</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>  
      <span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
      <span class="token function">put_forks</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span> 
   <span class="token punctuation">&#125;</span>  
<span class="token punctuation">&#125;</span>

<span class="token keyword">void</span> <span class="token function">take_forks</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token comment">/* i: philosopher number, from 0 to N−1 */</span>
  mutex<span class="token punctuation">.</span><span class="token function">P</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">/* enter critical region */</span> 
  state<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> HUNGRY<span class="token punctuation">;</span>  <span class="token comment">/* record that philosopher i is hungry */</span>
  <span class="token function">test</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* try to acquire 2 forks */</span> 
  mutex<span class="token punctuation">.</span><span class="token function">V</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* exit critical region */</span> 
  s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">P</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* block if forks were not acquired */</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">void</span> <span class="token function">put_forks</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token comment">/* i: philosopher number, from 0 to N−1 */</span>
  mutex<span class="token punctuation">.</span><span class="token function">P</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">/* enter critical region */</span>
  state<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> THINKING<span class="token punctuation">;</span>  <span class="token comment">/* philosopher has finished eating */</span>
  <span class="token function">test</span><span class="token punctuation">(</span>LEFT<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* see if left neighbor can now eat */</span>
  <span class="token function">test</span><span class="token punctuation">(</span>RIGHT<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* see if right neighbor can now eat */</span> 
  mutex<span class="token punctuation">.</span><span class="token function">V</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* exit critical region */</span>  
<span class="token punctuation">&#125;</span> 

<span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token comment">/* i: philosopher number, from 0 to N−1 */</span>  
<span class="token punctuation">&#123;</span>  
   <span class="token keyword">if</span> <span class="token punctuation">(</span>state<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> HUNGRY <span class="token operator">&amp;&amp;</span> state<span class="token punctuation">[</span>LEFT<span class="token punctuation">]</span> <span class="token operator">!=</span> EATING <span class="token operator">&amp;&amp;</span>state<span class="token punctuation">[</span>RIGHT<span class="token punctuation">]</span> <span class="token operator">!=</span> EATING<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  
      state<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> EATING<span class="token punctuation">;</span>  
      s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">V</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
   <span class="token punctuation">&#125;</span>  
<span class="token punctuation">&#125;</span> </code></pre>



<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h3 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h3><p>可抢占资源和不可抢占资源，前者可从占有进程控制中直接夺走，而不会造成不良影响，后者反之</p>
<p>死锁通常涉及不可抢占资源，涉及可抢占资源的死锁通常可由重新将进程资源分配给另一个进程解决（因为资源可抢占）。</p>
<h3 id="死锁介绍"><a href="#死锁介绍" class="headerlink" title="*死锁介绍"></a>*死锁介绍</h3><p>一个集合的进程是死锁当且仅当：</p>
<ul>
<li>集合中每个进程均在等待某个事件（每个进程等待事件不必相同）</li>
<li>这个事件仅能被除当前阻塞进程外的进程触发</li>
</ul>
<p><strong>死锁的四个必要条件</strong>（并非充要条件）</p>
<ul>
<li><p>互斥（Mutual exclusion）：同一时间内，同一资源只能被一个进程使用。（或者有限个进程可以同时使用同一资源，但也可以理解为存在相同的多个资源）</p>
</li>
<li><p>持有并等待（Hold and wait）：一个持有至少一个资源的进程正在等待获得其他进程持有的额外资源。</p>
</li>
<li><p>不可抢占（No preemption）：进程所占资源仅能完成任务后自愿释放</p>
</li>
<li><p>环路等待（Circular wait condition）：存在一个集合{P0, P1，…，Pn}，其中n &gt; 1，P0等待P1持有的一个(或多个)资源，P1等待P2持有的一个(或多个)资源，…，Pn - 1等待Pn持有的一个(或多个)资源，Pn等待P0持有的一个(或多个)资源</p>
</li>
</ul>
<p>特殊情况：单进程也可能死锁——递归，此时可改锁为整数，锁自己时递增，解锁递减，为0时才真解锁</p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">// Thread A  </span>
function <span class="token function">callA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span> 
   lock<span class="token punctuation">.</span><span class="token function">acquire</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
   <span class="token function">callA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
   lock<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token punctuation">&#125;</span> 
<span class="token function">callA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>

<h3 id="建模"><a href="#建模" class="headerlink" title="建模"></a>建模</h3><p>Resource-Allocation Graph资源分配图</p>
<p>—圆:表示进程。</p>
<p>—正方形:资源。</p>
<p>—从资源节点(方形)到流程节点(圆形)的有向弧线表示该资源目前由该流程持有。</p>
<p>—从进程节点到资源节点的有向弧线表示进程当前正在阻塞等待该资源。</p>
<p>画有向图，有环则有死锁（同一类型资源有多个时则不一定）</p>
<h3 id="鸵鸟算法-死锁解决办法"><a href="#鸵鸟算法-死锁解决办法" class="headerlink" title="鸵鸟算法-死锁解决办法"></a>鸵鸟算法-死锁解决办法</h3><p>The ostrich algorithm ，忽略问题也许问题就会消失</p>
<p>—用于大多数操作系统，包括UNIX</p>
<p>•检测和恢复。让死锁发生，检测死锁并采取行动。</p>
<p>•确保系统永远不会进入死锁状态</p>
<p>​	-通过仔细分配资源来动态避免。</p>
<p>​	-预防，从结构上否定四个必要条件之一。</p>
<p>鸵鸟算法广泛使用在于死锁的危害和修复死锁所需要付出的代价之间的平衡。</p>
<h3 id="死锁检测和恢复"><a href="#死锁检测和恢复" class="headerlink" title="*死锁检测和恢复"></a>*死锁检测和恢复</h3><ul>
<li><p>每种类型一个资源-&gt;可以利用环路检测算法进行死锁检测</p>
<p>深度优先搜索</p>
<p>1.对于图中的每个节点(N)，以N为起始节点执行以下5步。</p>
<ol start="2">
<li>初始化L为空列表，并指定所有弧为未标记。</li>
<li>将当前节点添加到L的末端，检查节点现在是否出现在L中两次。如果是，则图包含一个循环(列在L中)，算法终止</li>
<li>从给定的节点，看看是否有任何未标记的输出弧线。如果是，请转步骤5;如果没有，请转步骤6。</li>
<li>随机选取未标记的出弧，标记出来。然后按照新的当前节点，转到步骤3。</li>
<li>如果这是初始节点，则图中不包含循环，算法终止。否则，含有死锁。删除它并返回到前一个节点</li>
</ol>
<p>但是不够优秀，存在很多冗余步骤，理论上复杂度为O(E+V)，所有顶点和边均遍历一遍即可。</p>
</li>
<li><p>每种类型一个资源每种类型多个资源-&gt;环路检测算法失效，需要利用基于资源分配矩阵、请求矩阵、可用向量的算法进行检测</p>
<p>…没看</p>
</li>
<li><p>恢复：抢占（Preemption），回滚（Rollback），杀死进程</p>
<ul>
<li>preemption：把资源抢走分配给另一个，原进程挂起，执行结束后再唤醒</li>
<li>rollback：设置检查点，存储进程状态（内存映像和资源状态，新旧检查点不能覆盖），回滚到占用资源之前的状态</li>
<li>终止所有涉及死锁的进程，可以一次解决或者每次终止一个（按进程优先级、进程运行时间、资源使用情况、待完成情况）</li>
</ul>
</li>
</ul>
<h3 id="死锁避免（Deadlock-Avoidance）"><a href="#死锁避免（Deadlock-Avoidance）" class="headerlink" title="*死锁避免（Deadlock Avoidance）"></a>*死锁避免（Deadlock Avoidance）</h3><p>通过合理分配资源来避免死锁（过去，进程一次请求全部资源，如今每次请求一个或几个资源）</p>
<p>资源轨迹（resource trajectories）</p>
<h4 id="安全状态（safe）、非安全状态（Unsafe）"><a href="#安全状态（safe）、非安全状态（Unsafe）" class="headerlink" title="安全状态（safe）、非安全状态（Unsafe）"></a>安全状态（safe）、非安全状态（Unsafe）</h4><ul>
<li><p>现有资源向量E，可用资源向量A，当前分配矩阵C，最大请求矩阵M，请求向量R</p>
<p><img src="/os/image-20230225213910159.png" alt="image-20230225213910159"></p>
</li>
</ul>
<p>…</p>
<h4 id="银行家算法（Banker’s-algorithm）"><a href="#银行家算法（Banker’s-algorithm）" class="headerlink" title="银行家算法（Banker’s algorithm）"></a>银行家算法（Banker’s algorithm）</h4><ul>
<li><p>检查是否允许请求导致不安全状态。</p>
<p>如果是，则拒绝请求。如果授予请求导致安全状态，则执行请求。</p>
</li>
</ul>
<p>剩余需求矩阵N，N[i][j] &#x3D; M[i][j]−C[i][j]</p>
<p>安全检查算法应:</p>
<p>1.尝试最坏的情况：让每个进程请求它们所需的最大资源。</p>
<p>2.调用死锁检测算法，如果它导致死锁，那么它是不安全的。</p>
<p>3.否则，它是安全的。</p>
<p>具体操作：</p>
<p>\1. 寻找一行N，其未满足的资源需求都小于或等于A。如果不存在这样的行，系统将最终死锁。</p>
<p>\2. 假设所选行的进程请求所需的所有资源并结束。将该进程标记为终止，将其资源添加到A向量。</p>
<p>3.重复步骤1和2，直到所有进程都标记为终止(安全状态)，或者没有可以满足资源需求的进程(死锁)。</p>
<h3 id="防止死锁"><a href="#防止死锁" class="headerlink" title="防止死锁"></a>防止死锁</h3><p>确保至少有一个条件从未被满足–互斥（Mutual exclusion）、持有并等待（Hold and wait）、不可抢占（No preemption）、环路等待（Circular wait condition）</p>
<p>…</p>
<h3 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h3><p>…</p>
<h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>…</p>
<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><h3 id="内存管理的功能"><a href="#内存管理的功能" class="headerlink" title="内存管理的功能"></a>内存管理的功能</h3><p>•当有多个进程正在使用内存和资源时，在主存中处理所有与内存相关的操作和资源</p>
<p>—跟踪内存的哪些部分正在使用</p>
<p>—在需要时为进程分配内存，并在它们完成时释放内存</p>
<p>—保护所需的内存以确保正确的操作</p>
<p>—扩展物理内存的限制</p>
<p>•最大化内存利用率和系统吞吐量</p>
<p>• Control &amp; Efficiency 控制与效率</p>
<h3 id="虚拟和物理地址空间"><a href="#虚拟和物理地址空间" class="headerlink" title="虚拟和物理地址空间"></a>虚拟和物理地址空间</h3><p>虚地址转换，MMU（Memory-Management Unit ），内存粒度</p>
<h3 id="进程级、分段和分页"><a href="#进程级、分段和分页" class="headerlink" title="*进程级、分段和分页"></a>*进程级、分段和分页</h3><h4 id="地址转换"><a href="#地址转换" class="headerlink" title="地址转换"></a>地址转换</h4><p>在物理内存中连续地分配地址空间</p>
<p>Base和Limit (Bound)：使用两个特殊的硬件寄存器来定义地址空间(动态重定位-dynamic relocation)•Base:进程在内存中开始的物理地址•Limit:内存区域的长度</p>
<p>非常简陋，保护几乎没有（粗粒度），不能增加堆栈，不能和其他进程共享代码</p>
<p>*分页</p>
<p>–页表和页表项</p>
<p>–页面共享</p>
<p>–写时复制 (Copy on Write)</p>
<p>–转换检测缓冲区&#x2F;快表 (TLB) 和 TLB Miss</p>
<p>–有效访问时间</p>
<p>–多级页表</p>
<p>–页面大小</p>
<p><img src="/os/image-20230226131832095.png" alt="image-20230226131832095"></p>
<h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="*虚拟内存"></a>*虚拟内存</h3><h4 id="缺页错误-Page-Fault-及其处理流程"><a href="#缺页错误-Page-Fault-及其处理流程" class="headerlink" title="缺页错误 (Page Fault) 及其处理流程"></a>缺页错误 (Page Fault) 及其处理流程</h4><p>处理页面错误的三个主要活动:•服务中断:仔细编码意味着只需要几百条指令•读取页面:大量时间•重新启动进程:少量时间</p>
<h4 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法:"></a>页面置换算法:</h4><p>FIFO：替换最老的</p>
<p>Optimal：替换长时间不使用的页面</p>
<p>Least Recently Used (LRU)：替换在大多数时间内未被使用的页面（需要计数器来统计）</p>
<p>Approximating LRU (Second Chane, NRU, Aging)：</p>
<ul>
<li><p>second chance</p>
<p>•当一个页面被引用(即读或写)时，引用位被设置为1(由硬件)</p>
<p>•如果要替换的页面有</p>
<p>​	•R &#x3D; 1(最近使用):设置R位为0;</p>
<p>​	•R &#x3D; 0:替换它</p>
<p>•如果所有页面都被引用，第二次机会&#x3D; FIFO</p>
</li>
<li><p>NRU：通过引用位+修改位(最近未使用，NRU)近似LRU:为那些修改的页面分配更高的优先级，以减少I&#x2F;O(增强的第二次机会)</p>
</li>
<li><p>aging：老化算法</p>
<p>通过额外的参考位：保持一个软件计数器来跟踪每个页面被引用的频率，并用最小的计数替换页面</p>
<p>•每个页面对应一个软件计数器</p>
<p>•在每次时钟中断时</p>
<p>​	—计数器每个右移1位</p>
<p>​	—R位增加到最左边</p>
<p>•数值越大表示最近使用的页面</p>
<p>​	—选择01110111页面替换，而不是11000100页面</p>
</li>
</ul>
<p>• Demand Paging: bring a page into memory only when it is<br>needed<br>• Prefetching: guess which pages are about to be used, and thus bring it in ahead of time</p>
<h3 id="工作集模型"><a href="#工作集模型" class="headerlink" title="工作集模型"></a>工作集模型</h3><h4 id="–抖动-Thrashing"><a href="#–抖动-Thrashing" class="headerlink" title="–抖动 (Thrashing)"></a>–抖动 (Thrashing)</h4><p>如果一个进程没有“足够”的页面，页面故障率就会非常高。此时，应降低多路编程的程度，作为换出进程可以释放其帧。</p>
<p>Thrashing：进程将所有时间用于交换页面(大多数引用会导致页面错误)</p>
<h4 id="–访问局部性-Principle-of-Locality"><a href="#–访问局部性-Principle-of-Locality" class="headerlink" title="–访问局部性 (Principle of Locality)"></a>–访问局部性 (Principle of Locality)</h4><p>时间、空间</p>
<p>工作集</p>
<p>•工作集:页面的集合过程中使用最近的k内存引用——如果整个工作集是在内存中,这一过程会不会引起许多缺点,直到它进入另一个执行阶段,如果可用内存太小,不能容纳整个工作集,抖动发生•跟踪每个进程的工作集,并确保它在内存之前让进程运行,大大降低故障率的页面</p>
<h3 id="页框的全局和局部分配策略"><a href="#页框的全局和局部分配策略" class="headerlink" title="页框的全局和局部分配策略"></a>页框的全局和局部分配策略</h3><h4 id="需求分页"><a href="#需求分页" class="headerlink" title="需求分页"></a>需求分页</h4><h4 id="页面替换"><a href="#页面替换" class="headerlink" title="页面替换"></a>页面替换</h4><h4 id="页面缓冲"><a href="#页面缓冲" class="headerlink" title="页面缓冲"></a>页面缓冲</h4><h4 id="帧分配"><a href="#帧分配" class="headerlink" title="帧分配"></a>帧分配</h4><h4 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h4><p>*连续内存分配 </p>
<p>当一个程序开始运行时，操作系统决定它应该在物理内存的哪里被加载，并设置base寄存器和limit寄存器(在内存中为它的地址空间寻找空间)•当在进程之间切换时，操作系统必须保存和恢复base-and-limit pair•当用户程序试图非法访问内存(可能会终止进程)时，操作系统必须提供异常处理程序</p>
<h4 id="空闲空间管理"><a href="#空闲空间管理" class="headerlink" title="空闲空间管理"></a>空闲空间管理</h4><h4 id="动态空间分配算法"><a href="#动态空间分配算法" class="headerlink" title="动态空间分配算法"></a>动态空间分配算法</h4><p>First-Fit：第一次分配足够大的hole，目的是尽可能减少搜索次数</p>
<p>Next-Fit：跟踪上一次分配的hole，并在上次停止的位置开始第一次匹配的搜索，性能比first-fit略差</p>
<p>Best-Fit：分配最小的足够大的hole，需要search整个list，可能产生小而无用的hole从而产生浪费</p>
<p>Worst-Fit：分配最大的洞——也搜索整个列表——也不是一个很好的主意</p>
<p>Quick-Fit：一些更常见的请求大小维护单独的列表-找到所需大小的hole非常快-但hole应该按大小排序(当进程终止时)</p>
<h4 id="内部碎片和外部碎片"><a href="#内部碎片和外部碎片" class="headerlink" title="内部碎片和外部碎片"></a>内部碎片和外部碎片</h4><h4 id="地址保护"><a href="#地址保护" class="headerlink" title="地址保护"></a>地址保护</h4><h4 id="内存扩展"><a href="#内存扩展" class="headerlink" title="内存扩展"></a>内存扩展</h4><h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><h3 id="文件系统的功能"><a href="#文件系统的功能" class="headerlink" title="*文件系统的功能"></a>*文件系统的功能</h3><p>为应用程序提供持久的和命名的数据</p>
<p>•长期信息存储的基本要求-存储非常大量的信息-当进程终止时信息必须存活-多个进程必须能够同时访问信息</p>
<p>文件系统—为存储提供用户界面，将逻辑块映射到物理—通过允许数据存储、定位和轻松检索来高效访问磁盘</p>
<h4 id="核心功能"><a href="#核心功能" class="headerlink" title="核心功能"></a>核心功能</h4><p>•持久命名数据:文件和目录-存储直到它被显式删除，即使存储它的计算机崩溃或断电-可以通过文件系统与文件关联的人类可读标识符访问</p>
<p>•访问和保护:提供打开，读，写和其他操作;协调不同用户对文件的访问</p>
<p>•磁盘管理:公平高效地使用磁盘空间—为文件分配空间并跟踪空闲空间—快速访问文件</p>
<p>•可靠性:不能丢失文件数据</p>
<h3 id="文件"><a href="#文件" class="headerlink" title="*文件"></a>*文件</h3><p>可以创建，读取，写入和删除的字节(由用户定义的类型)的线性数组，一种抽象机制，提供了一种将信息存储在磁盘上并稍后读取的方法</p>
<h4 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h4><p>人类可读命名，扩展名<img src="/os/image-20230226005914514.png" alt="image-20230226005914514"></p>
<h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><p>类型：常规文件:包含用户信息的文件（ASCII文件:由文本行组成；二进制文件:具有特定程序所知道的一些内部结构）；目录文件:用于维护文件系统结构的系统文件；特殊文件:字符(打印机)，块(磁带)，……•每个操作系统都必须至少识别一种文件类型:它自己的可执行文件</p>
<p>metadata<img src="/os/image-20230226010149214.png" alt="image-20230226010149214"></p>
<p>文件系统应该将文件元数据保存在一个结构中:索引节点(inode) (UNIX中给出的历史名称)，驻留在磁盘上，缓存在内存中以加快访问速度</p>
<h4 id="文件访问"><a href="#文件访问" class="headerlink" title="文件访问"></a>文件访问</h4><p>顺序访问</p>
<p>read next &#x2F; write next &#x2F; reset，最常见，比如复制文件、编译器读取和写入，可以非常快</p>
<p>随机访问模式</p>
<p> read n &#x2F; write n &#x2F; seek n，包含块数作为参数，不快</p>
<h4 id="与文件相关的操作"><a href="#与文件相关的操作" class="headerlink" title="与文件相关的操作"></a>与文件相关的操作</h4><p>存储和检索信息的操作</p>
<p>•Create:宣布文件并设置属性•Delete:释放磁盘空间•Open:将属性和磁盘地址列表提取到主存中进行快速访问•Close:释放内部表空间，强制写入文件的最后一个块•Read:从文件中读取数据(指定需要多少数据并提供缓冲区)•Write:将数据写入文件(在当前位置)•Append:限制写操作的形式•Seek:在文件中重新定位(指定从哪里获取数据)•Get and Set Attributes:读取和更改文件属性•Rename:更改文件名称</p>
<p>•一些系统只提供了文件操作的最小系统调用集(其他操作可以使用这些操作实现)</p>
<h4 id="文件描述符-File-Descriptor"><a href="#文件描述符-File-Descriptor" class="headerlink" title="文件描述符 (File Descriptor)"></a>文件描述符 (File Descriptor)</h4><p>由操作系统分配的用于引用文件的唯一编号(每个进程私有)</p>
<p>•避免解析文件名(在目录中搜索文件名)并检查每次访问的权限</p>
<p>•执行某些操作的能力</p>
<p><img src="/os/image-20230226010902878.png" alt="image-20230226010902878"></p>
<h4 id="打开文件表-Open-File-Table"><a href="#打开文件表-Open-File-Table" class="headerlink" title="打开文件表 (Open-File Table)"></a>打开文件表 (Open-File Table)</h4><p>进程打开文件时，OS要创建一个存储文件信息的数据结构</p>
<p>每个进程维护一个打开文件表（由文件描述符索引的数组），表中的每个条目都跟踪文件描述符引用的底层文件、当前偏移量和其他相关详细信息（例如权限）</p>
<p>per-process open-file table：跟踪所有被进程打开的文件</p>
<p>system-wide open-file table：跟踪与进程无关的信息，系统维护所有打开文件的信息</p>
<p>打开文件步骤：在系统打开文件表中寻找这个文件条目（如果没有则在目录中寻找文件名，找到后添加到系统打开文件表中）；在每进程文件打开表中创建一个指向系统打开文件表对应条目的条目；自增系统打开文件表的open count（仅有当此变量为0时才能移除对应条目）；返回一个指向每进程文件打开表中对应条目的指针</p>
<p>三个描述文件描述符和打开文件关系的表（Unix中）：</p>
<p>•文件描述符表(每个进程的):每个由进程打开的文件描述符都有一个条目——引用打开文件描述</p>
<p>•打开文件表(系统):每个打开的文件都有一个条目——文件偏移量,访问模式,状态标志——参考inode对象文件</p>
<p>•inode表(系统):每个索引节点都有一个条目,文件类型权限,其他属性(大小、时间戳、…</p>
<h4 id="偏移-Offset"><a href="#偏移-Offset" class="headerlink" title="偏移 (Offset)"></a>偏移 (Offset)</h4><p>对于进程打开的每个文件，操作系统都会跟踪文件偏移量，这决定了下一次读或写将从哪里开始</p>
<p>•隐式更新(当发生N个字节的读或写时，N被添加到当前偏移量)</p>
<p>•通过系统调用显式更新:lseek()</p>
<h3 id="目录"><a href="#目录" class="headerlink" title="*目录"></a>*目录</h3><p>目录操作<img src="/os/image-20230226100526798.png" alt="image-20230226100526798"></p>
<ul>
<li><p>目录的层级结构（在目录中放置目录）</p>
<p>目录存储人类可读文件名和低级文件索引(inode号)之间的映射</p>
<p>⟨文件名，文件索引⟩pair的表</p>
<p>为根目录分配固定的inode号</p>
</li>
<li><p>从文件路径名到文件 inode 的转换</p>
<p>根目录中寻找对应inode，找到对应磁盘block，到磁盘再找inode…</p>
</li>
<li><p>硬链接 (Hard Link) 和符号链接 (Symbolic Link)</p>
<p>新文件链接到旧文件名，同一文件有了多个名字，目录结构是有向无环图</p>
<p>硬链接依赖inode，每个inode对应一个独一无二的文件，对inode的引用，系统有计数，计数减到0文件就算被删除。unlink()可以减少计数；存在规则：不能跨文件系统链接（inode仅在同一文件系统内唯一），不能链接到目录（防止出现环）；文件所有者仅有一个。</p>
<p>软链接依赖路径名：生产一个存储了链接文件路径的link类型文件；可以跨文件系统，可以递归链接（链接目录、甚至link类型文件）</p>
</li>
</ul>
<p>文件系统挂载（Mount）</p>
<h3 id="文件系统的布局"><a href="#文件系统的布局" class="headerlink" title="*文件系统的布局"></a>*文件系统的布局</h3><p> Superblock, bitmap, inodes, data blocks</p>
<p><img src="/os/image-20230226102518514.png" alt="image-20230226102518514"></p>
<p>单个物理磁盘可以划分并存储多个卷，也可以将多个物理磁盘组合在一起，使单个卷跨越多个物理磁盘，包含文件系统的分区称为卷</p>
<p>文件系统维护数据存储的磁盘结构，磁盘分块block：数据区域，inode表区域（文件的metadata），分配结构（存储磁盘已分配信息和空余信息，data region和inode  table各一个），superblock（存储文件系统信息，文件系统类型，inode数量，block数量，inode table起始位置，是挂载文件系统时第一个被读取的block）</p>
<p><img src="/os/image-20230226103951089.png" alt="image-20230226103951089"></p>
<p><img src="/os/image-20230226104228068.png" alt="image-20230226104228068"></p>
<p>引导块（boot block）:引导OS所需的信息，通常是分区的第一个块(如果没有OS则为空)</p>
<p>主引导记录(MBR):引导计算机的信息</p>
<p>分区表（Partition Table）:每个分区的开始和结束地址(其中一个标记为活动)</p>
<p>文件系统还需要维护用于数据访问的内存结构(反映和扩展磁盘结构)•挂载表:关于文件系统挂载的信息(挂载点，文件系统类型)•开放文件表:全系统级和每进程级•目录结构:关于最近访问的目录的信息•I&#x2F;O内存缓冲区:当文件系统块被读取或写入磁盘时保存它们</p>
<h3 id="文件的组织"><a href="#文件的组织" class="headerlink" title="*文件的组织"></a>*文件的组织</h3><p>文件需要分配磁盘块来存储数据，并具有指向数据块所在位置的结构</p>
<ul>
<li><p>Contiguous</p>
<p>连续分配，每个文件占用一组连续的块</p>
<p>•只需要第一个块的磁盘地址和块的个数。•可以高效地实现顺序访问。•也可以快速计算任意地址的数据位置</p>
<p>不灵活，文件创建时就需要指定文件大小，容易产生磁盘碎片。适合DVD和CD-ROM；有的文件系统用extend-based，比block更大，是连续block形成的extend（区段）</p>
</li>
<li><p>Linked List</p>
<p>a linked list of blocks，每个block含有指向next的指针</p>
<p>没有外部碎片，也只需要第一个block的地址</p>
<p>缺点在于随机访问慢，指针浪费空间，可靠性不高</p>
<p>可以采用cluster of blocks改进，但内部可能产生碎片</p>
</li>
<li><p>File Allocation Table</p>
<p>链表分配的变种，用于MS-DOS，把所有指针放进FAT</p>
<p>每个FAT条目对应一个磁盘block，每个条目包含一个指向代表了相同文件的block的FAT条目的指针，或者文件末尾值</p>
<p>目录同样可以存储起始块号，提供随机访问（在内存中搜索FAT），用两个这样的表备份</p>
<p>缺点在与内存开销大（FAT表必须一直在内存中）</p>
</li>
<li><p>Indexed (inode 的多级索引设计)</p>
<p>每个文件都有一个指向块的指针数组(索引block)</p>
<p>索引块只在相应文件打开时才需要在内存中，大小只跟一次需要打开的最大文件block大小有关（还是可能很大）</p>
<p>多级索引：可以有间接指针块（不是指向包含用户数据的块，而是指向包含更多指针的块），针对更大文件可以有多重指针块，不平衡树</p>
<p><img src="/os/image-20230226110411890.png" alt="image-20230226110411890"></p>
</li>
</ul>
<p>文件碎片-大多数文件都很小（平均200kB）</p>
<p>最佳的文件组织方法取决于-文件系统的特征-文件访问类型(例如，连续的适合顺序)-…</p>
<p>考虑要素：快速查找数据进行顺序和&#x2F;或随机访问-内部和外部碎片-易于实现-支持文件增长-存储开销</p>
<h3 id="目录的组织"><a href="#目录的组织" class="headerlink" title="*目录的组织"></a>*目录的组织</h3><p>–目录项中包含的信息、不同长度文件名的处理</p>
<p>⟨file name, file index⟩ mapping</p>
<p>包含的信息可能为：—整个文件的磁盘地址—第一个块号—inode号</p>
<p>文件属性（metadata）可以直接存储在目录条目中(固定大小的条目大小)，或者每个目录条目只引用一个inode(只有文件名+ inode号)<img src="/os/image-20230226110854879.png" alt="image-20230226110854879"></p>
<p>两种组织方法：</p>
<p>entry长度不一致：条目长度(固定)—属性(固定)—文件名(以特殊字符结束)•当一个文件被删除时，会引入一个可变大小的间隙</p>
<p>一致：保持所有的文件名在一个堆中•当一个条目被删除，下一个输入的文件将始终适合•文件名不需要从单词边界开始•必须管理堆</p>
<h3 id="文件系统的性能"><a href="#文件系统的性能" class="headerlink" title="*文件系统的性能"></a>*文件系统的性能</h3><p>如何跟踪哪些索引节点和数据块是空闲的?•当一个新的文件或目录被分配时，文件系统可以为它找到空间；位图bitmap和自由列表free list是两种常见的方法•更复杂的数据结构，如b -树也被使用</p>
<p>bitmap：每一位代表一个block的状态，能比较容易地找到连续磁盘空间，需要额外空间存储位图</p>
<p>free list：把空闲空间串成一个链表，让每个块拥有尽可能多的空闲磁盘块号(分组)-对于1KB的块，和4字节的块号，每个块拥有255个空闲块-分配多个空闲块不需要遍历列表；不浪费空间，寻找和分配（需要遍历）比较麻烦；部分block装满，部分不装满（解决频繁I&#x2F;O造成的性能浪费）</p>
<p>读文件的步骤：</p>
<p>•首先，打开文件-遍历路径名并找到所需的inode -读取该inode，执行权限检查，返回文件描述符</p>
<p>•然后，对于发出的每个读操作-读取inode -读取数据块-写入inode(更新上次访问时间) -在打开的文件表(内存)中更新文件偏移量</p>
<ul>
<li><p>缓存 (Cache and Buffering) </p>
<p>将经常使用的块保留在内存中:如果需要的块在内存中，则不需要I&#x2F;O就读取它•使用哈希表跟踪给定的块是否存在•当缓存满时必须删除一些块(类似于页面替换问题)；提前读取常用block到内存；写延迟，优化写操作（回写和直写）；</p>
</li>
<li><p>快速文件系统 (FFS)</p>
<p>disk-awareness的文件系统</p>
<p>通过在同一个组中放置两个文件，FFS确保访问一个文件后不会导致长时间的磁盘查找</p>
<p>实现数据局部性原则</p>
<p>对于文件-将数据块分配到与其inode相同的组中-将同一目录下的所有文件放在它们所在的目录组中</p>
<p>对于目录-找到已分配目录数量较少(以平衡组间的目录)和空闲inode数量较多(以能够分配一堆文件)的组-将目录数据和inode放在该组中</p>
</li>
</ul>
<h3 id="文件系统的一致性"><a href="#文件系统的一致性" class="headerlink" title="*文件系统的一致性"></a>*文件系统的一致性</h3><p>•对文件系统的更新操作需要多次I&#x2F;O操作(更新多个数据结构)—崩溃时，一些操作可能完成，一些操作可能丢失•使文件系统处于不一致状态</p>
<p>写操作步骤：•在文件中追加一个数据块—写入新的数据块—写入文件的inode—写入数据位图</p>
<p>后两步骤出现崩溃会出现一致性问题</p>
<ul>
<li><p>文件系统一致性检查 (fsck)</p>
<p>File System Consistency Check，在挂载文件系统之前运行(假设在运行时没有文件系统活动)，并确保文件系统元数据在内部保持一致</p>
<p>• Sanity check the superblock<br>• Check validity of free block and bitmaps<br>• Check that inodes are not corrupted<br>• Check inode links<br>• Check for duplicate pointers and bad blocks<br>• Check directories</p>
<p>•检查超级块•检查空闲块和位图的有效性•检查inode是否损坏•检查inode链接•检查重复的指针和坏块•检查目录</p>
<p>太慢，对文件系统知识要求高</p>
</li>
<li><p>日志文件系统 (Journaling)</p>
<p>write-ahead logging，覆写结构之前，记录即将进行的操作</p>
<p>循环日志，日志大小固定，花费高</p>
<p>元数据日志</p>
<p><img src="/os/image-20230226130004974.png" alt="image-20230226130004974"></p>
</li>
</ul>
<h3 id="虚拟文件系统"><a href="#虚拟文件系统" class="headerlink" title="*虚拟文件系统"></a>*虚拟文件系统</h3><h2 id="设备管理"><a href="#设备管理" class="headerlink" title="设备管理"></a>设备管理</h2><h3 id="•-Input-x2F-Output-I-x2F-O-devices"><a href="#•-Input-x2F-Output-I-x2F-O-devices" class="headerlink" title="• Input&#x2F;Output (I&#x2F;O) devices"></a>• Input&#x2F;Output (I&#x2F;O) devices</h3><p>– How should I&#x2F;O be integrated into systems?<br>– What are the general mechanisms?</p>
<h3 id="•-Hard-disk-drive"><a href="#•-Hard-disk-drive" class="headerlink" title="• Hard disk drive"></a>• Hard disk drive</h3><p>– How is the data actually laid out and accessed?<br>– How does disk scheduling improve performance?</p>
<h3 id="•-RAID"><a href="#•-RAID" class="headerlink" title="• RAID"></a>• RAID</h3><p>– How can we make a large, fast, and reliable storage system?</p>
<h3 id="I-x2F-O-设备的交互"><a href="#I-x2F-O-设备的交互" class="headerlink" title="*I&#x2F;O 设备的交互"></a>*I&#x2F;O 设备的交互</h3><p> Polling, Interrupts, DMA</p>
<h3 id="磁盘"><a href="#磁盘" class="headerlink" title="*磁盘"></a>*磁盘</h3><p>–寻道时间和旋转延迟</p>
<p>–磁盘调度算法: First Come First Service (FCFS), Shortest Seek First (SSF), Elevator (SCAN)</p>
<p>SSF：按轨道排列I&#x2F;O请求队列，选择最近轨道上的请求先完成，可能造成饿死</p>
<p>SCAN：简单地在磁盘服务请求上按顺序在磁道上来回移动(就像电梯一样)•一次通过磁盘(从外磁道到内磁道，或从内磁道到外磁道)称为扫描</p>
<h2 id="汇编文件相关"><a href="#汇编文件相关" class="headerlink" title="汇编文件相关"></a>汇编文件相关</h2><h3 id="至少三个节"><a href="#至少三个节" class="headerlink" title="至少三个节"></a>至少三个节</h3><h4 id="data"><a href="#data" class="headerlink" title=".data"></a>.data</h4><p>程序已初始化的数据，具有初值的变量</p>
<h4 id="text"><a href="#text" class="headerlink" title=".text"></a>.text</h4><p>包含程序代码，只读节</p>
<h4 id="bss"><a href="#bss" class="headerlink" title=".bss"></a>.bss</h4><p>包含未初始化变量，不占用空间，操作系统装入时全置为0</p>
<hr>
<h3 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h3><h4 id="ascii"><a href="#ascii" class="headerlink" title=".ascii"></a>.ascii</h4><pre class="language-asm" data-language="asm"><code class="language-asm">.ascii	“string” …</code></pre>

<p>ascii 表示零个或多个(用逗号隔开)字符串，并把每个字符串(结尾不自动加“\0”字符)中的字符放在连续的地址单元。</p>
<p>与此类似的 <code>.asciz</code>指令定义的字符串会在结尾处自动加 “\0”字符</p>
<h4 id="fill"><a href="#fill" class="headerlink" title=".fill"></a>.fill</h4><pre class="language-assembly" data-language="assembly"><code class="language-assembly">.fill repeat [, size , value]</code></pre>

<p>反复拷贝size个字节，重复repeat次 ，其中size和value是可选的，默认值分别为1和0</p>
<h4 id="global"><a href="#global" class="headerlink" title=".global"></a>.global</h4><pre class="language-assembly" data-language="assembly"><code class="language-assembly">.global symbol</code></pre>

<p>使得链接程序(ld)能识别symbol，局部程序中定义了.global symbol，则在与其链接的其它局部程序中也能存取symbol</p>
<hr>
<h3 id="内联汇编"><a href="#内联汇编" class="headerlink" title="内联汇编"></a>内联汇编</h3><p>使用内嵌汇编，要先编写汇编指令模板，然后将C语言表达式与指令的操作数相关联，并告诉GCC对这些操作有哪些限制条件。例如下面的汇编语句： </p>
<p>​    <code>__asm__ __violate__  (&quot;movl %1,%0&quot; : &quot;=r&quot; (result) : &quot;r&quot; (input));</code> </p>
<p>“movl %1,%0”是指令模板；“%0”和“%1”代表指令的操作数，称为占位符，“&#x3D;r”代表它之后是输入变量且需用到寄存器，指令模板后面用小括号括起来的是C语言表达式 ，其中input是输入变量，该指令会完成把input的值复制到result中的操作</p>
<p>内嵌汇编语法如下：</p>
<pre class="language-none"><code class="language-none">__asm__(
    汇编语句模板:
    输出部分:
    输入部分:
    破坏描述部分);
即格式为asm ( &quot;statements&quot; : output_regs : input_regs : clobbered_regs)</code></pre>







<h2 id="汇编语法相关"><a href="#汇编语法相关" class="headerlink" title="汇编语法相关"></a>汇编语法相关</h2><h3 id="环境语法"><a href="#环境语法" class="headerlink" title="环境语法"></a>环境语法</h3><p>旧版本的GAS把”.code16”解释为“生成32位指令，但是隐式地插入addr32（Address-Size Prefix 67H）和data32（Operand-Size Prefix 66H）指令来使代码工作在实模式下”。</p>
<p>新版本的GAS把”.code16”解释为“生成看似正确的16位指令”。这要求，当程序员想要使用32位得地址或是数据时，自己显示地插入addr32和data32指令。</p>
<pre class="language-asm" data-language="asm"><code class="language-asm">	data32 addr32 lgdt gdtDesc # loading gdtr, data32, addr32
	
	...

data32 ljmp $0x08, $start32 # reload code segment selector and ljmp to start32, data32</code></pre>



<h3 id="条件跳转和其它指令配合"><a href="#条件跳转和其它指令配合" class="headerlink" title="条件跳转和其它指令配合"></a>条件跳转和其它指令配合</h3><p>Intel格式</p>
<p> 无符号数比较</p>
<p>基于无符号数比较的跳转如下表所示。操作数的名称反映了表达式中操作数的顺序（比如 leftOp &lt; rightOp）。下表中的跳转仅在比较无符号数值时才有意义。有符号操作数使用不同的跳转指令。</p>
<table>
<thead>
<tr>
<th>助记符</th>
<th>说明</th>
<th>助记符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>JA</td>
<td>大于跳转（若 leftOp &gt; rightOp）</td>
<td>JB</td>
<td>小于跳转（若 leftOp &lt; rightOp）</td>
</tr>
<tr>
<td>JNBE</td>
<td>不小于或等于跳转（与 JA 相同）</td>
<td>JNAE</td>
<td>不大于或等于跳转（与 JB 相同）</td>
</tr>
<tr>
<td>JAE</td>
<td>大于或等于跳转（若 leftOp ≥ rightOp）</td>
<td>JBE</td>
<td>小于或等于跳转（若 leftOp ≤ rightOp）</td>
</tr>
<tr>
<td>JNB</td>
<td>不小于跳转（与 JAE 相同）</td>
<td>JNA</td>
<td>不大于跳转（与 JBE 相同）</td>
</tr>
</tbody></table>
<p>有符号数比较</p>
<p>下表列岀了基于有符号数比较的跳转。下面的指令序列展示了两个有符号数值的比较：</p>
<table>
<thead>
<tr>
<th>助记符</th>
<th>说明</th>
<th>助记符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>JG</td>
<td>大于跳转（若 leftOp &gt; rightOp）</td>
<td>JL</td>
<td>小于跳转（若 leftOp &lt; rightOp）</td>
</tr>
<tr>
<td>JNLE</td>
<td>不小于或等于跳转（与 JG 相同）</td>
<td>JNGE</td>
<td>不大于或等于跳转（与 JL 相同）</td>
</tr>
<tr>
<td>JGE</td>
<td>大于或等于跳转（若 leftOp ≥ rightOp）</td>
<td>JLE</td>
<td>小于或等于跳转（若 leftOp ≤ rightOp）</td>
</tr>
<tr>
<td>JNL</td>
<td>不小于跳转（与 JGE 相同）</td>
<td>JNG</td>
<td>不大于跳转（与 JLE 相同）</td>
</tr>
</tbody></table>
<pre class="language-asm" data-language="asm"><code class="language-asm">mov al, +127             ;十六进制数值 7Fh
cmp al, -128              ;十六进制数值 80h
ja Is Above                ;不跳转，因为 7Fh &lt; 80h
jg IsGreater               ;跳转，因为 +127 &gt; -128

</code></pre>

<p>由于无符号数 7Fh 小于无符号数 80h，因此，为无符号数比较而设计的 JA 指令不发生跳转。另一方面，由于 +127 大于 -128，因此，为有符号数比较而设计的 JG 指令发生跳转。</p>
<p>AT&amp;T格式中则是比较rightOp <em>operator</em> leftOp</p>
<h3 id="iret"><a href="#iret" class="headerlink" title="iret"></a>iret</h3><p>iret 指令描述为：pop IP pop CS popf</p>
<p>iret指令执行后，CPU回到执行中断处理程序前的执行点继续执行程序</p>
<pre class="language-none"><code class="language-none">old_CS &#x3D; CS 
pop EIP 
pop CS 
pop EFLAGS 
if(GDT[old_CS].DPL &lt; GDT[CS].DPL) 
    pop ESP 
    pop SS</code></pre>





<h3 id="jmp指令"><a href="#jmp指令" class="headerlink" title="jmp指令"></a>jmp指令</h3><p>假如标签叫做mylabel，它的地址是0x8048377，而且有个全局变量b，b存储的内容就是mylabel的地址，而b的地址是0x80494A8。</p>
<p>即有这样的赋值（加载）语句：</p>
<p>movl $mylabel,%eax 	&#x2F;&#x2F;把mylabel的地址加载到eax寄存器中</p>
<p>movl %eax,b 		&#x2F;&#x2F;把mylabel的地址加载到b中</p>
<p>movl $b,%ebx 	&#x2F;&#x2F;把b的地址加载到ebx寄存器中</p>
<p>我们考虑下面的语句：</p>
<p>1.jmp mylable</p>
<p>2.jmp 0x8048377</p>
<p>3.jmp %eax</p>
<p>4.jmp *%eax</p>
<p>5.jmp *(%ebx)</p>
<p>6.jmp *0x80494A8</p>
<p>7.jmp *b</p>
<p>8.jmp $0x5</p>
<p>这8句jmp语句！分别都做了什么？</p>
<p>1.不用说，跳转到mylabel标签处继续执行代码，但是，是如何跳转的呢？就是PC加上了mylabel标签处对于jmp处的一个偏移地址！可执行的二进制代码是这样表示的：eb 03，就是说，pc+0x03就可以了。</p>
<p>2.这里，0x8048377是mylabel的地址，我以前研究过，标签的作用，更他的地址的作用是等效的。所以，这里的执行效果跟1中的相同。但是，还有些不一样！这里的二进制代码成了：e9 03 00 00 00 这里用了32位表示了这个偏移，而在1中，只用了8位！</p>
<p>3.在编译链接的时候，这句代码会有警告：warning:indirect jmp without ‘*‘。间接跳转没有‘*’符号，但是，执行起来，还是没有错。看一下二进制的可执行文件的代码，发现，给补上了个‘*’号！而且二进制是：ff e0.</p>
<p>4.其实，4是3的补充版，正常的形式就是4，而三是有警告的被补充的版本。</p>
<p>5.%ebx是b的地址，那么(%ebx)表示ebx的值为地址，指向的地方。这里指向了b的内容，也就是mylabel的地址！于是，化简后，5也就等效与2，但是，二进制表示是：ff 23。</p>
<p>6.0x80494A8是b的地址，这里看做内存数，那么实质上，b指向的值是mylabel的地址，于是，化简后同2，二进制代码是：ff 25 a8 94 04 08。</p>
<p>7.b是标签，代表一个地址，所以，这里同6，二进制代码也同6</p>
<p>8.这句话是错误的，jmp不支持立即数！</p>
<h3 id="ljmp"><a href="#ljmp" class="headerlink" title="ljmp"></a>ljmp</h3><p>ljmp的含义是长跳，长跳主要就是重新加载寄存器，32位保护模式主要体现在段寄存器，具有可以参考段选择子和段描述符的概念，如果不用长跳的话，那么段寄存器不会重新加载，后面的取指结果仍然是老段寄存器中的值，当然保护模式不会生效了，Intel手册上有讲可见寄存器和不可见寄存器的篇章，可以看一下，其实实模式就是保护模式的一种权限全开放的特殊情况，就是说段寄存器左移相当于右边添加0，而这添加的0可以看做保护模式的RPL，RPL为0代表Intel的0环，当然是全权限了。</p>
<p>不过Intel的实模式的概念实属不得已而为之，现在的意义已经不大了，从实模式启动然后跳转到保护模式纯粹是在绕圈子，没有实质的意义，商业上为了保护以前的投资不得不将技术做的没有意义的复杂…</p>
<h3 id="pushf和popf"><a href="#pushf和popf" class="headerlink" title="pushf和popf"></a>pushf和popf</h3><p>pushf 的功能是将标志寄存器的值压栈，而 popf 是从栈中弹出数据，输出标志寄存器的值。</p>
<p>具体地说</p>
<p>pushf:指令将标志寄存器的内容压入堆栈，同时栈顶指针SP减2，这条指令可用来保存全部标志位。<br>popf：指令将栈顶字单元内容送标志寄存器，同时栈顶指针SP加2。</p>
<div class="post-tags"><a class="post-tag-link" href="/tags/OS/" rel="tag">#OS</a></div></article><div id="paginator"></div></div></div><div id="bottom-outer"><div id="bottom-inner"><hr><div><div><a>2023@ </a><a href="/atom.xml"><img src="/assets/rss.png"></a></div><div id="hexo"><a>Powered by&nbsp</a><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><a>&nbsp&&nbsp</a><a target="_blank" rel="noopener" href="https://github.com/qiantao94/hexo-theme-oasis">Oasis</a></div></div></div></div></div></body><script src="/js/oasis.js"></script></html>