<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>hh-blog</title>
  
  <subtitle>Learning</subtitle>
  <link href="https://hhumar.com/atom.xml" rel="self"/>
  
  <link href="https://hhumar.com/"/>
  <updated>2022-11-06T17:08:06.650Z</updated>
  <id>https://hhumar.com/</id>
  
  <author>
    <name>hh</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Computer Network</title>
    <link href="https://hhumar.com/2022/11/07/computer-net/"/>
    <id>https://hhumar.com/2022/11/07/computer-net/</id>
    <published>2022-11-06T16:40:02.000Z</published>
    <updated>2022-11-06T17:08:06.650Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>持续更新</p></blockquote><p>主要是计算机网络自顶向下方法第七版部分笔记和一些拓展</p><p><a href="https://liuyijian.github.io/vuepressBlog/techNote/basic/network/%EF%BC%8C%E8%BF%99%E5%93%A5%E4%BB%AC%E7%9A%84%E7%AC%94%E8%AE%B0%E5%BE%88%E6%A3%92">https://liuyijian.github.io/vuepressBlog/techNote/basic/network/，这哥们的笔记很棒</a></p><h2 id="计算机网络和因特网概述"><a href="#计算机网络和因特网概述" class="headerlink" title="计算机网络和因特网概述"></a>计算机网络和因特网概述</h2><p>什么是因特网(具体构成和描述、服务描述、协议)：端系统通过通信链路(communication link)和分组交换机(packet switch)连接；链路传输速率单位bit&#x2F;s，端系统间发送信息时发送<strong>分组</strong>(packet)，分组交换机最著名的有路由器(router)和链路层交换机(link-layer switch)，从发送端系统到接收端系统，一个分组所经历的一系列通信链路和分组交换机称为通过该网络的路径(route&#x2F;path)。分组交换是存储转发的过程。</p><p>统计多路复用是特殊的时分复用，不固定分配某个时间片给某个用户。分组交换又分为数据报文和虚电路；前者每个数据包都含有完整目标地址，直接发送不建立连接，而虚电路会先走一遍到目标，让报文中携带路径虚电路号而非目标地址。</p><p>RTT(Round-Trip Time)往返时间表示从发送端发送数据开始，到发送端收到来自接收端的确认（接收端收到数据后便立即发送确认，不包含数据传输时间）总共经历的时间。 RTT由三个部分决定：链路的传播时间、末端系统的处理时间、路由器的缓存中的排队和处理时间。</p><p>有连接(虚电路，体现在线路上每一个节点)，面向连接(TCP 体现在起点和终点)，无连接(数据报文)</p><p>ISP是由多个分组交换机和多段通信链路组成的网络。</p><p>协议(protocol)控制信息的接受和发送，TCP(Transmission Control Protocol，)&#x2F;IP(Internet Protocol，定义端系统和路由器之间发送和接收的分组格式)协议是最重要的两个。因特网标准(Internet standard)由因特网工程任务组[IETE-Internet Engineering Task Force]研发，IEFC的标准文档称为RFC(Request For Comment)。API(Application Programming Interface，应用程序编程接口)</p><p>协议，网络协议(协议定义了在两个或多个通信实体之间交换的报文格式和次序，以及报文发送和&#x2F;或接受一条报文或其他事件所采取的动作)</p><p><strong>分布式应用程序</strong>(distributed application)涉及多台相互交换数据的端系统，<strong>基础设施</strong>是应用层之下为分布式应用程序提供服务的网络部分。</p><p>整个互联网包括网络核心、网络边缘和接入网&#x2F;物理媒体：</p><p>​网络核心 core 由大量路由器和网络链路组成，负责数据交换和路由</p><p>​网络边缘 edge 包括主机和应用程序(client and server)</p><p>​接入网、物理媒体 access 是把网络边缘接入网络核心的有线或无限通信链路</p><p>网络边缘(接入网，物理媒体)：物联网-万物互联，端系统又称为主机，可分为client&#x2F;server，大部分服务器属于data center；access network接入网指将端系统连接到器边缘路由器(edge router)的物理链路，有：</p><p>​<strong>家庭接入</strong>(<u>DSL数字用户线</u>和<u>电缆</u>最为流行，前者中DSL调制解调器将数字数据转换为高频音通过电话线传输给本地中心局&#x2F;CO，CO中的数字用户线接入复用器&#x2F;DSLAM将模拟信号转换回数字形式，分频器分离数据信号和电话信号-频分复用技术；电缆因特网接入，混合光纤同轴&#x2F;HFC，电缆调制解调器&#x2F;cable modem，电缆调制解调器端接系统&#x2F;CMTS；光纤到户&#x2F;FTTH，有主动光纤网络&#x2F;<code>AON</code>和被动<code>PON</code>，<code>PON</code>包括<u>光纤网络端接器ONT</u>，连接到分配器splitter，集结光纤之后连接到中心局的<u>光纤线路端接器OLT</u>-提供光信号和电信号的转换，其中分组&#x2F;packet在分配器处复制，在家庭中先通过路由器连接<code>ONT</code>；还有卫星链路和传统电话线拨号接入，速度慢)</p><p>​<strong>公司&#x2F;企业接入</strong>(以太网和<code>WiFi</code>)和广域移动无线(3G、4G、LTE)物理媒体分为导引型媒体(固体媒体如电缆光缆)和非导引型媒体(空气和外层空间，在无线局域网和数字卫星频道)，<strong>双绞铜线</strong>-无屏蔽双绞线&#x2F;UTP常用在建筑物内的计算机网络中&#x2F;LAN、<strong>同轴电缆</strong>-是两个同心铜导体能被用作导引型共享媒体、<strong>光纤</strong>-导引光脉冲、<strong>陆地无线电信道</strong>、<strong>卫星无线电信道</strong>-同步卫星和近地轨道卫星</p><p>网络核心(分组交换)：分组交换-存储转发传输、排队时延和分组丢失</p><p>基础设施提供的网络服务可分为面向连接的服务(TCP服务)，无连接服务(UDP服务)</p><p>缓冲区管理和拥塞控制</p><p>多路复用：频分复用、时分复用、波分复用</p><p>不同的分层模型：</p><p>​OSI 7层网络模型</p><p>​互联网五层参考模型</p><p>计算速率进制为十进制，也就是说1KB&#x3D;1000B，便于计算</p><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><ul><li>200（OK）- 如果现有资源已被更改</li><li>201（created）- 如果新资源被创建</li><li>202（accepted）- 已接受处理请求但尚未完成（异步处理）</li><li>301（Moved Permanently）- 资源的URI被更新</li><li>303（See Other）- 其他（如，负载均衡）</li><li>400（bad request）- 指代坏请求</li><li>403（）- 禁止访问</li><li>404 （not found）- 资源不存在</li><li>406 （not acceptable）- 服务端不支持所需表示</li><li>409 （conflict）- 通用冲突</li><li>412 （Precondition Failed）- 前置条件失败（如执行条件更新时的冲突）</li><li>415 （unsupported media type）- 接受到的表示不受支持</li><li>500 （internal server error）- 通用错误响应</li><li>503 （Service Unavailable）- 服务当前无法处理请求</li></ul><p><img src="/computer-net/HTTP%E5%93%8D%E5%BA%94%E7%8A%B6%E6%80%81%E7%A0%81.jpg" alt="HTTP响应状态码"></p><pre class="language-none"><code class="language-none">GET &#x2F;cs453&#x2F;index.html HTTP&#x2F;1.1&lt;cr&gt;&lt;lf&gt;Host: gaia.cs.umass.edu&lt;cr&gt;&lt;lf&gt;User-Agent: Mozilla&#x2F;5.0 (Windows ; U; Windows NT5.1;en-US;rv:1.7.2) Geeko&#x2F;20040804 Netscape&#x2F;7.2(ax)&lt;cr&gt;&lt;lf&gt;Accept: ex&#x2F;xml application&#x2F;xml, applicaion&#x2F;xhtml+xml text&#x2F;html ; q&#x3D;0.9, text.&#x2F;plain;q&#x3D;0 . 8 , image&#x2F;png, *&#x2F;* ; q&#x3D;0 . 5 &lt;cr&gt;&lt;lf&gt;Accep-Language en-us, en;q&#x3D;O.S&lt;cr&gt;&lt;lf&gt;AcceptEncoding: zip deflate&lt;cr&gt;&lt;lf&gt;Accept-Charset : ISO-8859-1 , utf-8 ; q&#x3D;0 . 7,* ;q&#x3D;0 . 7&lt;cr&gt;&lt;1f&gt;Keep-Alive:300&lt;cr&gt;&lt;lf&gt;Connection: keep-alive&lt;cr&gt;&lt;l f&gt;&lt;cr&gt;&lt;l f&gt;</code></pre><h3 id="流水线和长连接"><a href="#流水线和长连接" class="headerlink" title="流水线和长连接"></a>流水线和长连接</h3><p>http 1.1 </p><p>有两个新的模型在 HTTP&#x2F;1.1 诞生了。首先是长连接模型，它会保持连接去完成多次连续的请求，减少了不断重新打开连接的时间。然后是 HTTP 流水线模型，它还要更先进一些，多个连续的请求甚至都不用等待立即返回就可以被发送，这样就减少了耗费在网络延迟上的时间。</p><h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><p>Domain Name System：注册域名的权威服务器的名字记录为ns类型在COM服务器中，然后再将该权威服务器的ip以A类型记录存在COM服务器中，包括以下部件：</p><ul><li>通过DNS服务器组建出的分布式数据库<ul><li>DNS服务器通常是Unix系统上运行Berkley Internet Name Domain（BIND）软件</li><li>DNS服务器有3种类型<ul><li>根DNS服务器：有13个不同的根DNS服务器，但有多于1000个副本分布在世界各地，提供顶级域DNS服务器的IP地址</li><li>顶级域DNS服务器：负责顶级域名，国家域名的维护（如com, org, net, edu, gov等等），提供权威DNS服务器的IP地址</li><li>权威DNS服务器：维护具体网站的DNS记录</li></ul></li></ul></li><li>允许用户访问分布式数据库的应用层协议<ul><li>DNS协议在UDP上运行，默认端口为53</li></ul></li></ul><p>递归查询或者迭代查询：递归查询的请求和响应对象逐层递进，在local server到root server，root server到TLD server，TLD server到 Authoritative server途中，找到即递归返回；迭代查询则由local server分别向后三者依次询问，每次必定会得到找到或者找不到的返回。</p><ul><li><p>DNS服务器存储了资源记录，提供了主机名到IP地址的映射，每个DNS回答报文包含一条或多条资源记录</p></li><li><p>资源记录是一个四元组（Name，Value，Type，TTL）</p><ul><li>TTL：记录的生存时间，决定何时从缓存中删除此记录</li><li>Type：<ul><li>A：Name是主机名，Value是IP地址</li><li>NS：Name是个域，Value是知道如何获取该域中主机IP地址的权威DNS服务器的主机名</li><li>CNAME：Name是主机名，Value是别名为Name的规范主机名</li><li>MX：Name是主机名，Value是别名为Name的邮件服务器的规范主机名</li></ul></li></ul></li><li><p>DNS报文：查询报文和回答报文具有相同的格式</p><ul><li>首部区域（前12字节）<ul><li>Identification：2字节的标识符，会被复制到对查询的回答报文中，以便客户匹配请求和应答</li><li>Flags：<ul><li>1比特的报文类型标志位，查询是0，回答是1</li><li>1比特的权威标志位：若该服务器是权威DNS服务器，则该位为1</li><li>1比特的希望递归标志位：若希望DNS服务器进行递归查询，则该位为1</li></ul></li><li>Numbers<ul><li>指出首部后的4类数据区域出现的数量</li></ul></li></ul></li><li>问题区域：包含名字字段（正在被查询的主机名字），类型字段（如主机地址是与一个名字关联还是与某个邮件服务器关联）</li><li>回答区域：若干条四元组形式的资源记录</li><li>权威区域：包含其他权威服务器的记录</li><li>附加区域：包含其他有帮助的记录</li></ul></li></ul><h3 id="CDN加速"><a href="#CDN加速" class="headerlink" title="CDN加速"></a>CDN加速</h3><p>Content Distribution Network：内容提供商将内容提前上载到CDN服务商的服务器中，用户在访问内容提供商的前端网页时，点击视频链接，会通过域名解析系统（见上文）访问到内容提供商的权威DNS服务器，然后得到其提供的另一个域名-即CDN提供商的权威DNS服务器，该DNS服务器提供 CDN簇选择策略，将早在CDN上载好的 content 的IP地址返回给 local DNS server，然后返回到用户端，用户与其直接建立连接，访问 content 。此时访问到的内容所在的服务器与客户最近，用户还能通过 DASH-动态、自适应流 over HTTP 协议切换视频码率。</p><h3 id="TCP-x2F-UDP套接字编程"><a href="#TCP-x2F-UDP套接字编程" class="headerlink" title="TCP&#x2F;UDP套接字编程"></a>TCP&#x2F;UDP套接字编程</h3><p>python3</p><p>TCP</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token operator">//</span>server<span class="token keyword">from</span> socket <span class="token keyword">import</span> <span class="token operator">*</span>serverPort <span class="token operator">=</span> <span class="token number">12000</span>serverSocket <span class="token operator">=</span> socket<span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span> SOCK_STREAM<span class="token punctuation">)</span><span class="token operator">//</span>SOCK_STREAMserverSocket<span class="token punctuation">.</span>bind<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">,</span> serverPort<span class="token punctuation">)</span><span class="token punctuation">)</span>serverSocket<span class="token punctuation">.</span>listen<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'The Server is ready to receive'</span><span class="token punctuation">)</span><span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>connectionSocket<span class="token punctuation">,</span> addr <span class="token operator">=</span> serverSocket<span class="token punctuation">.</span>accept<span class="token punctuation">(</span><span class="token punctuation">)</span> sentence <span class="token operator">=</span> connectionSocket<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span>  capitalizedSentence <span class="token operator">=</span> sentence<span class="token punctuation">.</span>upper<span class="token punctuation">(</span><span class="token punctuation">)</span>  connectionSocket<span class="token punctuation">.</span>send<span class="token punctuation">(</span>capitalizedSentence<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  connectionSocket<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token operator">//</span>client<span class="token keyword">from</span> socket <span class="token keyword">import</span> <span class="token operator">*</span>serverName <span class="token operator">=</span> <span class="token string">'servername'</span>serverPort <span class="token operator">=</span> <span class="token number">12000</span>clientSocket <span class="token operator">=</span> socket<span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span> SOCK_STREAM<span class="token punctuation">)</span><span class="token operator">//</span>SOCK_STREAMclientSocket<span class="token punctuation">.</span>connect<span class="token punctuation">(</span><span class="token punctuation">(</span>serverName<span class="token punctuation">,</span> serverPort<span class="token punctuation">)</span><span class="token punctuation">)</span>sentence <span class="token operator">=</span> <span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">'Input lowercase sentence: '</span><span class="token punctuation">)</span>clientSocket<span class="token punctuation">.</span>send<span class="token punctuation">(</span>sentence<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>modifiedSentencce <span class="token operator">=</span> clientSocket<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'From Server: '</span><span class="token punctuation">,</span> modifiedSentence<span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>clientSocket<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>UDP</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token operator">//</span>server<span class="token keyword">from</span> socket <span class="token keyword">import</span> <span class="token operator">*</span>serverPort <span class="token operator">=</span> <span class="token number">12000</span>serverSocket <span class="token operator">=</span> socket<span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span> SOCK_DGRAM<span class="token punctuation">)</span><span class="token operator">//</span>SOCK_DGRAMserverSocket<span class="token punctuation">.</span>bind<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">,</span> serverPort<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'The Server is ready to receive'</span><span class="token punctuation">)</span><span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>message<span class="token punctuation">,</span> clientAddress <span class="token operator">=</span> serverSocket<span class="token punctuation">.</span>recvfrom<span class="token punctuation">(</span><span class="token number">2048</span><span class="token punctuation">)</span>  modifiedMessage <span class="token operator">=</span> message<span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>upper<span class="token punctuation">(</span><span class="token punctuation">)</span>  serverSocket<span class="token punctuation">.</span>sendto<span class="token punctuation">(</span>modifiedMessage<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> clientAddress<span class="token punctuation">)</span>            <span class="token operator">//</span>client<span class="token keyword">from</span> socket <span class="token keyword">import</span> <span class="token operator">*</span>serverName <span class="token operator">=</span> <span class="token string">'hostname'</span>serverPort <span class="token operator">=</span> <span class="token string">'12000'</span>clientSocket <span class="token operator">=</span> socket<span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span> SOCK_DGRAM<span class="token punctuation">)</span><span class="token operator">//</span>SOCK_DGRAMmessage <span class="token operator">=</span> <span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">'Input lowercase sentence:'</span><span class="token punctuation">)</span>clientSocket<span class="token punctuation">.</span>sendto<span class="token punctuation">(</span>message<span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>serverName<span class="token punctuation">,</span> serverPort<span class="token punctuation">)</span><span class="token punctuation">)</span>moodifiedMessage<span class="token punctuation">,</span> serverAddress <span class="token operator">=</span> clientSocket<span class="token punctuation">.</span>recvfrom<span class="token punctuation">(</span><span class="token number">2048</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>modifiedMessage<span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>clientSocket<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>listen函数</p><pre class="language-none"><code class="language-none">#include&lt;sys&#x2F;socket.h&gt;int listen ( int sockfd,  int backlog )返回： 0──成功，  - 1──失败sockfd:backlog:队列等待长度上限</code></pre><p>listen函数使用主动连接套接口变为被连接套接口，使得一个进程可以接受其它进程的请求，从而成为一个服务器进程。在TCP服务器编程中listen函数把进程变为一个服务器，并指定相应的<a href="https://so.csdn.net/so/search?q=%E5%A5%97%E6%8E%A5%E5%AD%97&spm=1001.2101.3001.7020">套接字</a>变为被动连接。</p><p>nmap工具能做端口扫描，针对不同服务返回打开&#x2F;关闭&#x2F;不可达的端口列表</p><h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><h3 id="复用、解复用"><a href="#复用、解复用" class="headerlink" title="复用、解复用"></a>复用、解复用</h3><h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><p>校验和：“回卷”规则的引入，使得“先求反再求和”与“先求和再求反”所得结果一致。回卷指溢出位加回低位直至无溢出。</p><h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><p><strong>异步传输模式</strong>（英语：Asynchronous Transfer Mode，ATM），又叫<a href="https://zh.wikipedia.org/w/index.php?title=%E4%BF%A1%E5%85%83%E4%B8%AD%E7%BB%A7&action=edit&redlink=1">信元中继</a>。ATM采用<a href="https://zh.wikipedia.org/wiki/%E7%94%B5%E8%B7%AF%E4%BA%A4%E6%8D%A2">电路交换</a>的方式，它以<a href="https://zh.wikipedia.org/w/index.php?title=%E4%BF%A1%E5%85%83&action=edit&redlink=1">信元</a>（cell）为单位。每个信元长53<a href="https://zh.wikipedia.org/wiki/%E5%AD%97%E8%8A%82">字节</a>，其中报头占了5字节。</p><p>ATM能够比较理想地实现各种<a href="https://zh.wikipedia.org/wiki/QoS">QoS</a>，既能够支持有连接的业务，又能支持无连接的业务。是<a href="https://zh.wikipedia.org/w/index.php?title=%E5%AE%BD%E5%B8%A6ISDN&action=edit&redlink=1">宽带ISDN</a>（<a href="https://zh.wikipedia.org/w/index.php?title=B-ISDN&action=edit&redlink=1">B-ISDN</a>）技术的典范。ATM为一种交换技术，在发送资料时，先将数字资料切割成多个固定长度的数据包，之后利用光纤或DS1&#x2F;DS3发送。到达目的地后，再重新组合。ATM网络可同时将声音、影像及资料集成在一起。针对各种信息类型，提供最佳的传输环境。</p><p>Tahoe、Reno、New Reno、SACK和Vegas，五个主要变种</p><h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><p>网络层有四个协议：ARP协议，IP协议，ICMP协议，IGMP协议。ARP协议为IP协议提供服务，IP协议为ICMP协议提供服务，ICMP协议为IGMP协议提供服务。</p><h3 id="数据平面"><a href="#数据平面" class="headerlink" title="数据平面"></a>数据平面</h3><h3 id="控制平面"><a href="#控制平面" class="headerlink" title="控制平面"></a>控制平面</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;持续更新&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;主要是计算机网络自顶向下方法第七版部分笔记和一些拓展&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://liuyijian.github.io/vuepressBlog/techNote/basic</summary>
      
    
    
    
    <category term="计算机科学基础" scheme="https://hhumar.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Web" scheme="https://hhumar.com/tags/Web/"/>
    
    <category term="Computer Network" scheme="https://hhumar.com/tags/Computer-Network/"/>
    
  </entry>
  
  <entry>
    <title>数据结构和算法</title>
    <link href="https://hhumar.com/2022/11/06/ds/"/>
    <id>https://hhumar.com/2022/11/06/ds/</id>
    <published>2022-11-05T18:09:06.000Z</published>
    <updated>2022-11-05T18:14:02.348Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>持续更新</p></blockquote><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="三个渐近复杂度符号："><a href="#三个渐近复杂度符号：" class="headerlink" title="三个渐近复杂度符号："></a>三个渐近复杂度符号：</h3><p>$\Theta：紧确界\quad  O：上界\quad \Omega：下界$</p><h3 id="哨兵"><a href="#哨兵" class="headerlink" title="哨兵"></a>哨兵</h3><p>在首或尾增加哨兵等于目标，循环中寻找目标时不管索引是否超过界限，找到目标再查看索引是哨兵的索引还是真正目标的索引。</p><h3 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h3><p>求模式串的失配链接值是关键。向下取整floor(小于但是最大)和向上取整(大于但是最小)celling</p><h3 id="三元组表的快速转置"><a href="#三元组表的快速转置" class="headerlink" title="三元组表的快速转置"></a>三元组表的快速转置</h3><p>找出原表中每行&#x2F;每列第一个元素转置后在新表中的位置，记录在<code>cpot[]</code>数组中，<code>num[]</code>数组记录源矩阵中每列非零元素的个数。关键是保持三元组的次序-即按行&#x2F;按列排序。</p><h3 id="三元组和十字链表"><a href="#三元组和十字链表" class="headerlink" title="三元组和十字链表"></a>三元组和十字链表</h3><p>选用十字链表是为了在稀疏矩阵间需要运算，而两稀疏矩阵非零元素位置差异较大，每次运算都需要移动大量元素的位置，耗时耗力，所以利用链表特性存储稀疏矩阵。</p><h3 id="重连通图"><a href="#重连通图" class="headerlink" title="重连通图"></a>重连通图</h3><p>关节点是指图中某点，当删除此点及其关联边时，图的一个连通分量会被分割为两个或以上连通分量。无关节点的图为重连通图，重连通图中，任一顶点到其它顶点有两条及以上路径。若在连通图上至少需要删除k个顶点才能破坏图的连通性则称图的连通度为k。系统的连通度越高越安全。(电路设施、通信网络、物资运输线路)</p><h3 id="图的最小路径算法"><a href="#图的最小路径算法" class="headerlink" title="图的最小路径算法"></a>图的最小路径算法</h3><h4 id="Dijkstra算法："><a href="#Dijkstra算法：" class="headerlink" title="Dijkstra算法："></a>Dijkstra算法：</h4><p>建立最短路径数组，元素值表示当前顶点到数组下标对应顶点的最短距离。同时建立bool数组记录某顶点是否已经被提取过。初始化bool数组为全false，初始化最短路径数组为源点到各顶点直接距离，不存在直接边则距离为无穷大。然后从当前最小距离数组中寻找最小距离，确定这个这个最小的最小距离对应的顶点，将其在bool数组中置为已提取(true)在邻接矩阵中依次比较<u>此顶点到其它<strong>未提取顶点</strong>距离与当前最小的最小距离之和</u>与<u>最小距离数组中对应到各顶点的最小距离</u>，若前者更小则替换之，更新最小距离数组(比较次数每个循环会减一)，然后继续寻找最小的最小距离(去除已提取的顶点)。但是这里面没有记录到每个顶点最小距离的相对应路径。可以置路径数组用来记录到达对应数组元素下标的顶点的上一个结点。 path[j] &#x3D; <code>min_num</code>;<code>path[j]</code>记录<code>d[j]</code>暂时最短路径的最后一个中途节点<code>min_num</code>，表明<code>d[j]</code>最后一段从节点<code>min_num</code>到节点<code>j</code>，而到结点<code>j</code>的路径自然会由其它最短路径记录，由此可以达到记录路径的目的。</p><h3 id="最小生成树算法"><a href="#最小生成树算法" class="headerlink" title="最小生成树算法"></a>最小生成树算法</h3><h4 id="Prim算法"><a href="#Prim算法" class="headerlink" title="Prim算法"></a>Prim算法</h4><p>从任一顶点开始建立顶点集和空边集，利用辅助数组记录当前顶点集到图顶点集各点的最小距离，初始化也即为初始顶点到其余各顶点的距离(数组元素是结构体，包括邻接顶点和最小距离，不存在边时距离记为无穷大，到自己的距离记为0)，然后循环n-1次，<em>每次增加一条边和一个顶点，该边是辅助数组中最小的最小距离(增加顶点的形式是把辅助数组对应位置的最小距离置零，增加边是打印该点在数组中的邻接顶点值和该点的值)，然后更新辅助数组，用新顶点和图中其它顶点的距离比较当前对应位置最小距离，若更小则更新邻接顶点为当前顶点并更新最小距离，然后重复下一次循环</em>。如此可以保证辅助数组中的最小距离始终是当前顶点集到图中其余顶点的最小距离，并能记录是当前顶点集的哪一个顶点到图中顶点距离最小，如此循环n-1次就能添加完所有的必要边。复杂度为$O(n^2)$，与边数无关，适合稠密图。</p><h4 id="Kruskal算法-避圈法"><a href="#Kruskal算法-避圈法" class="headerlink" title="Kruskal算法(避圈法)"></a>Kruskal算法(避圈法)</h4><p>初始状态最小生成树为n个顶点无边的非连通图，连通分量为n，每次选择代价最小并能减少一个连通分量的边，直至所有顶点共属一个连通分量。需要利用堆对图中所有边按长进行排序，从小到大依次处理，并利用辅助数据结构并查集(数组即可，不同的连通分量记为不同序号值)检查新边的两顶点是否属于同一连通分量。</p><ul><li>破圈法</li><li>索林(<code>Sollin</code>)算法：类似聚类的凝聚法，合并平凡树</li></ul><h3 id="寻找有向图的强连通分量"><a href="#寻找有向图的强连通分量" class="headerlink" title="寻找有向图的强连通分量"></a>寻找有向图的强连通分量</h3><p><code>Tarjan</code>算法</p><h3 id="寻找图的最大匹配"><a href="#寻找图的最大匹配" class="headerlink" title="寻找图的最大匹配"></a>寻找图的最大匹配</h3><p>匈牙利算法</p><h3 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h3><h3 id="AVL树-二叉平衡树"><a href="#AVL树-二叉平衡树" class="headerlink" title="AVL树(二叉平衡树)"></a>AVL树(二叉平衡树)</h3><p>任意结点左右子树平衡因子满足$-1\leq 平衡因子 \leq 1$</p><h3 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h3><p>2-3树</p><h3 id="B-树："><a href="#B-树：" class="headerlink" title="B+树："></a>B+树：</h3><h3 id="求欧拉图中欧拉回路的算法："><a href="#求欧拉图中欧拉回路的算法：" class="headerlink" title="求欧拉图中欧拉回路的算法："></a>求欧拉图中欧拉回路的算法：</h3><ul><li>Fleury算法：能不走桥就不走桥</li><li>逐步插入回路法</li></ul><h3 id="货郎担问题："><a href="#货郎担问题：" class="headerlink" title="货郎担问题："></a>货郎担问题：</h3><h3 id="利用哈希表的滑动窗口字符串匹配——Robin-Karp算法"><a href="#利用哈希表的滑动窗口字符串匹配——Robin-Karp算法" class="headerlink" title="利用哈希表的滑动窗口字符串匹配——Robin-Karp算法"></a>利用哈希表的滑动窗口字符串匹配——Robin-Karp算法</h3><p>把pattern作整体计算哈希值，类比处理母串，滑动处理。</p><h3 id="Huffman算法"><a href="#Huffman算法" class="headerlink" title="Huffman算法"></a>Huffman算法</h3><p>求带权最优二叉树</p><h3 id="递归思想及原则："><a href="#递归思想及原则：" class="headerlink" title="递归思想及原则："></a>递归思想及原则：</h3><ul><li>函数调用其自身（直接的或间接的都算）</li><li>有<strong>明确的终止条件</strong></li></ul><p>  尾递归(函数所做的最后一件事情是一个函数调用（递归的或者非递归的)可以大大减少栈空间的占用</p><h3 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h3><h3 id="回溯和深度优先搜索dfs"><a href="#回溯和深度优先搜索dfs" class="headerlink" title="回溯和深度优先搜索dfs"></a>回溯和深度优先搜索dfs</h3><p>  遍历所有当前选择（做出选择，记录选择，下一次选择（递归），回退选择）</p><p>1、路径：也就是已经做出的选择。</p><p>2、选择列表：也就是你当前可以做的选择。</p><p>3、结束条件：也就是到达决策树底层，无法再做选择的条件。</p><h3 id="关联分析"><a href="#关联分析" class="headerlink" title="关联分析"></a>关联分析</h3><p>还没看</p><p><a href="https://www.cnblogs.com/LittleHann/p/9398219.html">https://www.cnblogs.com/LittleHann/p/9398219.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;持续更新&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;h3 id=&quot;三个渐近复杂度符号：&quot;&gt;&lt;a href=&quot;#三个渐近复杂度符号：&quot; </summary>
      
    
    
    
    <category term="计算机科学基础" scheme="https://hhumar.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Data Structure" scheme="https://hhumar.com/tags/Data-Structure/"/>
    
    <category term="Algorithm" scheme="https://hhumar.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Vue</title>
    <link href="https://hhumar.com/2022/11/05/vue/"/>
    <id>https://hhumar.com/2022/11/05/vue/</id>
    <published>2022-11-04T16:07:44.000Z</published>
    <updated>2022-11-05T18:13:47.344Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>持续更新</p></blockquote><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h2 id="基础内容"><a href="#基础内容" class="headerlink" title="基础内容"></a>基础内容</h2><p>SFC: Single File Component </p><p><strong>选项式 API</strong> 和<strong>组合式 API</strong></p><p>mustache 语法 (即双大括号<code>&#123;&#123;&#125;&#125;</code>) 只能用于文本插值。</p><p><code>reactive()</code> 只适用于对象 (包括数组和内置类型，如 <code>Map</code> 和 <code>Set</code>)。此外，<code>ref()</code> 可以接受任何值类型，并创建一个对象，在 <code>.value</code> property 下暴露内部值。都创建的是JavaScript proxy</p><p>ref()创建的proxy在其模板渲染上下文的顶层 property 时支持自动解包，</p><p>在 Vue 模板内，JavaScript 表达式可以被使用在如下场景上：</p><ul><li>在文本插值中 (双大括号)</li><li>在任何 Vue 指令 (以 <code>v-</code> 开头的特殊 attribute) attribute 的值中</li><li><strong>计算属性值会基于其响应式依赖被缓存</strong>，比方法更好，不会每次重新渲染都重新计算，只会在响应式依赖更新时重新计算。一个计算属性的声明中描述的是如何根据其他值派生一个值，因此计算函数的职责应该仅为计算和返回该值而非异步请求或者更改DOM。修改计算属性值也没有意义。</li></ul><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><pre class="language-none"><code class="language-none">在watcher中调用getter，执行addSub, 将target传入对应的dep; vue的实现本质就是如此Vue中一个发布者observer会被多个订阅者watcher订阅，同时一个订阅者也会订阅多个发布者，是多对多的关系，watcher也可以叫做依赖，依赖于发布者的变化从而执行其绑定的回调，dep可以叫做订阅中心，负责维护订阅列表</code></pre><p>2.x defineProperty 和 3.x Proxy 的区别：</p><p>2.x：</p><ul><li>检测不到对象属性的添加和删除</li><li>数组<code>API</code>方法无法监听到</li><li>需要对每个属性进行遍历监听，如果嵌套对象，需要深层监听，造成性能问题</li></ul><p>3.x</p><ul><li><p><code>Proxy</code>可以直接监听数组的变化（<code>push</code>、<code>shift</code>、<code>splice</code>）</p></li><li><p><code>Proxy</code>直接可以劫持整个对象，并返回一个新对象，我们可以只操作新的对象达到响应式目的</p></li><li><p>当对象嵌套对象时，递归响应式</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//实现深层响应式</span><span class="token keyword">function</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> obj<span class="token operator">!==</span><span class="token string">'object'</span> <span class="token operator">||</span> obj<span class="token operator">===</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> obj<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">const</span> observed <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span><span class="token punctuation">&#123;</span>        <span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span>key<span class="token punctuation">,</span>reciver<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">const</span> res <span class="token operator">=</span> Reflect<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span>key<span class="token punctuation">,</span>reciver<span class="token punctuation">)</span><span class="token punctuation">;</span>            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">getting </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>key<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token string">:</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>res<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token function">isObject</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token operator">?</span><span class="token function">reactive</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token operator">:</span>res<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> observed<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre></li><li><p><code>Proxy</code>有多达13种拦截方法,不限于<code>apply</code>、<code>ownKeys</code>、<code>deleteProperty</code>、<code>has</code>等等，这是<code>Object.defineProperty</code>不具备的</p><p>正因为<code>defineProperty</code>自身的缺陷，导致<code>Vue2</code>在实现响应式过程需要实现其他的方法辅助（如重写数组方法、增加额外<code>set</code>、<code>delete</code>方法）</p></li></ul><h2 id="vue指令"><a href="#vue指令" class="headerlink" title="vue指令"></a>vue指令</h2><ul><li><p>某些指令会需要一个“参数”，在指令名后通过一个冒号隔开做标识。</p><p>可以在绑定的表达式中使用一个组件暴露的方法</p><pre class="language-none"><code class="language-none">&lt;span :title&#x3D;&quot;toTitleDate(date)&quot;&gt;  &#123;&#123; formatDate(date) &#125;&#125;&lt;&#x2F;span&gt;</code></pre><p>在指令参数上也可以使用一个 JavaScript 表达式，需要包含在一对方括号内，称作动态参数</p><pre class="language-none"><code class="language-none">&lt;p :[attributename]&#x3D;&quot;attributeValue&quot;&gt;&lt;&#x2F;p&gt;&#x2F;&#x2F;动态参数期望值为字符串或 null ，null 代表显式移除该绑定，在HTML文件中时还要避免大写字母</code></pre><p>修饰符是以点开头的特殊后缀，表明指令需要以一些特殊的方式被绑定。例如 <code>.prevent</code> 修饰符会告知 <code>v-on</code> 指令对触发的事件调用 <code>event.preventDefault()</code></p><pre class="language-none"><code class="language-none">&lt;form @submit.prevent&#x3D;&quot;onSubmit&quot;&gt;...&lt;&#x2F;form&gt;</code></pre></li><li><p>v-html&#x3D;”html”</p><p>具有v-html属性的对应标签的innderHTML 会与html变量值保持一致</p></li><li><p>v-bind:attributeName&#x3D;”varName”给 attribute 绑定一个动态值<br>abbreviated.:attribute&#x3D;””<br>布尔型attribute根据值为true&#x2F;false来决定标签行为，下例中 isButtonDisabled 为非false布尔值或空字符串时，元素的disable属性值均为true</p><pre class="language-none"><code class="language-none">&lt;button :disabled&#x3D;&quot;isButtonDisabled&quot;&gt;Button&lt;&#x2F;button&gt;</code></pre><p>还可以通过不带参数的 v-bind 将包含多个 attribute 的JavaScript 对象绑定到单个元素</p><pre class="language-none"><code class="language-none">&lt;script&gt;const objectOfAttrs &#x3D; &#123;  id: &#39;container&#39;,  class: &#39;wrapper&#39;&#125;;&lt;&#x2F;script&gt;&lt;template&gt;&lt;div v-bind&#x3D;&quot;objectOfAttrs&quot;&gt;&lt;&#x2F;div&gt;&lt;&#x2F;template&gt;</code></pre></li><li><p>v-on:DOMEventName&#x3D;”funcName”监听DOM事件<br>abbreviated.@DOMEventName&#x3D;””</p></li><li><p>可以同时使用 v-bind 和 v-on 来在表单的输入元素上创建双向绑定：</p><pre class="language-none"><code class="language-none">&lt;input :value&#x3D;&quot;text&quot; @input&#x3D;&quot;onInput&quot;&gt;</code></pre><p>v-model是以上操作的语法糖</p><pre class="language-none"><code class="language-none">&lt;input v-model&#x3D;&quot;text&quot;&gt;</code></pre><p>v-model 会将被绑定的值与 <code>&lt;input&gt;</code> 的值自动同步</p></li><li><p>v-if&#x3D;”varName”条件渲染DOM元素，为真值时渲染，否则移除该DOM元素</p><pre class="language-none"><code class="language-none">&lt;h1 v-if&#x3D;&quot;awesome&quot;&gt;Vue is awesome!&lt;&#x2F;h1&gt;</code></pre><p>类似的有v-else和v-else-if可以与其配合使用，一个 <code>v-else</code>和<code>v-else-if</code> 元素必须跟在一个 <code>v-if</code> 或者 <code>v-else-if</code> 元素后面，否则将不会识别它。</p></li><li><p><code>v-show</code><a href="https://cn.vuejs.org/guide/essentials/conditional.html#v-show">#</a></p><p>另一个可以用来按条件显示一个元素的指令是 <code>v-show</code>。其用法基本一样：</p><p>template</p><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span> <span class="token attr-name">v-show</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>ok<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Hello!<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span></code></pre><p>不同之处在于 <code>v-show</code> 会在 DOM 渲染中保留该元素；<code>v-show</code> 仅切换了该元素上名为 <code>display</code> 的 CSS 属性。</p><p><code>v-show</code> 不支持在 <code>&lt;template&gt;</code> 元素上使用，也不能和 <code>v-else</code> 搭配使用。</p></li><li><p>v-for</p><p>以下代码能创建多个li元素</p><pre class="language-none"><code class="language-none">&lt;li v-for&#x3D;&quot;todo in todos&quot; :key&#x3D;&quot;todo.id&quot;&gt;  &lt;input type&#x3D;&quot;checkbox&quot; v-model&#x3D;&quot;todo.done&quot;&gt;  ...&lt;&#x2F;li&gt;</code></pre><p>key<a href="https://cn.vuejs.org/api/built-in-special-attributes.html#key">#</a></p><p><code>key</code> 这个特殊的 attribute 主要作为 Vue 的虚拟 DOM 算法提示，在比较新旧节点列表时用于识别 vnode。</p><ul><li><p><strong>预期</strong>：<code>number | string | symbol</code></p></li><li><p><strong>详细信息</strong></p><p>在没有 key 的情况下，Vue 将使用一种最小化元素移动的算法，并尽可能地就地更新&#x2F;复用相同类型的元素。如果传了 key，则将根据 key 的变化顺序来重新排列元素，并且将始终移除&#x2F;销毁 key 已经不存在的元素。</p><p>同一个父元素下的子元素必须具有<strong>唯一的 key</strong>。重复的 key 将会导致渲染异常。</p><p>最常见的用例是与 <code>v-for</code> 结合：</p><p>template</p><pre class="language-none"><code class="language-none">&lt;ul&gt;  &lt;li v-for&#x3D;&quot;item in items&quot; :key&#x3D;&quot;item.id&quot;&gt;...&lt;&#x2F;li&gt;&lt;&#x2F;ul&gt;</code></pre><p>也可以用于强制替换一个元素&#x2F;组件而不是复用它。当你想这么做时它可能会很有用：</p><ul><li>在适当的时候触发组件的生命周期钩子</li><li>触发过渡</li></ul><p>举例来说：</p><p>template</p><pre class="language-none"><code class="language-none">&lt;transition&gt;  &lt;span :key&#x3D;&quot;text&quot;&gt;&#123;&#123; text &#125;&#125;&lt;&#x2F;span&gt;&lt;&#x2F;transition&gt;</code></pre><p>当 <code>text</code> 变化时，<code>&lt;span&gt;</code> 总是会被替换而不是更新，因此 transition 将会被触发。</p></li></ul></li></ul><p>readonly 和 shallowreadonly</p><h3 id="模板引用"><a href="#模板引用" class="headerlink" title="模板引用"></a>模板引用</h3><p>为dom元素加上ref属性，在script中命名同名响应式属性即可操作模板</p><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">setup</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript"><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> ref<span class="token punctuation">,</span> onMounted <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'vue'</span><span class="token comment">// 声明一个 ref 来存放该元素的引用</span><span class="token comment">// 必须和模板里的 ref 同名</span><span class="token keyword">const</span> input <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token function">onMounted</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  input<span class="token punctuation">.</span>value<span class="token punctuation">.</span><span class="token function">focus</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>input<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span></code></pre><h2 id="响应式"><a href="#响应式" class="headerlink" title="响应式"></a>响应式</h2><p>reactive解构赋值便不再具有响应式，但是computed返回的内容是具有响应式的。</p><h2 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h2><p>计算属性的计算函数应只做计算而没有任何其他的副作用，一个计算属性的声明中描述的是如何根据其他值派生一个值。同时避免直接修改计算属性值。</p><p>从计算属性返回的值是派生状态。可以把它看作是一个“临时快照”，每当源状态发生变化时，就会创建一个新的快照。更改快照是没有意义的，因此计算属性的返回值应该被视为只读的，并且永远不应该被更改——应该更新它所依赖的源状态以触发新的计算。</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 组件中</span><span class="token keyword">function</span> <span class="token function">calculateBooksMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> author<span class="token punctuation">.</span>books<span class="token punctuation">.</span>length <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">?</span> <span class="token string">'Yes'</span> <span class="token operator">:</span> <span class="token string">'No'</span><span class="token punctuation">&#125;</span></code></pre><p>也可以同时传入 get 和 set 方法，超过只读范围来刻意产生副作用，此时传递给computed的是带有set和get方法的对象</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> ref<span class="token punctuation">,</span> computed <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'vue'</span><span class="token keyword">const</span> firstName <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token string">'John'</span><span class="token punctuation">)</span><span class="token keyword">const</span> lastName <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token string">'Doe'</span><span class="token punctuation">)</span><span class="token keyword">const</span> fullName <span class="token operator">=</span> <span class="token function">computed</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>  <span class="token comment">// getter</span>  <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> firstName<span class="token punctuation">.</span>value <span class="token operator">+</span> <span class="token string">' '</span> <span class="token operator">+</span> lastName<span class="token punctuation">.</span>value  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token comment">// setter</span>  <span class="token function">set</span><span class="token punctuation">(</span>newValue<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 注意：我们这里使用的是解构赋值语法</span>    <span class="token punctuation">[</span>firstName<span class="token punctuation">.</span>value<span class="token punctuation">,</span> lastName<span class="token punctuation">.</span>value<span class="token punctuation">]</span> <span class="token operator">=</span> newValue<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">' '</span><span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span></code></pre><h2 id="侦听器"><a href="#侦听器" class="headerlink" title="侦听器"></a>侦听器</h2><p>watch：watch是去监听一个值的变化，然后执行相对应的函数。</p><p>如果监听的数据源是一个 引用类型 时（ e.g. <code>Object</code> 、 <code>Array</code> 、 <code>Date</code> … ）， <code>value</code> 和 <code>oldValue</code> 是完全相同的，因为指向同一个对象。</p><pre class="language-typescript" data-language="typescript"><code class="language-typescript"><span class="token comment">// watch 部分的 TS 类型</span><span class="token comment">// ...</span><span class="token keyword">export</span> <span class="token keyword">declare</span> <span class="token keyword">function</span> <span class="token generic-function"><span class="token function">watch</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> Immediate <span class="token keyword">extends</span> Readonly<span class="token operator">&lt;</span><span class="token builtin">boolean</span><span class="token operator">></span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>  source<span class="token operator">:</span> WatchSource<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span><span class="token punctuation">,</span>  cb<span class="token operator">:</span> WatchCallback<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> Immediate <span class="token keyword">extends</span> <span class="token class-name"><span class="token boolean">true</span></span> <span class="token operator">?</span> <span class="token constant">T</span> <span class="token operator">|</span> <span class="token keyword">undefined</span> <span class="token operator">:</span> <span class="token constant">T</span><span class="token operator">></span><span class="token punctuation">,</span>  options<span class="token operator">?</span><span class="token operator">:</span> WatchOptions<span class="token operator">&lt;</span>Immediate<span class="token operator">></span><span class="token punctuation">)</span><span class="token operator">:</span> WatchStopHandle</code></pre><p>callback 有三个参数，依次为 value、oldValue、onCleanup清理函数。</p><p>还可以做批量监听，参数以数组形式传入，在回调函数中也以数组形式作为参数传入</p><p><code>watch</code> 的第一个参数可以是不同形式的“数据源”：它可以是一个 ref (包括计算属性)、一个响应式对象、一个 getter 函数、或多个数据源组成的数组：</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> x <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token keyword">const</span> y <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token comment">// 单个 ref</span><span class="token function">watch</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">newX</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">x is </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>newX<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token comment">// getter 函数</span><span class="token function">watch</span><span class="token punctuation">(</span>  <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> x<span class="token punctuation">.</span>value <span class="token operator">+</span> y<span class="token punctuation">.</span>value<span class="token punctuation">,</span>  <span class="token punctuation">(</span><span class="token parameter">sum</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">sum of x + y is: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>sum<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token comment">// 多个来源组成的数组</span><span class="token function">watch</span><span class="token punctuation">(</span><span class="token punctuation">[</span>x<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> y<span class="token punctuation">.</span>value<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">[</span>newX<span class="token punctuation">,</span> newY<span class="token punctuation">]</span></span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">x is </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>newX<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token string"> and y is </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>newY<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span></code></pre><p>关于 options</p><table><thead><tr><th>deep</th><th>boolean</th><th>false</th><th>true | false</th><th>是否进行深度监听，适用于监听 ref 响应式引用对象</th></tr></thead><tbody><tr><td>immediate</td><td>boolean</td><td>false</td><td>true | false</td><td>是否立即执行监听回调，包括初始化，为 false 时初始化不调用回调</td></tr><tr><td>flush</td><td>string</td><td>‘pre’</td><td>‘pre’ | ‘post’ | ‘sync’</td><td>控制监听回调的调用时机</td></tr><tr><td>onTrack</td><td>(e) &#x3D;&gt; void</td><td></td><td></td><td>在数据源被追踪时调用</td></tr><tr><td>onTrigger</td><td>(e) &#x3D;&gt; void</td><td></td><td></td><td>在监听回调被触发时调用</td></tr></tbody></table><p>deep在传入为 reactive 时自动开启，可以搭配传入 ref 引用对象使用</p><p>在带有 immediate 选项时，不能在第一次回调时取消该数据源的监听</p><p>定义一个 watch 行为的时候，它会返回一个用来停止监听的函数</p><h2 id="模板引用-1"><a href="#模板引用-1" class="headerlink" title="模板引用"></a>模板引用</h2><p>使用 ref 在dom 中挂载结点，必须使用 xxx.value 才能访问到模板 dom 元素</p><h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><h3 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h3><p>全局注册和局部注册，3.2之后好像局部注册就够了</p><h3 id="Props"><a href="#Props" class="headerlink" title="Props"></a>Props</h3><p>组件间传递值</p><p>在子组件中定义属性向外暴露，外部组件用 v-bind 传递进来，</p><pre class="language-jsx" data-language="jsx"><code class="language-jsx"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">setup</span><span class="token punctuation">></span></span><span class="token plain-text">const props = defineProps(['foo'])console.log(props.foo)    //or// 使用 &lt;script setup>defineProps(&#123;  title: String,  likes: Number&#125;)</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span></code></pre><p>在ts中</p><pre class="language-tsx" data-language="tsx"><code class="language-tsx"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">setup</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>ts<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">defineProps&lt;&#123;  title?: string  likes?: number&#125;>()</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span></code></pre><h3 id="透传attrs"><a href="#透传attrs" class="headerlink" title="透传attrs"></a>透传attrs</h3><p>非props，直接赋值</p><h4 id="v-on-监听器继承"><a href="#v-on-监听器继承" class="headerlink" title="v-on 监听器继承#"></a><code>v-on</code> 监听器继承<a href="https://cn.vuejs.org/guide/components/attrs.html#v-on-listener-inheritance">#</a></h4><p>同样的规则也适用于 <code>v-on</code> 事件监听器：</p><p>template</p><pre class="language-none"><code class="language-none">&lt;MyButton @click&#x3D;&quot;onClick&quot; &#x2F;&gt;</code></pre><p><code>click</code> 监听器会被添加到 <code>&lt;MyButton&gt;</code> 的根元素，即那个原生的 <code>&lt;button&gt;</code> 元素之上。当原生的 <code>&lt;button&gt;</code> 被点击，会触发父组件的 <code>onClick</code> 方法。同样的，如果原生 <code>button</code> 元素自身也通过 <code>v-on</code> 绑定了一个事件监听器，则这个监听器和从父组件继承的监听器都会被触发。</p><h4 id="深层组件继承"><a href="#深层组件继承" class="headerlink" title="深层组件继承#"></a>深层组件继承<a href="https://cn.vuejs.org/guide/components/attrs.html#nested-component-inheritance">#</a></h4><p>有些情况下一个组件会在根节点上渲染另一个组件。例如，我们重构一下 <code>&lt;MyButton&gt;</code>，让它在根节点上渲染 <code>&lt;BaseButton&gt;</code>：</p><p>template</p><pre class="language-none"><code class="language-none">&lt;!-- &lt;MyButton&#x2F;&gt; 的模板，只是渲染另一个组件 --&gt;&lt;BaseButton &#x2F;&gt;</code></pre><ol><li>透传的 attribute 不会包含 <code>&lt;MyButton&gt;</code> 上声明过的 props 或是针对 <code>emits</code> 声明事件的 <code>v-on</code> 侦听函数，换句话说，声明过的 props 和侦听函数被 <code>&lt;MyButton&gt;</code>“消费”了。</li><li>透传的 attribute 若符合声明，也可以作为 props 传入 <code>&lt;BaseButton&gt;</code>。</li></ol><p>禁用attrs：如果你<strong>不想要</strong>一个组件自动地继承 attribute，你可以在组件选项中设置 <code>inheritAttrs: false</code>。</p><p>管理所有透传attrs</p><p>const attrs &#x3D; useAttrs();</p><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p>组件直接传递事件，Child.vue 通过 emit 向 Father.vue 触发父组件的事件执行</p><p>和原生 DOM 事件不一样，组件触发的事件<strong>没有冒泡机制</strong>。你只能监听直接子组件触发的事件。平级组件或是跨越多层嵌套的组件间通信，应使用一个外部的事件总线，或是使用一个<a href="https://cn.vuejs.org/guide/scaling-up/state-management.html">全局状态管理方案</a></p><p>defineEmits</p><p>emit</p><pre class="language-typescript" data-language="typescript"><code class="language-typescript"><span class="token operator">&lt;</span>script setup<span class="token operator">></span><span class="token keyword">const</span> emit <span class="token operator">=</span> <span class="token function">defineEmits</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'inFocus'</span><span class="token punctuation">,</span> <span class="token string">'submit'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">function</span> <span class="token function">buttonClick</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token function">emit</span><span class="token punctuation">(</span><span class="token string">'submit'</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span></code></pre><p>这个 <code>emits</code> 选项还支持对象语法，它允许我们对触发事件的参数进行验证：</p><p>vue</p><pre class="language-none"><code class="language-none">&lt;script setup&gt;const emit &#x3D; defineEmits(&#123;  submit(payload) &#123;    &#x2F;&#x2F; 通过返回值为 &#96;true&#96; 还是为 &#96;false&#96; 来判断    &#x2F;&#x2F; 验证是否通过  &#125;&#125;)&lt;&#x2F;script&gt;</code></pre><h3 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h3><p><slot />写在子组件中供父组件传递dom内容</p><p><code>&lt;slot&gt;</code> 元素是一个<strong>插槽出口</strong> (slot outlet)，标示了父元素提供的<strong>插槽内容</strong> (slot content) 将在哪里被渲染。</p><p>插槽内容可以访问到父组件的数据作用域，<strong>无法访问</strong>子组件的数据</p><h4 id="具名插槽"><a href="#具名插槽" class="headerlink" title="具名插槽"></a>具名插槽</h4><p>带 <code>name</code> 的插槽被称为具名插槽 (named slots)。没有提供 <code>name</code> 的 <code>&lt;slot&gt;</code> 出口会隐式地命名为“default”</p><p><code>v-slot</code> 有对应的简写 <code>#</code>，因此 <code>&lt;template v-slot:header&gt;</code> 可以简写为 <code>&lt;template #header&gt;</code>。其意思就是“将这部分模板片段传入子组件的 header 插槽中”。</p><p>当一个组件同时接收默认插槽和具名插槽时，所有位于顶级的非 <code>&lt;template&gt;</code> 节点都被隐式地视为默认插槽的内容。</p><p>例子：</p><p>待接收插槽内容的子组件</p><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>container<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>header</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>slot</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>header<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>slot</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>header</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>main</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>slot</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>slot</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>main</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>footer</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>slot</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>footer<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>slot</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>footer</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span></code></pre><p>父组件</p><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>BaseLayout</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span> <span class="token attr-name">#header</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">></span></span>Here might be a page title<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span>  <span class="token comment">&lt;!-- 隐式的默认插槽 --></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>A paragraph for the main content.<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>And another one.<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>  <span class="token comment">&lt;!--     &lt;template #default>    &lt;p>A paragraph for the main content.&lt;/p>    &lt;p>And another one.&lt;/p>    &lt;/template>     --></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span> <span class="token attr-name">#footer</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>Here's some contact info<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>BaseLayout</span><span class="token punctuation">></span></span></code></pre><p>子组件渲染结果</p><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>container<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>header</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">></span></span>Here might be a page title<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>header</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>main</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>A paragraph for the main content.<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>And another one.<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>main</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>footer</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>Here's some contact info<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>footer</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span></code></pre><p>支持动态指令参数</p><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span> <span class="token attr-name"><span class="token namespace">v-slot:</span>[dynamicSlotName]</span><span class="token punctuation">></span></span>  ...<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span><span class="token comment">&lt;!-- 缩写为 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span> <span class="token attr-name">#[dynamicSlotName]</span><span class="token punctuation">></span></span>  ...<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span></code></pre><h3 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h3><p>祖先组件中用provide提供依赖，后代任意位置可使用inject注入该依赖</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//祖先</span><span class="token keyword">const</span> message <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token string">'hello'</span><span class="token punctuation">)</span><span class="token function">provide</span><span class="token punctuation">(</span><span class="token string">'message'</span><span class="token punctuation">,</span> message<span class="token punctuation">)</span><span class="token comment">//name, value</span><span class="token comment">//后代</span><span class="token keyword">const</span> message <span class="token operator">=</span> <span class="token function">inject</span><span class="token punctuation">(</span><span class="token string">'message'</span><span class="token punctuation">)</span><span class="token comment">//name</span></code></pre><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>created:html加载完成之前，执行。执行顺序：父组件-子组件</p><p>mounted:html加载完成后执行。执行顺序：子组件-父组件</p><p>methods：事件方法执行</p><p>created()：组件实例创建完成，dom还未生成，仅仅触发一次； mounted是挂载vue实例后的钩子函数，仅仅执行一次； activated()：在使用时，会用到activated(),keep-live主要目的是可以使用缓存，避免组件重新渲染；</p><p>activated()只要进入页面就会触发</p><p><img src="/2022/11/05/vue/lifecycle_vue3.png" alt="lifecycle_vue3"></p><h2 id="全局API"><a href="#全局API" class="headerlink" title="全局API"></a>全局API</h2><h3 id="nextTick"><a href="#nextTick" class="headerlink" title="nextTick()#"></a>nextTick()<a href="https://cn.vuejs.org/api/general.html#nexttick">#</a></h3><p>等待下一次 DOM 更新刷新的工具方法。</p><ul><li><p><strong>类型</strong></p><pre class="language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">function</span> <span class="token function">nextTick</span><span class="token punctuation">(</span>callback<span class="token operator">?</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token keyword">void</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Promise</span><span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token operator">></span></code></pre></li><li><p><strong>详细信息</strong></p><p>当你在 Vue 中更改响应式状态时，最终的 DOM 更新并不是同步生效的，而是由 Vue 将它们缓存在一个队列中，直到下一个“tick”才一起执行。这样是为了确保每个组件无论发生多少状态改变，都仅执行一次更新。</p><p><code>nextTick()</code> 可以在状态改变后立即使用，以等待 DOM 更新完成。你可以传递一个回调函数作为参数，或者 await 返回的 Promise。</p></li></ul><h2 id="路由vue-router"><a href="#路由vue-router" class="headerlink" title="路由vue-router"></a>路由vue-router</h2><ul><li><p>router-link</p><p>链接，类似a标签，但是自定义组件，使得 Vue Router 可以在不重新加载页面的情况下更改 URL，处理 URL 的生成以及编码</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//如导航代码</span> <span class="token operator">&lt;</span>router<span class="token operator">-</span>link <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"nav-link"</span> to<span class="token operator">=</span><span class="token string">"ContactUs"</span><span class="token operator">></span>联系我们<span class="token operator">&lt;</span><span class="token operator">/</span>router<span class="token operator">-</span>link<span class="token operator">></span><span class="token number">12</span></code></pre><p>通过router-link可以使<code>&lt;router-view/&gt;</code>中的显示内容路由（跳转）到<code>src/router/index.js</code>文件中配置的组件中去，这类似于html的a标签中的href（注意：href页面会刷新，在这里则不会），其实这就好比tab选项卡中的头部选项，<code>router-view好比tab选项卡的body选项。</code></p></li><li><p>router-view</p><p>显示与 url 对应的组件</p><p>默认刚进入网页时是’&#x2F;‘</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token operator">&lt;</span>router<span class="token operator">-</span>view<span class="token operator">></span><span class="token operator">&lt;</span>router<span class="token operator">-</span>view<span class="token operator">/</span><span class="token operator">></span>（命名视图）<span class="token number">1</span><span class="token operator">&lt;</span>router<span class="token operator">-</span>view<span class="token operator">/</span><span class="token operator">></span>（嵌套命名视图）<span class="token number">1</span></code></pre><p><code>&lt;router-view&gt;</code> 是用来渲染通过路由映射过来的组件，当路径更改时， 其中的内容也会发生更改</p><p><strong>主要应用于单页面中，与<code>router-link</code>配合，渲染<code>router-link</code> 映射过来的组件。</strong></p><p>运作过程：就是几个跳转链接跳到对应的子页面，程序运行的时候，会将<code>&lt;template&gt;</code>标签里面的内容都注入到App.vue页面中的<code>router-view</code>标签中，从而实现无刷新的路由跳转。</p></li><li><p>createRouter(<strong>RouterOptions</strong> )</p><pre class="language-typescript" data-language="typescript"><code class="language-typescript">RouterOptions <span class="token keyword">extends</span> <span class="token class-name">PathParserOptions</span><span class="token punctuation">&#123;</span>​history<span class="token operator">:</span> RouterHistory<span class="token punctuation">;</span>​routes<span class="token operator">:</span> RouteRecordRaw<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre></li><li><p>useRoute<a href="https://router.vuejs.org/zh/api/#useroute">#</a></p><p>返回当前路由地址。相当于在模板中使用 <code>$route</code>。必须在 <code>setup()</code> 中调用。</p><p><strong>函数签名：</strong></p><pre class="language-none"><code class="language-none">export declare function useRoute(): RouteLocationNormalized</code></pre><p>useRouter<a href="https://router.vuejs.org/zh/api/#userouter">#</a></p><p>返回 <a href="https://router.vuejs.org/zh/api/#router-properties">router</a> 实例。相当于在模板中使用 <code>$router</code>。必须在 <code>setup()</code> 中调用。</p><p><strong>函数签名：</strong></p><pre class="language-none"><code class="language-none">export declare function useRouter(): Router</code></pre></li><li></li><li><p><a href="https://router.vuejs.org/zh/api/#createwebhistory">createWebHistory()</a></p><p>创建一个 HTML5 历史，即单页面应用程序中最常见的历史记录。应用程序必须通过 http 协议被提供服务。</p><p>可选参数base为托管目录</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token function">createWebHistory</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 没有 base，应用托管在域名 `https://example.com` 的根目录下。</span><span class="token function">createWebHistory</span><span class="token punctuation">(</span><span class="token string">'/folder/'</span><span class="token punctuation">)</span> <span class="token comment">// 给出的网址为 `https://example.com/folder/`</span></code></pre></li><li><p>router.push<a href="https://router.vuejs.org/zh/api/#push">#</a></p><p>通过在历史堆栈中推送一个 entry，以编程方式导航到一个新的 URL。</p><p><strong>函数签名：</strong></p><pre class="language-none"><code class="language-none">push(to: RouteLocationRaw): Promise&lt;NavigationFailure | void | undefined&gt;</code></pre><p><em>参数</em></p><table><thead><tr><th>参数</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>to</td><td><a href="https://router.vuejs.org/zh/api/#routelocationraw"><code>RouteLocationRaw</code></a></td><td>要导航到的路由地址</td></tr></tbody></table></li></ul><p>ts类型</p><ul><li><p>RouteRecordRaw</p><pre class="language-none"><code class="language-none">export declare type RouteRecordRaw &#x3D; RouteRecordSingleView | RouteRecordMultipleViews | RouteRecordRedirect;</code></pre></li><li><p>RouteLocationNormalized</p><pre class="language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">export</span> <span class="token keyword">declare</span> <span class="token keyword">interface</span> <span class="token class-name">RouteLocationNormalized</span> <span class="token keyword">extends</span> <span class="token class-name">_RouteLocationBase</span> <span class="token punctuation">&#123;</span>    <span class="token comment">/**     * Array of &#123;@link RouteRecordNormalized&#125;     */</span>    matched<span class="token operator">:</span> RouteRecordNormalized<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">export</span> <span class="token keyword">declare</span> <span class="token keyword">interface</span> <span class="token class-name">_RouteLocationBase</span> <span class="token keyword">extends</span> <span class="token class-name">Pick<span class="token operator">&lt;</span>MatcherLocation<span class="token punctuation">,</span> <span class="token string">'name'</span> <span class="token operator">|</span> <span class="token string">'path'</span> <span class="token operator">|</span> <span class="token string">'params'</span> <span class="token operator">|</span> <span class="token string">'meta'</span><span class="token operator">></span></span> <span class="token punctuation">&#123;</span>    <span class="token comment">/**     * The whole location including the `search` and `hash`. This string is     * percentage encoded.     */</span>    fullPath<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>    <span class="token comment">/**     * Object representation of the `search` property of the current location.     */</span>    query<span class="token operator">:</span> LocationQuery<span class="token punctuation">;</span>    <span class="token comment">/**     * Hash of the current location. If present, starts with a `#`.     */</span>    hash<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>    <span class="token comment">/**     * Contains the location we were initially trying to access before ending up     * on the current location.     */</span>    redirectedFrom<span class="token operator">:</span> RouteLocation <span class="token operator">|</span> <span class="token keyword">undefined</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">declare</span> <span class="token keyword">interface</span> <span class="token class-name">MatcherLocation</span> <span class="token punctuation">&#123;</span>    <span class="token comment">/**     * Name of the matched record     */</span>    name<span class="token operator">:</span> RouteRecordName <span class="token operator">|</span> <span class="token keyword">null</span> <span class="token operator">|</span> <span class="token keyword">undefined</span><span class="token punctuation">;</span>    <span class="token comment">/**     * Percentage encoded pathname section of the URL.     */</span>    path<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>    <span class="token comment">/**     * Object of decoded params extracted from the `path`.     */</span>    params<span class="token operator">:</span> RouteParams<span class="token punctuation">;</span>    <span class="token comment">/**     * Merged `meta` properties from all the matched route records.     */</span>    meta<span class="token operator">:</span> RouteMeta<span class="token punctuation">;</span>    <span class="token comment">/**     * Array of &#123;@link RouteRecord&#125; containing components as they were     * passed when adding records. It can also contain redirect records. This     * can't be used directly     */</span>    matched<span class="token operator">:</span> RouteRecord<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre></li><li><p>Router 属性<a href="https://router.vuejs.org/zh/api/#router-%E5%B1%9E%E6%80%A7">#</a></p><p>currentRoute<a href="https://router.vuejs.org/zh/api/#currentroute">#</a></p><ul><li><p><strong>类型</strong>：Ref<RouteLocationNormalized></p></li><li><p><strong>详细内容</strong>：</p><p>当前路由地址。只读的。</p></li></ul><p>options<a href="https://router.vuejs.org/zh/api/#options">#</a></p><ul><li><p><strong>类型</strong>：<a href="https://router.vuejs.org/zh/api/#routeroptions"><code>RouterOptions</code></a></p></li><li><p><strong>详细内容</strong>：</p><p>创建 Router 时传递的原始配置对象。只读的。</p></li></ul></li></ul><h2 id="状态管理工具"><a href="#状态管理工具" class="headerlink" title="状态管理工具"></a>状态管理工具</h2><h3 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h3><p>中大型项目</p><h3 id="Pinia"><a href="#Pinia" class="headerlink" title="Pinia"></a>Pinia</h3><p>小型项目</p><p>一个 Store （如 Pinia）是一个实体，它持有未绑定到您的组件树的状态和业务逻辑。换句话说，<strong>它托管全局状态</strong>。它有点像一个始终存在并且每个人都可以读取和写入的组件。它有<strong>三个概念</strong>，<a href="https://pinia.web3doc.top/core-concepts/state.html">state</a>、<a href="https://pinia.web3doc.top/core-concepts/getters.html">getters</a> 和 <a href="https://pinia.web3doc.top/core-concepts/actions.html">actions</a> 并且可以安全地假设这些概念等同于组件中的“数据”、“计算”和“方法”。</p><p>可以通过调用 store 上的 <code>$reset()</code> 方法将状态 <em>重置</em> 到其初始值：</p><pre class="language-none"><code class="language-none">const store &#x3D; useStore()store.$reset()</code></pre><h2 id="构建工具"><a href="#构建工具" class="headerlink" title="构建工具"></a>构建工具</h2><h3 id="vite"><a href="#vite" class="headerlink" title="vite"></a>vite</h3><p>Vite 在一个特殊的 <strong><code>import.meta.env</code></strong> 对象上暴露环境变量。这里有一些在所有情况下都可以使用的内建变量：</p><ul><li><strong><code>import.meta.env.MODE</code></strong>: {string} 应用运行的<a href="https://cn.vitejs.dev/guide/env-and-mode.html#modes">模式</a>。<ul><li>默认情况下，开发服务器 (<code>dev</code> 命令) 运行在 <code>development</code> (开发) 模式，而 <code>build</code> 命令则运行在 <code>production</code> (生产) 模式。</li></ul></li><li><strong><code>import.meta.env.BASE_URL</code></strong>: {string} 部署应用时的基本 URL。他由<a href="https://cn.vitejs.dev/config/shared-options.html#base"><code>base</code> 配置项</a>决定。</li><li><strong><code>import.meta.env.PROD</code></strong>: {boolean} 应用是否运行在生产环境。</li><li><strong><code>import.meta.env.DEV</code></strong>: {boolean} 应用是否运行在开发环境 (永远与 <code>import.meta.env.PROD</code>相反)。</li><li><strong><code>import.meta.env.SSR</code></strong>: {boolean} 应用是否运行在 <a href="https://cn.vitejs.dev/guide/ssr.html#conditional-logic">server</a> 上。</li></ul><p>不支持动态读取值。在生产环境中，这些环境变量会在构建时被<strong>静态替换</strong>，例如，动态 key 取值 <code>import.meta.env[key]</code> 是无效的。</p><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><ul><li><p>base<a href="https://cn.vitejs.dev/config/shared-options.html#base">¶</a></p><ul><li><strong>类型：</strong> <code>string</code></li><li><strong>默认：</strong> <code>/</code></li></ul><p>开发或生产环境服务的公共基础路径。合法的值包括以下几种：</p><ul><li>绝对 URL 路径名，例如 <code>/foo/</code></li><li>完整的 URL，例如 <code>https://foo.com/</code></li><li>空字符串或 <code>./</code>（用于嵌入形式的开发）</li></ul></li><li><p>plugins<a href="https://cn.vitejs.dev/config/shared-options.html#plugins">¶</a></p><ul><li><strong>类型：</strong> <code>(Plugin | Plugin[] | Promise&lt;Plugin | Plugin[]&gt;)[]</code></li></ul><p>需要用到的插件数组。Falsy 虚值的插件将被忽略，插件数组将被扁平化（flatten）。查看 <a href="https://cn.vitejs.dev/guide/api-plugin.html">插件 API</a> 获取 Vite 插件的更多细节。</p></li><li><p>server</p><ul><li><p>.host<a href="https://cn.vitejs.dev/config/server-options.html#server-host">¶</a></p><ul><li><strong>类型：</strong> <code>string | boolean</code></li><li><strong>默认：</strong> <code>&#39;localhost&#39;</code></li></ul><p>指定服务器应该监听哪个 IP 地址。 如果将此设置为 <code>0.0.0.0</code> 或者 <code>true</code> 将监听所有地址，包括局域网和公网地址。localhost一般用来测试本机，监听本机请求。</p></li><li><p>.port</p><ul><li><strong>类型：</strong> <code>number</code></li><li><strong>默认值：</strong> <code>5173</code></li></ul><p>指定监听端口。注意：如果端口已经被使用，Vite 会自动尝试下一个可用的端口，所以这可能不是开发服务器最终监听的实际端口。</p></li></ul></li></ul><h2 id="UI框架"><a href="#UI框架" class="headerlink" title="UI框架"></a>UI框架</h2><h3 id="element-plus"><a href="#element-plus" class="headerlink" title="element-plus"></a>element-plus</h3><h4 id="el-input"><a href="#el-input" class="headerlink" title="el-input"></a>el-input</h4><h4 id="el-button"><a href="#el-button" class="headerlink" title="el-button"></a>el-button</h4><table><thead><tr><th align="left">属性名</th><th align="left">说明</th><th align="left">类型</th><th align="left">可选值</th><th align="left">默认值</th></tr></thead><tbody><tr><td align="left">size</td><td align="left">尺寸</td><td align="left">string</td><td align="left">large &#x2F; default &#x2F;small</td><td align="left">—</td></tr><tr><td align="left">type</td><td align="left">类型</td><td align="left">string</td><td align="left">primary &#x2F; success &#x2F; warning &#x2F; danger &#x2F; info &#x2F; <del>text</del></td><td align="left">—</td></tr></tbody></table><p>详见<a href="https://element-plus.gitee.io/zh-CN/component/button.html#button-%E5%B1%9E%E6%80%A7">https://element-plus.gitee.io/zh-CN/component/button.html#button-%E5%B1%9E%E6%80%A7</a></p><h4 id="el-dialog"><a href="#el-dialog" class="headerlink" title="el-dialog"></a>el-dialog</h4><table><thead><tr><th align="left">属性名</th><th align="left">说明</th><th align="left">类型</th><th align="left">可选值</th><th align="left">默认值</th></tr></thead><tbody><tr><td align="left">model-value &#x2F; v-model</td><td align="left">是否显示 Dialog</td><td align="left">boolean</td><td align="left">—</td><td align="left">—</td></tr><tr><td align="left">title</td><td align="left">Dialog 对话框 Dialog 的标题， 也可通过具名 slot （见下表）传入</td><td align="left">string</td><td align="left">—</td><td align="left">—</td></tr><tr><td align="left">width</td><td align="left">Dialog 的宽度</td><td align="left">string &#x2F; number</td><td align="left">—</td><td align="left">50%</td></tr><tr><td align="left">fullscreen</td><td align="left">是否为全屏 Dialog</td><td align="left">boolean</td><td align="left">—</td><td align="left">false</td></tr><tr><td align="left">top</td><td align="left">Dialog CSS 中的 margin-top 值</td><td align="left">string</td><td align="left">—</td><td align="left">15vh</td></tr><tr><td align="left">modal</td><td align="left">是否需要遮罩层</td><td align="left">boolean</td><td align="left">—</td><td align="left">true</td></tr><tr><td align="left">lock-scroll</td><td align="left">是否在 Dialog 出现时将 body 滚动锁定</td><td align="left">boolean</td><td align="left">—</td><td align="left">true</td></tr><tr><td align="left">open-delay</td><td align="left">Dialog 打开的延时时间，单位毫秒</td><td align="left">number</td><td align="left">—</td><td align="left">0</td></tr><tr><td align="left">close-delay</td><td align="left">Dialog 关闭的延时时间，单位毫秒</td><td align="left">number</td><td align="left">—</td><td align="left">0</td></tr><tr><td align="left">close-on-click-modal</td><td align="left">是否可以通过点击 modal 关闭 Dialog</td><td align="left">boolean</td><td align="left">—</td><td align="left">true</td></tr><tr><td align="left">close-on-press-escape</td><td align="left">是否可以通过按下 ESC 关闭 Dialog</td><td align="left">boolean</td><td align="left">—</td><td align="left">true</td></tr><tr><td align="left">show-close</td><td align="left">是否显示关闭按钮</td><td align="left">boolean</td><td align="left">—</td><td align="left">true</td></tr><tr><td align="left">before-close</td><td align="left">关闭前的回调，会暂停 Dialog 的关闭. 回调函数内执行 done 参数方法的时候才是真正关闭对话框的时候.</td><td align="left">Function(done) (done 用来关闭 Dialog)</td><td align="left">—</td><td align="left">—</td></tr></tbody></table><p><a href="https://element-plus.gitee.io/zh-CN/component/dialog.html#%E5%B1%9E%E6%80%A7">https://element-plus.gitee.io/zh-CN/component/dialog.html#%E5%B1%9E%E6%80%A7</a></p><h4 id="el-drawer"><a href="#el-drawer" class="headerlink" title="el-drawer*"></a>el-drawer*</h4><h3 id="el-upload"><a href="#el-upload" class="headerlink" title="el-upload*"></a>el-upload*</h3><h4 id="Form"><a href="#Form" class="headerlink" title="Form"></a>Form</h4><p><strong>FormInstance</strong>类型，可以辅助vue3中的ref属性为dom操作提供便利，</p><p>方法</p><ul><li><p>validate</p><pre class="language-typescript" data-language="typescript"><code class="language-typescript"><span class="token comment">//类型</span><span class="token punctuation">(</span>callback<span class="token operator">?</span><span class="token operator">:</span> <span class="token punctuation">(</span>isValid<span class="token operator">:</span> <span class="token builtin">boolean</span><span class="token punctuation">,</span> invalidFields<span class="token operator">?</span><span class="token operator">:</span> ValidateFieldsError<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token builtin">Promise</span><span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token operator">></span></code></pre></li><li><p>validator：自定义校验规则</p><p>为指定字段定制验证函数</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> fields <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  <span class="token literal-property property">field</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token function">validator</span><span class="token punctuation">(</span><span class="token parameter">rule<span class="token punctuation">,</span> value<span class="token punctuation">,</span> callback</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">return</span> value <span class="token operator">===</span> <span class="token string">'test'</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token literal-property property">message</span><span class="token operator">:</span> <span class="token string">'Value is not equal to "test".'</span><span class="token punctuation">,</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token literal-property property">field2</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token function">validator</span><span class="token punctuation">(</span><span class="token parameter">rule<span class="token punctuation">,</span> value<span class="token punctuation">,</span> callback</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>value<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token string"> is not equal to 'test'.</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>   <span class="token literal-property property">arrField</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token function">validator</span><span class="token punctuation">(</span><span class="token parameter">rule<span class="token punctuation">,</span> value</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">return</span> <span class="token punctuation">[</span>        <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'Message 1'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'Message 2'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>      <span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><p>asyncValidator</p><p>详见<a href="https://github.com/yiminghe/async-validator#options">https://github.com/yiminghe/async-validator#options</a></p></li><li><p><strong>FormItemRule</strong></p><pre class="language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">export</span> <span class="token keyword">declare</span> <span class="token keyword">type</span> <span class="token class-name">Arrayable<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token operator">|</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">interface</span> <span class="token class-name">FormItemRule</span> <span class="token keyword">extends</span> <span class="token class-name">RuleItem</span> <span class="token punctuation">&#123;</span>    trigger<span class="token operator">?</span><span class="token operator">:</span> Arrayable<span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token operator">></span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">export</span> <span class="token keyword">interface</span> <span class="token class-name">RuleItem</span> <span class="token punctuation">&#123;</span>    type<span class="token operator">?</span><span class="token operator">:</span> RuleType<span class="token punctuation">;</span>    required<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">boolean</span><span class="token punctuation">;</span>    pattern<span class="token operator">?</span><span class="token operator">:</span> RegExp <span class="token operator">|</span> <span class="token builtin">string</span><span class="token punctuation">;</span>    min<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>    max<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>    len<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>    <span class="token keyword">enum</span><span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">Array</span><span class="token operator">&lt;</span><span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span> <span class="token operator">|</span> <span class="token builtin">boolean</span> <span class="token operator">|</span> <span class="token keyword">null</span> <span class="token operator">|</span> <span class="token keyword">undefined</span><span class="token operator">></span><span class="token punctuation">;</span>    whitespace<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">boolean</span><span class="token punctuation">;</span>    fields<span class="token operator">?</span><span class="token operator">:</span> Record<span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token punctuation">,</span> Rule<span class="token operator">></span><span class="token punctuation">;</span>    options<span class="token operator">?</span><span class="token operator">:</span> ValidateOption<span class="token punctuation">;</span>    defaultField<span class="token operator">?</span><span class="token operator">:</span> Rule<span class="token punctuation">;</span>    transform<span class="token operator">?</span><span class="token operator">:</span> <span class="token punctuation">(</span>value<span class="token operator">:</span> Value<span class="token punctuation">)</span> <span class="token operator">=></span> Value<span class="token punctuation">;</span>    message<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>a<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    asyncValidator<span class="token operator">?</span><span class="token operator">:</span> <span class="token punctuation">(</span>rule<span class="token operator">:</span> InternalRuleItem<span class="token punctuation">,</span> value<span class="token operator">:</span> Value<span class="token punctuation">,</span> <span class="token function-variable function">callback</span><span class="token operator">:</span> <span class="token punctuation">(</span>error<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">|</span> Error<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token keyword">void</span><span class="token punctuation">,</span> source<span class="token operator">:</span> Values<span class="token punctuation">,</span> options<span class="token operator">:</span> ValidateOption<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token keyword">void</span> <span class="token operator">|</span> <span class="token builtin">Promise</span><span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token operator">></span><span class="token punctuation">;</span>    validator<span class="token operator">?</span><span class="token operator">:</span> <span class="token punctuation">(</span>rule<span class="token operator">:</span> InternalRuleItem<span class="token punctuation">,</span> value<span class="token operator">:</span> Value<span class="token punctuation">,</span> <span class="token function-variable function">callback</span><span class="token operator">:</span> <span class="token punctuation">(</span>error<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">|</span> Error<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token keyword">void</span><span class="token punctuation">,</span> source<span class="token operator">:</span> Values<span class="token punctuation">,</span> options<span class="token operator">:</span> ValidateOption<span class="token punctuation">)</span> <span class="token operator">=></span> SyncValidateResult <span class="token operator">|</span> <span class="token keyword">void</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre></li></ul><h3 id="Icon"><a href="#Icon" class="headerlink" title="Icon"></a>Icon</h3><p><a href="https://element-plus.gitee.io/zh-CN/component/icon.html">https://element-plus.gitee.io/zh-CN/component/icon.html</a></p><h4 id="ElMessage"><a href="#ElMessage" class="headerlink" title="ElMessage"></a>ElMessage</h4><p>配置项</p><table><thead><tr><th align="left">属性</th><th align="left">说明</th><th align="left">类型</th><th align="left">默认值</th></tr></thead><tbody><tr><td align="left"><code>message</code></td><td align="left">消息文字</td><td align="left">&#96;string</td><td align="left">VNode</td></tr><tr><td align="left"><code>type</code></td><td align="left">消息类型</td><td align="left">&#96;’success’</td><td align="left">‘warning’</td></tr><tr><td align="left"><code>icon</code></td><td align="left">自定义图标，该属性会覆盖 <code>type</code> 的图标。</td><td align="left">&#96;string</td><td align="left">Component&#96;</td></tr><tr><td align="left"><code>dangerouslyUseHTMLString</code></td><td align="left">是否将 message 属性作为 HTML 片段处理</td><td align="left"><code>boolean</code></td><td align="left"><code>false</code></td></tr><tr><td align="left"><code>custom-class</code></td><td align="left">自定义类名</td><td align="left"><code>string</code></td><td align="left">—</td></tr><tr><td align="left"><code>duration</code></td><td align="left">显示时间，单位为毫秒。 设为 0 则不会自动关闭</td><td align="left"><code>number</code></td><td align="left"><code>3000</code></td></tr><tr><td align="left"><code>show-close</code></td><td align="left">是否显示关闭按钮</td><td align="left"><code>boolean</code></td><td align="left"><code>false</code></td></tr><tr><td align="left"><code>center</code></td><td align="left">文字是否居中</td><td align="left"><code>boolean</code></td><td align="left"><code>false</code></td></tr><tr><td align="left"><code>on-close</code></td><td align="left">关闭时的回调函数, 参数为被关闭的 message 实例</td><td align="left"><code>function</code></td><td align="left">—</td></tr><tr><td align="left"><code>offset</code></td><td align="left">Message 距离窗口顶部的偏移量</td><td align="left"><code>number</code></td><td align="left"><code>20</code></td></tr><tr><td align="left"><code>appendTo</code></td><td align="left">设置组件的根元素</td><td align="left">&#96;string</td><td align="left">HTMLElement&#96;</td></tr><tr><td align="left"><code>grouping</code></td><td align="left">合并内容相同的消息，不支持 VNode 类型的消息</td><td align="left"><code>boolean</code></td><td align="left"><code>false</code></td></tr></tbody></table><p>例子</p><pre class="language-typescript" data-language="typescript"><code class="language-typescript"><span class="token function">ElMessage</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>    message<span class="token operator">:</span> data<span class="token punctuation">.</span>error<span class="token punctuation">,</span>    type<span class="token operator">:</span> <span class="token string">'error'</span><span class="token punctuation">,</span>    duration<span class="token operator">:</span> <span class="token number">1.5</span> <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//显示错误信息</span><span class="token keyword">const</span> <span class="token function-variable function">open4</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  ElMessage<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">'Oops, this is a error message.'</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span></code></pre><h2 id="底层"><a href="#底层" class="headerlink" title="底层"></a>底层</h2><h3 id="compiler-sfc"><a href="#compiler-sfc" class="headerlink" title="compiler-sfc"></a>compiler-sfc</h3><p>vue的直属目录下有一个 <code>compiler-sfc</code></p><p><code>compiler-sfc</code>，这个文件夹里面的内容主要是能够编译 <code>template</code>，<code>style</code>, <code>script（setup）</code>的字符串，生成对应的内容。</p><p>分别对应的是 <code>compileTemplate</code>，<code>compileStyle</code>， <code>compileScript</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;持续更新&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;h2 id=&quot;基础内容&quot;&gt;&lt;a href=&quot;#基础内容&quot; class=&quot;heade</summary>
      
    
    
    
    <category term="Frontend" scheme="https://hhumar.com/categories/Frontend/"/>
    
    
    <category term="Web" scheme="https://hhumar.com/tags/Web/"/>
    
    <category term="Vue" scheme="https://hhumar.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript</title>
    <link href="https://hhumar.com/2022/11/04/ts/"/>
    <id>https://hhumar.com/2022/11/04/ts/</id>
    <published>2022-11-03T16:21:24.000Z</published>
    <updated>2022-11-05T18:10:39.689Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>持续更新</p></blockquote><h3 id=""><a href="#" class="headerlink" title=""></a></h3><p><strong>我们需要在类型的严格性和开发的便利性之间掌握平衡</strong></p><p>“reaching the right balance and making the right exceptions is the essence of how successful programming languages are designed.”</p><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>非严格模式下 undefined 和 null 可以赋值给其他类型的值，也就是可以作为其它类型的子类型</p><p>如果定义的时候没有赋值，不管之后有没有赋值，都会被推断成 <code>any</code> 类型而完全不被类型检查</p><p>typeof 能直接获取元素深层类型</p><pre class="language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">const</span> Message <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    name<span class="token operator">:</span> <span class="token string">"jimmy"</span><span class="token punctuation">,</span>    age<span class="token operator">:</span> <span class="token number">18</span><span class="token punctuation">,</span>    address<span class="token operator">:</span> <span class="token punctuation">&#123;</span>      province<span class="token operator">:</span> <span class="token string">'四川'</span><span class="token punctuation">,</span>      city<span class="token operator">:</span> <span class="token string">'成都'</span>       <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">type</span> <span class="token class-name">message</span> <span class="token operator">=</span> <span class="token keyword">typeof</span> Message<span class="token punctuation">;</span><span class="token comment">/* type message = &#123;    name: string;    age: number;    address: &#123;        province: string;        city: string;    &#125;;&#125;*/</span></code></pre><h4 id="never类型"><a href="#never类型" class="headerlink" title="never类型"></a>never类型</h4><p>never 和 void 之间的区别是void 意味着至少要返回一个 undefined 或者 null ，而 never 意味着不会正常执行到 函数的终点。</p><p>! 特殊用法</p><ul><li>强制链式调用</li></ul><pre class="language-none"><code class="language-none">&#x2F;&#x2F; 这里 Error对象定义的stack是可选参数，如果这样写的话编译器会提示&#x2F;&#x2F; 出错 TS2532: Object is possibly &#39;undefined&#39;.new Error().stack.split(&#39;\n&#39;);&#x2F;&#x2F; 我们确信这个字段100%出现，那么就可以添加！，强调这个字段一定存在new Error().stack!.split(&#39;\n&#39;);</code></pre><ul><li>用在赋值的内容后时，使null和undefined类型可以赋值给其他类型并通过编译</li></ul><pre class="language-none"><code class="language-none">&#x2F;&#x2F; 由于x是可选的，因此parma.x的类型为number | undefined，无法传递给number类型的y，因此需要用x!interface IDemo &#123;    x?: number&#125;let y:numberconst demo &#x3D; (parma: IDemo) &#x3D;&gt; &#123;    y &#x3D; parma.x!    return y&#125;</code></pre><p>? 特殊用法</p><ul><li>当使用A对象属性A.B时，如果无法确定A是否为空，则需要用A?.B，表示当A有值的时候才去访问B属性，没有值的时候就不去访问，如果不使用?则会报错</li></ul><pre class="language-none"><code class="language-none">&#x2F;&#x2F; 由于函数参数可选，因此parma无法确定是否拥有，所以无法正常使用parma.x，使用parma?.x向编译器假设此时parma不为空且为IDemo类型，同时parma?.x无法保证非空，因此使用parma?.x!来保证了整体通过编译interface IDemo &#123;    x: number&#125;let y:numberconst demo &#x3D; (parma?: IDemo) &#x3D;&gt; &#123;    y &#x3D; parma?.x!    console.log(parma?.x)   &#x2F;&#x2F; 只是单纯调用属性时就无需!        return y&#125;    &#x2F;&#x2F; 如果使用y &#x3D; parma!.x!是会报错的，因为当parma为空时，是不拥有x属性的，会报找不到x的错误</code></pre><h3 id="支持接口："><a href="#支持接口：" class="headerlink" title="支持接口："></a>支持接口：</h3><p>一个简单的接口，<code>SquareConfig</code>可以有任意数量的属性，并且只要它们不是<code>color</code>和<code>width</code>，那么就无所谓它们的类型是什么。</p><pre class="language-none"><code class="language-none">interface SquareConfig &#123;    color?: string;    width?: number;    [propName: string]: any;&#125;</code></pre><h3 id="定义数组"><a href="#定义数组" class="headerlink" title="定义数组"></a>定义数组</h3><pre class="language-none"><code class="language-none">let arr1: number[] &#x3D; [1,2,3];let arr2: Array&lt;number&gt; &#x3D; [1,2,3];元组，元素数量和各位置元素类型确定，均不可违背let arr3: [string,number,boolean] &#x3D; [1,&#39;1&#39;,true];</code></pre><h3 id="联合类型（Union-Types）"><a href="#联合类型（Union-Types）" class="headerlink" title="联合类型（Union Types）"></a>联合类型（Union Types）</h3><p>表示取值可以为多种类型中的一种。</p><p>当 TypeScript 不确定一个联合类型的变量到底是哪个类型的时候，我们<strong>只能访问此联合类型的所有类型里共有的属性或方法</strong></p><pre class="language-none"><code class="language-none">function getLength(something: string | number): number &#123;    return something.length;&#125;&#x2F;&#x2F; index.ts(2,22): error TS2339: Property &#39;length&#39; does not exist on type &#39;string | number&#39;.&#x2F;&#x2F;   Property &#39;length&#39; does not exist on type &#39;number&#39;.</code></pre><p>联合类型的变量在被赋值的时候，会根据类型推论的规则推断出一个类型，确定类型后也就可以使用其特有的属性和方法了。</p><h3 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h3><p>支持可选参数</p><pre class="language-none"><code class="language-none">function e(arg1:number,arg2?:number)&#123;&#125;</code></pre><p><strong>可选参数后面不允许再出现必需参数</strong></p><p>允许给函数的参数添加默认值，<strong>TypeScript 会将添加了默认值的参数识别为可选参数</strong>，此时上一条限制不再存在</p><pre class="language-none"><code class="language-none">function buildName(firstName: string &#x3D; &#39;Tom&#39;, lastName: string) &#123;    return firstName + &#39; &#39; + lastName;&#125;let tomcat &#x3D; buildName(&#39;Tom&#39;, &#39;Cat&#39;);let cat &#x3D; buildName(undefined, &#39;Cat&#39;);</code></pre><p>关于剩余参数，其实也就相当于多一个数组参数在末尾</p><pre class="language-none"><code class="language-none">function push(array: any[], ...items: any[]) &#123;    items.forEach(function(item) &#123;        array.push(item);    &#125;);&#125;let a &#x3D; [];push(a, 1, 2, 3);</code></pre><p>函数定义还支持重载，当输入参数类型不同时按照程序逻辑进行不同的操作</p><pre class="language-none"><code class="language-none">function reverse(x: number): number;function reverse(x: string): string;function reverse(x: number | string): number | string | void &#123;    if (typeof x &#x3D;&#x3D;&#x3D; &#39;number&#39;) &#123;        return Number(x.toString().split(&#39;&#39;).reverse().join(&#39;&#39;));    &#125; else if (typeof x &#x3D;&#x3D;&#x3D; &#39;string&#39;) &#123;        return x.split(&#39;&#39;).reverse().join(&#39;&#39;);    &#125;&#125;</code></pre><h3 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h3><pre class="language-none"><code class="language-none">两种写法值 as 类型or&lt;类型&gt;值</code></pre><p>当 TypeScript 不确定一个联合类型的变量到底是哪个类型的时候，我们<strong>只能访问此联合类型的所有类型中共有的属性或方法</strong>。但是通过类型断言我们能在还不确定类型的时候就访问其中一个类型特有的属性或方法</p><pre class="language-none"><code class="language-none">interface Cat &#123;    name: string;    run(): void;&#125;interface Fish &#123;    name: string;    swim(): void;&#125;function isFish(animal: Cat | Fish) &#123;    if (typeof (animal as Fish).swim &#x3D;&#x3D;&#x3D; &#39;function&#39;) &#123;        return true;    &#125;    return false;&#125;</code></pre><p>即作用为将一个联合类型断言为其中一个类型，同样还有其它作用：将一个父类断言为更加具体的派生类(此种情况下使用 instanceof 可能会更贴切)，将任何一个类型断言为 any，将 any 断言为一个具体的类型</p><pre class="language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">class</span> <span class="token class-name">ApiError</span> <span class="token keyword">extends</span> <span class="token class-name">Error</span> <span class="token punctuation">&#123;</span>    code<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">HttpError</span> <span class="token keyword">extends</span> <span class="token class-name">Error</span> <span class="token punctuation">&#123;</span>    statusCode<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token operator">=</span> <span class="token number">200</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function">isApiError</span><span class="token punctuation">(</span>error<span class="token operator">:</span> Error<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>error <span class="token keyword">instanceof</span> <span class="token class-name">ApiError</span><span class="token punctuation">)</span> <span class="token comment">//error as ApiError</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>将一个变量断言为 <code>any</code> 可以说是解决 TypeScript 中类型问题的最后一个手段。</p><p><strong>它极有可能掩盖了真正的类型错误，所以如果不是非常确定，就不要使用 <code>as any</code>。</strong></p><pre class="language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">function</span> <span class="token function">getCacheData</span><span class="token punctuation">(</span>key<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">any</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>window <span class="token keyword">as</span> <span class="token builtin">any</span><span class="token punctuation">)</span><span class="token punctuation">.</span>cache<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">interface</span> <span class="token class-name">Cat</span> <span class="token punctuation">&#123;</span>    name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>    <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">const</span> tom <span class="token operator">=</span> <span class="token function">getCacheData</span><span class="token punctuation">(</span><span class="token string">'tom'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> Cat<span class="token punctuation">;</span>tom<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><code>any as</code>上例中调用完 getCacheData 后把返回值限定为 Cat ，明确后续代码中的 tom 类型。</p><p>类型声明比类型断言更加严格，当声明的类型兼容值的类型才使赋值语句成立。而类型断言中等号左边和右边的类型任一兼容对方即可。</p><pre class="language-none"><code class="language-none">interface Animal &#123;    name: string;&#125;interface Cat &#123;    name: string;    run(): void;&#125;const animal: Animal &#x3D; &#123;    name: &#39;tom&#39;&#125;;let tom: Cat &#x3D; animal;&#x2F;&#x2F;改为 let tom &#x3D; animal as Cat; 不会报错&#x2F;&#x2F; index.ts:12:5 - error TS2741: Property &#39;run&#39; is missing in type &#39;Animal&#39; but required in type &#39;Cat&#39;.</code></pre><h3 id="类与接口"><a href="#类与接口" class="headerlink" title="类与接口"></a>类与接口</h3><p><strong>implements</strong><br>实现，一个新的类，从父类或者接口实现所有的属性和方法，同时可以重写属性和方法，包含一些新的功能</p><p><strong>extends</strong><br>继承，一个新的接口或者类，从父类或者接口继承所有的属性和方法，不可以重写属性，但可以重写方法。</p><p>存在 constructor 时需要在其中调用 super 方法(相当于调用父类的constructor)</p><pre class="language-none"><code class="language-none">interface Alarm &#123;    alert(): void;&#125;class Door &#123;&#125;class SecurityDoor extends Door implements Alarm &#123;    alert() &#123;        console.log(&#39;SecurityDoor alert&#39;);    &#125;&#125;class Car implements Alarm &#123;    alert() &#123;        console.log(&#39;Car alert&#39;);    &#125;&#125;</code></pre><p>抽象类：专用于子类实例化和实现其中的抽象方法，本身不可实例化。抽象类还包括抽象属性(不常用)和抽象方法，不会实现内容，留给子类实现。</p><pre class="language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Animal</span><span class="token punctuation">&#123;</span><span class="token keyword">abstract</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">Dog</span> <span class="token keyword">extends</span> <span class="token class-name">Animal</span><span class="token punctuation">&#123;</span>    <span class="token function">add</span><span class="token punctuation">(</span>a<span class="token operator">:</span><span class="token builtin">number</span><span class="token punctuation">,</span>b<span class="token operator">:</span><span class="token builtin">number</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token builtin">number</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> a<span class="token operator">+</span>b<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>指代任意输入的类型，保持在其它地方使用该类型的一致性</p><pre class="language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">function</span> <span class="token generic-function"><span class="token function">swap</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token constant">U</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>tuple<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token constant">U</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token constant">U</span><span class="token punctuation">,</span> <span class="token constant">T</span><span class="token punctuation">]</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token punctuation">[</span>tuple<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> tuple<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">swap</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">,</span> <span class="token string">'seven'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ['seven', 7]</span></code></pre><p>泛型约束可以</p><h2 id="reflection"><a href="#reflection" class="headerlink" title="reflection"></a>reflection</h2><p>proxy 接口</p><pre class="language-text" data-language="text"><code class="language-text">interface ProxyHandler&lt;T extends object> &#123;    getPrototypeOf? (target: T): object | null;    setPrototypeOf? (target: T, v: any): boolean;    isExtensible? (target: T): boolean;    preventExtensions? (target: T): boolean;    getOwnPropertyDescriptor? (target: T, p: PropertyKey): PropertyDescriptor | undefined;    has? (target: T, p: PropertyKey): boolean;    get? (target: T, p: PropertyKey, receiver: any): any;    set? (target: T, p: PropertyKey, value: any, receiver: any): boolean;    deleteProperty? (target: T, p: PropertyKey): boolean;    defineProperty? (target: T, p: PropertyKey, attributes: PropertyDescriptor): boolean;    ownKeys? (target: T): PropertyKey[];    apply? (target: T, thisArg: any, argArray?: any): any;    construct? (target: T, argArray: any, newTarget?: any): object;&#125;interface ProxyConstructor &#123;    revocable&lt;T extends object>(target: T, handler: ProxyHandler&lt;T>): &#123; proxy: T; revoke: () => void; &#125;;    new &lt;T extends object>(target: T, handler: ProxyHandler&lt;T>): T;&#125;declare var Proxy: ProxyConstructor;</code></pre><h2 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h2><h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><p><strong>只属于类自己的，不需要实例化即可引用</strong>，<strong>不能通过new出来的实例访问类的静态变量或方法</strong>，<strong>类中访问自己的静态属性，不能用this，只能用类名。</strong></p><pre class="language-none"><code class="language-none">class Test &#123; static myName: string &#x3D; &quot;lle&quot;;  static changeName(): void &#123;    console.log(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;&gt;&gt;&quot;, &quot;hello&quot;);  &#125;    this.myName &#x3D; &quot;change name&quot;;  -----------&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ❌❌❌ 不可以  Test.myName &#x3D; &quot;change name&quot;; -----------&gt;&gt;&gt;&gt;&gt; ✔️✔️✔️这样就是OK的&#125;Test.changeName();  -------------&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ✔️✔️✔️这样就是OK的let instance &#x3D; new Test();instance.changName();  -----------&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ❌❌❌ 不可以</code></pre><h2 id="Utility-Types"><a href="#Utility-Types" class="headerlink" title="Utility Types"></a>Utility Types</h2><pre class="language-typescript" data-language="typescript"><code class="language-typescript"><span class="token comment">/** * Make all properties in T optional */</span><span class="token keyword">type</span> <span class="token class-name">Partial<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">[</span><span class="token constant">P</span> <span class="token keyword">in</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">]</span><span class="token operator">?</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">P</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">/** * Make all properties in T readonly */</span><span class="token keyword">type</span> <span class="token class-name">Readonly<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">readonly</span> <span class="token punctuation">[</span><span class="token constant">P</span> <span class="token keyword">in</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">P</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">/** * From T, pick a set of properties whose keys are in the union K */</span><span class="token keyword">type</span> <span class="token class-name">Pick<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token constant">K</span> <span class="token keyword">extends</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">[</span><span class="token constant">P</span> <span class="token keyword">in</span> <span class="token constant">K</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">P</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">/** * Construct a type with a set of properties K of type T */</span><span class="token keyword">type</span> <span class="token class-name">Record<span class="token operator">&lt;</span><span class="token constant">K</span> <span class="token keyword">extends</span> <span class="token keyword">keyof</span> <span class="token builtin">any</span><span class="token punctuation">,</span> <span class="token constant">T</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">[</span><span class="token constant">P</span> <span class="token keyword">in</span> <span class="token constant">K</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><h3 id="Partial"><a href="#Partial" class="headerlink" title="Partial"></a>Partial<Type></h3><p>构造一个类型，其中 Type 的所有属性都设置为可选。此实用工具将返回一个表示给定 type 的所有子集的类型。</p><pre class="language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">Coord</span> <span class="token operator">=</span> Partial<span class="token operator">&lt;</span>Record<span class="token operator">&lt;</span><span class="token string">'x'</span> <span class="token operator">|</span> <span class="token string">'y'</span><span class="token punctuation">,</span> <span class="token builtin">number</span><span class="token operator">>></span><span class="token punctuation">;</span><span class="token comment">// 等同于</span><span class="token keyword">type</span> <span class="token class-name">Coord</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>x<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>y<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="Pick"><a href="#Pick" class="headerlink" title="Pick"></a>Pick</h3><pre class="language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">Coord</span> <span class="token operator">=</span> Record<span class="token operator">&lt;</span><span class="token string">'x'</span> <span class="token operator">|</span> <span class="token string">'y'</span><span class="token punctuation">,</span> <span class="token builtin">number</span><span class="token operator">></span><span class="token punctuation">;</span><span class="token keyword">type</span> <span class="token class-name">CoordX</span> <span class="token operator">=</span> Pick<span class="token operator">&lt;</span>Coord<span class="token punctuation">,</span> <span class="token string">'x'</span><span class="token operator">></span><span class="token punctuation">;</span><span class="token comment">// 等用于</span><span class="token keyword">type</span> <span class="token class-name">CoordX</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>x<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="Required"><a href="#Required" class="headerlink" title="Required"></a>Required<Type></h3><p>partial的反义，返回给定 type 的超集</p><h3 id="Readonly"><a href="#Readonly" class="headerlink" title="Readonly"></a>Readonly<Type></h3><p>仅读不可更改类型。<strong>只读的约束存在于第一次给对象赋值的时候，而不是第一次给只读属性赋值的时候</strong></p><pre class="language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">Coord</span> <span class="token operator">=</span> Readonly<span class="token operator">&lt;</span>Record<span class="token operator">&lt;</span><span class="token string">'x'</span> <span class="token operator">|</span> <span class="token string">'y'</span><span class="token punctuation">,</span> <span class="token builtin">number</span><span class="token operator">>></span><span class="token punctuation">;</span><span class="token comment">// 等同于</span><span class="token keyword">type</span> <span class="token class-name">Coord</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">readonly</span> x<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>    <span class="token keyword">readonly</span> y<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 如果进行了修改，则会报错：</span><span class="token keyword">const</span> c<span class="token operator">:</span> Coord <span class="token operator">=</span> <span class="token punctuation">&#123;</span> x<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> y<span class="token operator">:</span> <span class="token number">1</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>c<span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">// Error: Cannot assign to 'x' because it is a read-only property.</span></code></pre><h3 id="Record-lt-Keys-Type-gt"><a href="#Record-lt-Keys-Type-gt" class="headerlink" title="Record&lt;Keys, Type&gt;"></a>Record&lt;Keys, Type&gt;</h3><p>构造一个对象类型，其属性键为 Keys，其属性值为 Type。此实用工具可用于将一种类型的属性映射到另一种类型。</p><pre class="language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">Coord</span> <span class="token operator">=</span> Record<span class="token operator">&lt;</span><span class="token string">'x'</span> <span class="token operator">|</span> <span class="token string">'y'</span><span class="token punctuation">,</span> <span class="token builtin">number</span><span class="token operator">></span><span class="token punctuation">;</span><span class="token comment">// 等同于</span><span class="token keyword">type</span> <span class="token class-name">Coord</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>x<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>y<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h2 id="编译配置"><a href="#编译配置" class="headerlink" title="编译配置"></a>编译配置</h2><p>直接使用以下命令对指定文件进行编译会生成在当前目录下，忽略tsconfig 的配置文件</p><pre class="language-none"><code class="language-none">tsc 指定文件</code></pre><h3 id="tsconfig配置信息"><a href="#tsconfig配置信息" class="headerlink" title="tsconfig配置信息"></a>tsconfig配置信息</h3><p><strong>target –</strong></p><p>就是<a href="https://so.csdn.net/so/search?q=TypeScript&spm=1001.2101.3001.7020">TypeScript</a>文件编译后生成的javascript文件里的语法应该遵循哪个JavaScript的版本。可选项为：<code>&quot;ES5&quot;</code>， <code>&quot;ES6&quot;</code>&#x2F; <code>&quot;ES2015&quot;</code>， <code>&quot;ES2016&quot;</code>， <code>&quot;ES2017&quot;</code>或 <code>&quot;ESNext&quot;</code></p><p><strong>module –</strong></p><p>就是你的TypeScript文件中的module，采用何种方式实现，可选项为：<code>&quot;None&quot;</code>， <code>&quot;CommonJS&quot;</code>， <code>&quot;AMD&quot;</code>， <code>&quot;System&quot;</code>， <code>&quot;UMD&quot;</code>， <code>&quot;ES6&quot;</code>或 <code>&quot;ES2015&quot;。</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;持续更新&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;我们需要在类型的严格性和开发的便利性之间掌握平衡&lt;/stron</summary>
      
    
    
    
    <category term="常用编程语言基础知识" scheme="https://hhumar.com/categories/%E5%B8%B8%E7%94%A8%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="TypeScript" scheme="https://hhumar.com/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>Frontend-Engineering</title>
    <link href="https://hhumar.com/2022/11/03/frontend-engineering/"/>
    <id>https://hhumar.com/2022/11/03/frontend-engineering/</id>
    <published>2022-11-02T17:24:13.000Z</published>
    <updated>2022-11-05T18:10:20.920Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>持续更新</p></blockquote><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h2 id="项目构建"><a href="#项目构建" class="headerlink" title="项目构建"></a>项目构建</h2><h3 id="vue-cli"><a href="#vue-cli" class="headerlink" title="vue cli"></a>vue cli</h3><pre class="language-none"><code class="language-none">npm install -g @vue&#x2F;clinpm install vue@nextvue create project-name</code></pre><h3 id="vite"><a href="#vite" class="headerlink" title="vite"></a>vite</h3><pre class="language-none"><code class="language-none">npm create vite@latest&#x2F;&#x2F;oryarn create vite&#x2F;&#x2F;orpnpm create vite</code></pre><h2 id="包管理"><a href="#包管理" class="headerlink" title="包管理"></a>包管理</h2><p>版本号：x.x.x</p><ul><li><em>主版本号： 当API发生改变，并与之前的版本不兼容的时候</em></li><li><em>次版本号： 当增加了功能，但是向后兼容的时候</em></li><li><em>补丁版本号： 当做了向后兼容的缺陷修复的时候</em></li></ul><h3 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h3><p>Node Package Manager</p><p>dependencies（生产环境）和 devDependencies（开发环境），前者是项目运行时所需要的包，后者是开发时需要的包例如打包项目的 webpack </p><pre class="language-powershell" data-language="powershell"><code class="language-powershell">npm install <span class="token operator">--</span><span class="token function">save-dev</span> packageName<span class="token comment"># 开发环境简写</span>npm i <span class="token operator">-</span>D packageNamenpm install <span class="token operator">--</span>save packageName<span class="token comment"># 生产环境简写，也可以不带S</span>npm i <span class="token operator">-</span>S packageName</code></pre><ul><li><code>devDependencies</code> 里面的依赖只用于开发环境，不用于生产环境。而 <code>dependencies</code> 依赖的包不仅开发环境能使用，生产环境也能使用。</li><li>两种环境的的指定方式是通过配置文件中的<code>NODE_ENV=developement</code>或<code>NODE_ENV=production</code>来指定是开发还是生产环境的。</li><li>使用的一些构建工具例如<code>glup、webpack</code>这些只是在开发中使用的包，上线以后就和他们没关系了，所以将它写入<code>devDependencies</code></li></ul><p>install的tag</p><p>标签可以用来提供一个别名，而不是版本号。</p><p>例如，一个项目可能会选择有多个开发流，并为每个开发流使用不同的标签，例如，stable、beta、dev、canary。</p><p>默认情况下，latest 标签被npm用来识别软件包的当前版本，npm install <pkg>（没有任何@<version>或@<tag>指定符）会安装 latest 标签。通常情况下，项目只对稳定的发布版本使用 latest 标签，而对不稳定的版本（如预发布）使用其他标签。</p><p>下一个标签被一些项目用来标识即将发布的版本。</p><p>除了 latest ，没有任何标签对npm本身有任何特殊意义。</p><p><strong>next标签</strong>：包如果还不够稳定，但是又想给别人测试使用，可以给这种即将上线的包的版本打上next标签。</p><p>install 的 package</p><p>A <code>package</code> is:</p><ul><li>a) a folder containing a program described by a <a href="https://docs.npmjs.com/cli/v8/configuring-npm/package-json"><code>package.json</code></a> file</li><li>b) a gzipped tarball containing (a)</li><li>c) a url that resolves to (b)</li><li>d) a <code>&lt;name&gt;@&lt;version&gt;</code> that is published on the registry (see <a href="https://docs.npmjs.com/cli/v8/using-npm/registry"><code>registry</code></a>) with (c)</li><li>e) a <code>&lt;name&gt;@&lt;tag&gt;</code> (see <a href="https://docs.npmjs.com/cli/v8/commands/npm-dist-tag"><code>npm dist-tag</code></a>) that points to (d)</li><li>f) a <code>&lt;name&gt;</code> that has a “latest” tag satisfying (e)</li><li>g) a <code>&lt;git remote url&gt;</code> that resolves to (a)</li></ul><p>init package信息：</p><ul><li>“name”：全部小写，没有空格，可以使用下划线或者横线</li><li>“version”： x.x.x 的格式，符合 “语义化版本规则”</li><li>description：描述信息，有助于搜索</li><li>main：入口文件，一般都是 <code>index.js</code></li><li>scripts：支持的脚本，默认是一个空的 <code>test</code></li><li>keywords：关键字，有助于在人们使用 <code>npm search</code>搜索时发现你的项目<code>author</code> :作者信息</li><li>license ：默认是 <code>MIT</code></li><li>bugs：当前项目的一些错误信息，如果有的话</li></ul><p>npm run xxx到底干了什么</p><ol><li>运行 npm run xxx的时候，npm 会先在当前目录的 node_modules&#x2F;.bin 查找要执行的程序，如果找到则运行；</li><li>没有找到则从全局的 node_modules&#x2F;.bin 中查找，npm i -g xxx就是安装到到全局目录；</li><li>如果全局目录还是没找到，那么就从 path 环境变量中查找有没有其他同名的可执行程序。</li></ol><h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><ul><li><p>npm shrinkwrap</p><p>repurposes <code>package-lock.json</code> into a publishable <code>npm-shrinkwrap.json</code> or simply creates a new one; is unaware of workspaces.</p><ul><li>when run npm install: <code>npm-shrinkwrap.json</code>&gt;<code>package-lock.json</code>&gt;<code>yarn.lock</code></li></ul></li></ul><h4 id="npx"><a href="#npx" class="headerlink" title="npx"></a>npx</h4><p>一个 CLI 工具，其目的是使安装和管理托管在 npm 注册表中的依赖关系变得容易。</p><p>能够更方便地安装和运行二进制包，并且还能远程运行 **gist(**Github的一个子服务. 最简单的功能就是分享代码片段，例如把一些小型脚本放到Gist方便分享和管理) 和 <strong>github仓库</strong> 。</p><h3 id="yarn"><a href="#yarn" class="headerlink" title="yarn"></a>yarn</h3><ul><li><p>yarn upgrade–interactive</p><p>更新所有包</p></li><li></li></ul><h2 id="前端工程化"><a href="#前端工程化" class="headerlink" title="前端工程化"></a>前端工程化</h2><p>模块化开发，打包引用(分块引用加载速度慢，单块开发难度大，耦合性高)</p><ul><li><p>使用export default命令，为模块指定默认输出，在import导入时可以随意指定值</p><pre class="language-none"><code class="language-none">&#x2F;&#x2F; 文件 test.jslet k; export default k &#x3D; 12; &#x2F;&#x2F; 另一个文件import m from &#39;.&#x2F;test&#39;; &#x2F;&#x2F; 由于 k 是默认导出，所以可以自由使用 import m 替代 import kconsole.log(m);        &#x2F;&#x2F; 输出为 12 </code></pre></li></ul><p>打包(bundle)：常见打包工具webpack，rollup，可以根据模块间依赖关系将多个模块合并为一个文件</p><p>组件化：UI组件是一组视图及其交互行为的封装，组件化是将页面(或应用)，按组件拆分模块开发，通过组件的组合拼装实现页面。</p><p>Babel：JavaScript编译器，把ES 2015转成低版本JS语法</p><p>css预处理器：支持嵌套和格式复用，如Sass、Less、Stylus，在webpack中增加预处理器loader即可。</p><h3 id="TS编译相关"><a href="#TS编译相关" class="headerlink" title="TS编译相关"></a>TS编译相关</h3><p>搭配 Babel 和 tsc –watch 使用，前者做文件编译，后者负责类型检查</p><pre class="language-json" data-language="json"><code class="language-json"><span class="token comment">// package.json</span><span class="token punctuation">&#123;</span>  ...  <span class="token comment">// 指定输出文件 dist，指定扩展名 "ts,tsx"</span>  <span class="token property">"scripts"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token property">"build"</span><span class="token operator">:</span> <span class="token string">"babel src --out-dir dist --extensions \".ts,.tsx\""</span>    ...    <span class="token property">"check-type"</span><span class="token operator">:</span> <span class="token string">"tsc --watch"</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  ...  <span class="token property">"devDependencies"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token property">"@babel/cli"</span><span class="token operator">:</span> <span class="token string">"^7.13.16"</span><span class="token punctuation">,</span>    <span class="token property">"@babel/core"</span><span class="token operator">:</span> <span class="token string">"^7.13.16"</span><span class="token punctuation">,</span>    <span class="token property">"@babel/plugin-proposal-class-properties"</span><span class="token operator">:</span> <span class="token string">"^7.13.0"</span><span class="token punctuation">,</span>  <span class="token comment">// 支持类属性</span>    <span class="token property">"@babel/plugin-proposal-object-rest-spread"</span><span class="token operator">:</span> <span class="token string">"^7.13.8"</span><span class="token punctuation">,</span> <span class="token comment">// 支持剩余扩展操作符</span>    <span class="token property">"@babel/preset-env"</span><span class="token operator">:</span> <span class="token string">"^7.13.15"</span><span class="token punctuation">,</span>    <span class="token property">"@babel/preset-typescript"</span><span class="token operator">:</span> <span class="token string">"^7.13.0"</span> <span class="token comment">// 编译 ts 文件</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// .babellrc</span><span class="token punctuation">&#123;</span>  <span class="token property">"presets"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"@babel/preset-env"</span><span class="token punctuation">,</span> <span class="token string">"@babel/preset-typescript"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token property">"plugins"</span><span class="token operator">:</span> <span class="token punctuation">[</span>    <span class="token string">"@babel/plugin-proposal-class-properties"</span><span class="token punctuation">,</span>    <span class="token string">"@babel/plugin-proposal-object-rest-spread"</span>  <span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span class="token comment">// tsconfig.json</span><span class="token punctuation">&#123;</span>  ...  <span class="token property">"compilerOptions"</span><span class="token operator">:</span><span class="token punctuation">&#123;</span>    <span class="token property">"noEmit"</span><span class="token operator">:</span><span class="token boolean">true</span> <span class="token comment">// 不输出文件，只做类型检查</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>同时另开终端运行 npm run check-type 即可</p><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><p>测试金字塔：从低到高是单元测试-&gt;服务测试-&gt;系统测试，越往上测试数量应该越少</p><p>测试框架：AVA、TAPE、Jasmine、Jest</p><p>测试框架衡量指标：Node端和Browser的支持，并发的支持，库的集成度，社区的活跃度。Jest最常用</p><p>三种编写测试用例形式：<code>xxx.test.js</code>, <code>xxx.spec.js</code>, 或者写到<code>__test__</code>文件夹下，正常<code>.js</code>后缀。</p><pre class="language-none"><code class="language-none">const delay&#x3D;require(&#39;..&#x2F;index&#39;);describe(&#39;add 方法测试-__test__&#39;, ()&#x3D;&gt;&#123;    test(&#39;1+1应该等于2&#39;, ()&#x3D;&gt;&#123;        const res&#x3D;add(1,1);        expect(res).toBe(2);    &#125;)&#125;)</code></pre><p>describe：将几个相关的测试放到一个组中，非必须</p><p>test：别名it，测试用例，是测试的最小单位</p><p>expect：提供大量matcher来判断方法返回值是否符合特定条件</p><p>异步测试避免没有执行到预期代码，在test的执行方法首行加上断言数<code>expect.assertions(num);</code>，主要是针对异步代码的测试。</p><p>并且为了避免过早结束在test末尾添加done()方法，并把test的执行方法调入参数done，表示执行到done()方法后才结束。</p><p>针对返回类型为 promise 直接 return 最后调用测试的结果即可。如下：</p><pre class="language-none"><code class="language-none">const delay&#x3D;require(&#39;..&#x2F;index&#39;);test(&#39;calllback execute&#39;,done&#x3D;&gt;&#123;    expect.assertions(1);    const callback&#x3D;()&#x3D;&gt;&#123;        console.log(&#39;callback exec&#39;);        expect(true).toBe(true);        done();    &#125;;    delay(callback);&#125;);test(&#39;calllback execute&#39;,()&#x3D;&gt;&#123;    expect.assertions(1);    const callback&#x3D;()&#x3D;&gt;1;    return delayPromise(callback).then(res &#x3D;&gt; &#123;        expect(res).toBe(1);    &#125;);&#125;);</code></pre><p>测试覆盖率：在 <code>package.json</code>文件中把<code>scripts</code>行进行修改</p><pre class="language-none"><code class="language-none">&quot;scripts&quot;: &#123;  &quot;test&quot;: &quot;jest --coverage&quot;&#x2F;&#x2F;&#125;,</code></pre><p>jest方法：</p><ul><li><p>const func &#x3D; jest.<strong>fn</strong>().<strong>mockReturnValue</strong>(1)，生成一个返回值为1的函数。</p></li><li><p>存在库依赖 jest.spyOn 监视库函数</p><pre class="language-none"><code class="language-none">let mockRandom&#x3D;null;beforeEach(()&#x3D;&gt;&#123;    mockRandom&#x3D;jest.spyOn(Math, &#39;random&#39;);&#125;)afterEach(()&#x3D;&gt;&#123;    mockRandom.mockRestore();&#125;)&#x2F;&#x2F;设置库函数返回值&#x2F;&#x2F;mockRandom.mockReturnValue(value);</code></pre></li><li><p>jest.<strong>mock</strong>(‘’)</p></li></ul><h3 id="代码规范"><a href="#代码规范" class="headerlink" title="代码规范"></a>代码规范</h3><p>Eslint 和 Prettier</p><h2 id="打包之webpack"><a href="#打包之webpack" class="headerlink" title="打包之webpack"></a>打包之webpack</h2><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p>webpack 默认支持处理 JS 与 JSON 文件，其他类型都处理不了，必须借助 Loader 来对不同类型的文件的进行处理。</p><h3 id="配置模块"><a href="#配置模块" class="headerlink" title="配置模块"></a>配置模块</h3><p>Entry：入口，指示 Webpack 应该使用哪个模块，来作为构建其内部 依赖图(dependency graph) 的开始。</p><p>Output：输出结果，告诉 Webpack 在哪里输出它所创建的 bundle，以及如何命名这些文件。</p><h4 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h4><p>模块，在 Webpack 里一切皆模块，一个模块对应着一个文件。Webpack 会从配置的 Entry 开始递归找出所有依赖的模块。</p><p>Chunk：代码块，一个 Chunk 由多个模块组合而成，用于代码合并与分割。</p><p>Loader：模块代码转换器，让webpack能够去处理除了JS、JSON之外的其他类型的文件，并将它们转换为有效 模块，以供应用程序使用，以及被添加到依赖图中。</p><p>Plugin：扩展插件。在webpack运行的生命周期中会广播出许多事件，plugin可以监听这些事件，在合适的时机通过webpack提供的api改变输出结果。常见的有：打包优化，资源管理，注入环境变量。</p><h4 id="Mode"><a href="#Mode" class="headerlink" title="Mode"></a>Mode</h4><p>模式，告知 webpack 使用相应模式的内置优化，默认为 production</p><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td>development</td><td>开发模式，打包更加快速，省了代码优化步骤</td></tr><tr><td>production</td><td>生产模式，打包比较慢，会开启 tree-shaking 和 压缩代码</td></tr><tr><td>none</td><td>不使用任何默认优化选项</td></tr></tbody></table><p>Browser Compatibility：浏览器兼容性，Webpack 支持所有符合 ES5 标准 的浏览器（IE8以上版本）</p><h3 id="打包流程"><a href="#打包流程" class="headerlink" title="打包流程"></a>打包流程</h3><p>1、读取<code>webpack</code>的配置参数；</p><p>2、启动<code>webpack</code>，创建<code>Compiler</code>对象并开始解析项目；</p><p>3、从入口文件（<code>entry</code>）开始解析，并且找到其导入的依赖模块，递归遍历分析，形成依赖关系树；</p><p>4、对不同文件类型的依赖模块文件使用对应的<code>Loader</code>进行编译，最终转为<code>Javascript</code>文件；</p><p>5、整个过程中<code>webpack</code>会通过发布订阅模式，向外抛出一些<code>hooks</code>，而<code>webpack</code>的插件即可通过监听这些关键的事件节点，执行插件任务进而达到干预输出结果的目的。</p><h2 id="NodeJS"><a href="#NodeJS" class="headerlink" title="NodeJS"></a>NodeJS</h2><h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><ul><li><strong>__dirname</strong>: 返回当前模块文件解析过后所在的文件夹(目录)的绝对路径。</li><li><strong>__filename</strong>: 返回当前模块文件被解析过后的绝对路径。</li></ul><h2 id="设计架构，框架"><a href="#设计架构，框架" class="headerlink" title="设计架构，框架"></a>设计架构，框架</h2><p>设计系统：设计价值观&#x3D;&gt;设计原则&#x3D;&gt;设计风格规范、组件化Design Token，实现样式代理、资源代理、结构化设计</p><p>框架的作用是为前端UI开发提供另外一种方式，提供良好的代码风格，易于添加测试，组件化开发，服务端和客户端路由</p><p>无极设计规范：原子设计方法论，拆解和组合</p><p>组件化中遇到的问题：组件化不彻底，无基础组件，复用程度低，单位不统一，语法版本规范弱</p><p>MVC，包括视图、控制器、模型</p><h3 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h3><p>开发者只需要关心数据结构和视图，抽象层包括视图，视图模型和模型。</p><p>实际应用包括Vue、React、San、小程序</p><p>真正的区别在于，发布订阅模式实现的是一种多对多的关系，在发布者与订阅者之间需要有一个中介者，发布者发布事件名和参数到中间者，中间者向事件集中的订阅者发送参数。<br>而观察者是一种一对多的关系，所有的在同一被观察者身上绑定的观察者只能接受同一个被观察者的消息。</p><p>本质上，观察者模式和发布订阅模式都是对回调函数的松（解）耦合。回调函数是：事件A结束后，执行事件B。观察者模式实现的是：定义好事件A，事件B，通过“观察”这一行为，将事件A和B的因果先后关系关联起来。发布订阅模式实现的是：事件A结束后，发布到事件中心；事件B订阅A，连同后续回调托管到事件中心。事件中心将A和B关联起来。这一过程中，事件A和事件B完全不会受到对方是否存在的影响，是完全解耦合的。</p><h3 id="MTV"><a href="#MTV" class="headerlink" title="MTV"></a>MTV</h3><p>model templates view</p><p>比如 django </p><h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><h3 id="前端-x2F-后端路由"><a href="#前端-x2F-后端路由" class="headerlink" title="前端&#x2F;后端路由"></a>前端&#x2F;后端路由</h3><p>router和route，router 可以理解为一个容器，或者说一种机制，它管理了一组 route。简单来说，route 只是进行了URL和函数的映射，而在当接收到一个URL之后，去路由映射表中查找相应的函数，这个过程由 router 来处理。</p><p>服务器端路由和客户端路由：</p><ul><li>对于服务器来说，当接收到客户端发来的HTTP请求，会根据请求的URL，来找到相应的映射函数，然后执行该函数，并将函数的返回值发送给客户端。在 router 匹配 route 的过程中，不仅会根据URL来匹配，还会根据请求的方法来看是否匹配。如果通过 POST 方法来GET &#x2F;users的内容，就会找不到正确的路由。</li><li>对于客户端（通常为浏览器）来说，路由的映射函数通常是进行一些DOM的显示和隐藏操作。这样，当访问不同的路径的时候，会显示不同的页面组件。有基于Hash和History API两种</li></ul><p>上述路由和渲染概念相近。</p><p>前端路由——顾名思义，页面跳转的URL规则匹配由前端来控制。而前端路由主要是有两种显示方式：</p><ul><li>带有hash的前端路由，优点是兼容性高。缺点是URL带有<code>#</code>号不好看</li><li>不带hash的前端路由，优点是URL不带<code>#</code>号，好看。缺点是既需要浏览器支持也需要后端服务器支持</li></ul><h3 id="hash-x2F-history路由模式"><a href="#hash-x2F-history路由模式" class="headerlink" title="hash&#x2F;history路由模式"></a>hash&#x2F;history路由模式</h3><p>当在url栏中输入新网址，浏览器会直接向服务器请求网址对应的信息。而在已存在网页中点击链接路由时，会进行判断是否需要向服务器请求信息。</p><p><strong>hash</strong>：带 # 的url，浏览器向服务器请求 # 后的地址信息，仅向服务器请求url中 # 之前的地址，再由浏览器获取到的前端脚本处理#后的地址信息</p><p><strong>history</strong>：不带 # ，正常 &#x2F; 分隔，在已加载页面点击链接进行跳转时不会出现问题，当后端服务器不存在某个路由信息而直接在网址栏输入对其访问会404.</p><h2 id="前后端通信-Axios"><a href="#前后端通信-Axios" class="headerlink" title="前后端通信-Axios"></a>前后端通信-Axios</h2><p>基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。</p><p>一个通信框架，用于服务器交互；当然也可以使用jQuery提供的AJAX通信功能</p><ul><li>ajax最早出现的发送后端请求技术，利用用XMLHttpRequest对象。</li><li>$.ajax是jQuery中的发送后端请求技术，基于原生Ajax的封装。</li><li>Axios不是原生JS的，需要进行安装。它在client-side和server-side都可以使用。也可以在请求和响应阶段进行拦截。它是基于promise对象的。</li><li>Fetch号称是AJAX的替代品，使用了ES6中的promise对象。其参数有点像jQuery.ajax。但是fetch不是对ajax的封装，而是原生js实现的，并没有使用XMLHttpRequest对象。</li></ul><p>axios 中所谓的绝对路径，就是以 <code>&lt;scheme&gt;://</code>（协议头）或者 <code>//</code> 开头的URL，除此之外都算先对路径，都会在头部附加 baseURL</p><h3 id="结构信息"><a href="#结构信息" class="headerlink" title="结构信息"></a>结构信息</h3><p>request信息</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token punctuation">&#123;</span>   <span class="token comment">// `url` 是用于请求的服务器 URL</span>  <span class="token literal-property property">url</span><span class="token operator">:</span> <span class="token string">'/user'</span><span class="token punctuation">,</span>  <span class="token comment">// `method` 是创建请求时使用的方法</span>  <span class="token literal-property property">method</span><span class="token operator">:</span> <span class="token string">'get'</span><span class="token punctuation">,</span> <span class="token comment">// default</span>  <span class="token comment">// `baseURL` 将自动加在 `url` 前面，除非 `url` 是一个绝对 URL。</span>  <span class="token comment">// 它可以通过设置一个 `baseURL` 便于为 axios 实例的方法传递相对 URL</span>  <span class="token literal-property property">baseURL</span><span class="token operator">:</span> <span class="token string">'https://some-domain.com/api/'</span><span class="token punctuation">,</span>  <span class="token comment">// `transformRequest` 允许在向服务器发送前，修改请求数据</span>  <span class="token comment">// 只能用在 'PUT', 'POST' 和 'PATCH' 这几个请求方法</span>  <span class="token comment">// 后面数组中的函数必须返回一个字符串，或 ArrayBuffer，或 Stream</span>  <span class="token literal-property property">transformRequest</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">data<span class="token punctuation">,</span> headers</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 对 data 进行任意转换处理</span>    <span class="token keyword">return</span> data<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token comment">// `transformResponse` 在传递给 then/catch 前，允许修改响应数据</span>  <span class="token literal-property property">transformResponse</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 对 data 进行任意转换处理</span>    <span class="token keyword">return</span> data<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token comment">// `headers` 是即将被发送的自定义请求头</span>  <span class="token literal-property property">headers</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span><span class="token string-property property">'X-Requested-With'</span><span class="token operator">:</span> <span class="token string">'XMLHttpRequest'</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token comment">// `params` 是即将与请求一起发送的 URL 参数</span>  <span class="token comment">// 必须是一个无格式对象(plain object)或 URLSearchParams 对象</span>  <span class="token literal-property property">params</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token constant">ID</span><span class="token operator">:</span> <span class="token number">12345</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>   <span class="token comment">// `paramsSerializer` 是一个负责 `params` 序列化的函数</span>  <span class="token comment">// (e.g. https://www.npmjs.com/package/qs, http://api.jquery.com/jquery.param/)</span>  <span class="token function-variable function">paramsSerializer</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">params</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> Qs<span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>params<span class="token punctuation">,</span> <span class="token punctuation">&#123;</span><span class="token literal-property property">arrayFormat</span><span class="token operator">:</span> <span class="token string">'brackets'</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token comment">// `data` 是作为请求主体被发送的数据</span>  <span class="token comment">// 只适用于这些请求方法 'PUT', 'POST', 和 'PATCH'</span>  <span class="token comment">// 在没有设置 `transformRequest` 时，必须是以下类型之一：</span>  <span class="token comment">// - string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams</span>  <span class="token comment">// - 浏览器专属：FormData, File, Blob</span>  <span class="token comment">// - Node 专属： Stream</span>  <span class="token literal-property property">data</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token literal-property property">firstName</span><span class="token operator">:</span> <span class="token string">'Fred'</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token comment">// `timeout` 指定请求超时的毫秒数(0 表示无超时时间)</span>  <span class="token comment">// 如果请求话费了超过 `timeout` 的时间，请求将被中断</span>  <span class="token literal-property property">timeout</span><span class="token operator">:</span> <span class="token number">1000</span><span class="token punctuation">,</span>   <span class="token comment">// `withCredentials` 表示跨域请求时是否需要使用凭证</span>  <span class="token literal-property property">withCredentials</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token comment">// default</span>  <span class="token comment">// `adapter` 允许自定义处理请求，以使测试更轻松</span>  <span class="token comment">// 返回一个 promise 并应用一个有效的响应 (查阅 [response docs](#response-api)).</span>  <span class="token function-variable function">adapter</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">config</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">/* ... */</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token comment">// `auth` 表示应该使用 HTTP 基础验证，并提供凭据</span>  <span class="token comment">// 这将设置一个 `Authorization` 头，覆写掉现有的任意使用 `headers` 设置的自定义 `Authorization`头</span>  <span class="token literal-property property">auth</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token literal-property property">username</span><span class="token operator">:</span> <span class="token string">'janedoe'</span><span class="token punctuation">,</span>    <span class="token literal-property property">password</span><span class="token operator">:</span> <span class="token string">'s00pers3cret'</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>   <span class="token comment">// `responseType` 表示服务器响应的数据类型，可以是 'arraybuffer', 'blob', 'document', 'json', 'text', 'stream'</span>  <span class="token literal-property property">responseType</span><span class="token operator">:</span> <span class="token string">'json'</span><span class="token punctuation">,</span> <span class="token comment">// default</span>  <span class="token comment">// `responseEncoding` indicates encoding to use for decoding responses</span>  <span class="token comment">// Note: Ignored for `responseType` of 'stream' or client-side requests</span>  <span class="token literal-property property">responseEncoding</span><span class="token operator">:</span> <span class="token string">'utf8'</span><span class="token punctuation">,</span> <span class="token comment">// default</span>   <span class="token comment">// `xsrfCookieName` 是用作 xsrf token 的值的cookie的名称</span>  <span class="token literal-property property">xsrfCookieName</span><span class="token operator">:</span> <span class="token string">'XSRF-TOKEN'</span><span class="token punctuation">,</span> <span class="token comment">// default</span>  <span class="token comment">// `xsrfHeaderName` is the name of the http header that carries the xsrf token value</span>  <span class="token literal-property property">xsrfHeaderName</span><span class="token operator">:</span> <span class="token string">'X-XSRF-TOKEN'</span><span class="token punctuation">,</span> <span class="token comment">// default</span>   <span class="token comment">// `onUploadProgress` 允许为上传处理进度事件</span>  <span class="token function-variable function">onUploadProgress</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">progressEvent</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// Do whatever you want with the native progress event</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token comment">// `onDownloadProgress` 允许为下载处理进度事件</span>  <span class="token function-variable function">onDownloadProgress</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">progressEvent</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 对原生进度事件的处理</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>   <span class="token comment">// `maxContentLength` 定义允许的响应内容的最大尺寸</span>  <span class="token literal-property property">maxContentLength</span><span class="token operator">:</span> <span class="token number">2000</span><span class="token punctuation">,</span>  <span class="token comment">// `validateStatus` 定义对于给定的HTTP 响应状态码是 resolve 或 reject  promise 。如果 `validateStatus` 返回 `true` (或者设置为 `null` 或 `undefined`)，promise 将被 resolve; 否则，promise 将被 rejecte</span>  <span class="token function-variable function">validateStatus</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">status</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> status <span class="token operator">>=</span> <span class="token number">200</span> <span class="token operator">&amp;&amp;</span> status <span class="token operator">&lt;</span> <span class="token number">300</span><span class="token punctuation">;</span> <span class="token comment">// default</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token comment">// `maxRedirects` 定义在 node.js 中 follow 的最大重定向数目</span>  <span class="token comment">// 如果设置为0，将不会 follow 任何重定向</span>  <span class="token literal-property property">maxRedirects</span><span class="token operator">:</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token comment">// default</span>  <span class="token comment">// `socketPath` defines a UNIX Socket to be used in node.js.</span>  <span class="token comment">// e.g. '/var/run/docker.sock' to send requests to the docker daemon.</span>  <span class="token comment">// Only either `socketPath` or `proxy` can be specified.</span>  <span class="token comment">// If both are specified, `socketPath` is used.</span>  <span class="token literal-property property">socketPath</span><span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token comment">// default</span>  <span class="token comment">// `httpAgent` 和 `httpsAgent` 分别在 node.js 中用于定义在执行 http 和 https 时使用的自定义代理。允许像这样配置选项：</span>  <span class="token comment">// `keepAlive` 默认没有启用</span>  <span class="token literal-property property">httpAgent</span><span class="token operator">:</span> <span class="token keyword">new</span> <span class="token class-name">http<span class="token punctuation">.</span>Agent</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span> <span class="token literal-property property">keepAlive</span><span class="token operator">:</span> <span class="token boolean">true</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token literal-property property">httpsAgent</span><span class="token operator">:</span> <span class="token keyword">new</span> <span class="token class-name">https<span class="token punctuation">.</span>Agent</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span> <span class="token literal-property property">keepAlive</span><span class="token operator">:</span> <span class="token boolean">true</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token comment">// 'proxy' 定义代理服务器的主机名称和端口</span>  <span class="token comment">// `auth` 表示 HTTP 基础验证应当用于连接代理，并提供凭据</span>  <span class="token comment">// 这将会设置一个 `Proxy-Authorization` 头，覆写掉已有的通过使用 `header` 设置的自定义 `Proxy-Authorization` 头。</span>  <span class="token literal-property property">proxy</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token literal-property property">host</span><span class="token operator">:</span> <span class="token string">'127.0.0.1'</span><span class="token punctuation">,</span>    <span class="token literal-property property">port</span><span class="token operator">:</span> <span class="token number">9000</span><span class="token punctuation">,</span>    <span class="token literal-property property">auth</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>      <span class="token literal-property property">username</span><span class="token operator">:</span> <span class="token string">'mikeymike'</span><span class="token punctuation">,</span>      <span class="token literal-property property">password</span><span class="token operator">:</span> <span class="token string">'rapunz3l'</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token comment">// `cancelToken` 指定用于取消请求的 cancel token</span>  <span class="token comment">// （查看后面的 Cancellation 这节了解更多）</span>  <span class="token literal-property property">cancelToken</span><span class="token operator">:</span> <span class="token keyword">new</span> <span class="token class-name">CancelToken</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">cancel</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span></code></pre><p>response信息</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token punctuation">&#123;</span>  <span class="token comment">// `data` 由服务器提供的响应</span>  <span class="token literal-property property">data</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token comment">// `status` 来自服务器响应的 HTTP 状态码</span>  <span class="token literal-property property">status</span><span class="token operator">:</span> <span class="token number">200</span><span class="token punctuation">,</span>  <span class="token comment">// `statusText` 来自服务器响应的 HTTP 状态信息</span>  <span class="token literal-property property">statusText</span><span class="token operator">:</span> <span class="token string">'OK'</span><span class="token punctuation">,</span>  <span class="token comment">// `headers` 服务器响应的头</span>  <span class="token literal-property property">headers</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>   <span class="token comment">// `config` 是为请求提供的配置信息</span>  <span class="token literal-property property">config</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token comment">// 'request'</span>  <span class="token comment">// `request` is the request that generated this response</span>  <span class="token comment">// It is the last ClientRequest instance in node.js (in redirects)</span>  <span class="token comment">// and an XMLHttpRequest instance the browser</span>  <span class="token literal-property property">request</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><ul><li><p>changeOrigin：Boolean</p><p>为false时通过前端访问，devServer转发请求时，http request的host头值不会改变，为true时会把host值改为target指定的host</p></li></ul><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>要求：</p><ol><li>正常请求该有的（跨域携带cookie，token，超时设置）</li><li>请求响应拦截器<ul><li>请求成功，业务状态码200，解析result给我，我不想一层一层的去判断拿数据</li><li>http请求200， 业务状态码非200，说明逻辑判断这是不成功的，那就全局message提示服务端的报错</li><li>http请求非200， 说明http请求都有问题，也全局message提示报错</li><li>http请求或者业务状态码401都做注销操作</li></ul></li><li>全局的loading配置，默认开启，可配置关闭（由于后端的问题，经常会让前端加防抖节流或者loading不让用户在界面上疯狂乱点，行吧行吧，你们的问题前端帮你们解决，你的规矩就是规矩是吧🍜）</li><li>统一文件下载处理 （不要再去各写各的下载了，你写一个，他写一个，一个项目就是这样整的跟屎一样）</li></ol><h2 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h2><p>动态网页的生成是基于动态web server的。一个动态网络服务器首先是一台计算机，这个计算机上包含了产生这个网页所需的HTML模板，样式表，其它托管文件和负责调动这些文件的静态HTTP服务器软件，应用服务器软件和数据库软件(通常情况)。后两者会对HTTP服务器打算传送的托管文件进行更新。</p><p>Nginx优点：负载均衡、反向代理、处理静态文件优势。nginx处理静态请求的速度高于apache；</p><p>Apache优点：相对于Tomcat服务器来说处理静态文件是它的优势，速度快。Apache是静态解析，适合静态HTML、图片等。</p><p>Tomcat：动态解析容器，处理动态请求，是编译JSP\Servlet的容器，Nginx有动态分离机制，静态请求直接就可以通过Nginx处理，动态请求才转发请求到后台交由Tomcat进行处理。 </p><p>　　Apache在处理动态有优势，Nginx并发性比较好，CPU内存占用低，如果rewrite频繁，那还是Apache较适合。</p><p>localStorage生命周期是永久，除非主动清除localStorage信息，否则这些信息将永远存在。存放数据大小为一般为5MB,而且它仅在客户端（即浏览器）中保存，不参与和服务器的通信。</p><p>sessionStorage仅在当前会话下有效，关闭页面或浏览器后被清除。存放数据大小为一般为5MB,而且它仅在客户端（即浏览器）中保存，不参与和服务器的通信。</p><p>cookie机制：如果不在浏览器中设置过期事件，cookie被保存在内存中，生命周期随浏览器的关闭而结束，这种cookie简称为会话cookie。如果在浏览器中设置了cookie的过期事件，cookie会被保存在硬盘中，关闭浏览器后，cookie数据仍然存在，直到过期事件结束才消失。cookie是服务端发给客户端的特殊信息，cookie是以文本的方式保存在客户端，每次请求时都带上它</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;持续更新&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;h2 id=&quot;项目构建&quot;&gt;&lt;a href=&quot;#项目构建&quot; class=&quot;heade</summary>
      
    
    
    
    <category term="Frontend" scheme="https://hhumar.com/categories/Frontend/"/>
    
    
    <category term="Web" scheme="https://hhumar.com/tags/Web/"/>
    
    <category term="Engineering" scheme="https://hhumar.com/tags/Engineering/"/>
    
  </entry>
  
  <entry>
    <title>前端基础</title>
    <link href="https://hhumar.com/2022/11/02/Frontend/"/>
    <id>https://hhumar.com/2022/11/02/Frontend/</id>
    <published>2022-11-01T16:40:14.000Z</published>
    <updated>2022-11-05T18:10:24.372Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>持续更新</p></blockquote><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h2 id="web基础知识"><a href="#web基础知识" class="headerlink" title="web基础知识"></a>web基础知识</h2><h3 id="url到页面"><a href="#url到页面" class="headerlink" title="url到页面"></a>url到页面</h3><p>浏览器中的进程</p><table><thead><tr><th>进程</th><th>说明</th></tr></thead><tbody><tr><td>浏览器进程</td><td>负责浏览器各个子进程的通信，处理浏览器界面，包括地址栏等</td></tr><tr><td>渲染进程</td><td>也就是我们看到的图中的标签页进程，也就是我们常说的浏览器内核，v8就在这个进程。主要负责解析html、js、css渲染页面等</td></tr><tr><td>网络进程</td><td>负责发起网络请求，解析返回头信息</td></tr><tr><td>GUI进程</td><td>负责将渲染进程生成的图块转化成位图</td></tr><tr><td>插件进程</td><td></td></tr></tbody></table><p>从输入页面URL到页面渲染完成大致流程为：</p><ul><li><p>地址栏输入信息处理</p><p>判断输入信息是检索信息还是请求URL</p><ul><li>如果是检索的信息，就构建请求搜索的URL，调用浏览器默认的搜索引擎进行检索。</li><li>如果符合URL格式，浏览器主进程就通过IPC通信机制将URL发送给网络进程。<a href="https://www.jianshu.com/p/c1015f5ffa74">进程间通信IPC (InterProcess Communication)</a></li></ul></li><li><p>网络进程发起网络请求</p><ul><li>解析URL，解码</li><li>查找浏览器本地缓存</li><li>无缓存则DNS解析</li><li>建立TCP&#x2F;IP连接</li><li>发送HTTP请求</li><li>服务器处理请求并返回HTTP报文</li></ul></li><li><p>服务器返回对应资源</p><ul><li>浏览器接收到服务器返回的资源信息，网络进程首先会解析返回的头信息，查看是否有Location字段，如果有的话，再次发起请求，常见例子：请求http的站点，然后重定向到https。</li><li>通过返回头字段<code>Content-Type</code>判断文件类型，如果其他类型，就调用不同的进程处理，如果是html类型，继续处理。</li><li>浏览器根据深度遍历的方式把html节点遍历构建DOM树</li><li>遇到CSS外链，异步加载解析CSS，构建CSS规则树</li><li><strong>遇到script标签，如果是普通JS标签则同步加载并执行，阻塞页面渲染，如果标签上有defer &#x2F; async属性则异步加载JS资源</strong></li><li>将dom树和CSS DOM树构造成render树</li><li>渲染render树</li></ul></li><li><p>四次挥手，资源传输完毕，断开连接</p></li></ul><p><img src="/2022/11/02/Frontend/%E6%B8%B2%E6%9F%93%E8%BF%9B%E7%A8%8B.png" alt="渲染进程"></p><h3 id="MIME类型"><a href="#MIME类型" class="headerlink" title="MIME类型"></a>MIME类型</h3><table><thead><tr><th><code>text</code></th><th>表明文件是普通文本，理论上是人类可读</th><th><code>text/plain</code>, <code>text/html</code>, <code>text/css, text/javascript</code></th></tr></thead><tbody><tr><td><code>image</code></td><td>表明是某种图像。不包括视频，但是动态图（比如动态 gif）也使用 image 类型</td><td><code>image/gif</code>, <code>image/png</code>, <code>image/jpeg</code>, <code>image/bmp</code>, <code>image/webp</code>, <code>image/x-icon</code>, <code>image/vnd.microsoft.icon</code></td></tr><tr><td><code>audio</code></td><td>表明是某种音频文件</td><td><code>audio/midi</code>, <code>audio/mpeg, audio/webm, audio/ogg, audio/wav</code></td></tr><tr><td><code>video</code></td><td>表明是某种视频文件</td><td><code>video/webm</code>, <code>video/ogg</code></td></tr><tr><td><code>application</code></td><td>表明是某种二进制数据</td><td><code>application/octet-stream</code>, <code>application/pkcs12</code>, <code>application/vnd.mspowerpoint</code>, <code>application/xhtml+xml</code>, <code>application/xml</code>, <code>application/pdf</code></td></tr></tbody></table><p>由类型与子类型两个字符串中间用<code>&#39;/&#39;</code>分隔而组成。不允许空格存在。不敏感大小写。</p><p>对于 text 文件类型若没有特定的 subtype，就使用 <code>text/plain</code>。类似的，二进制文件没有特定或已知的 subtype，即使用 <code>application/octet-stream</code>。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/MIME_types#applicationoctet-stream">application&#x2F;octet-stream</a>这是应用程序文件的默认值。意思是 <em>未知的应用程序文件 ，</em>浏览器一般不会自动执行或询问执行。</p><p>text&#x2F;plain文本文件默认值。即使它<em>意味着未知的文本文件</em>，但浏览器认为是可以直接展示的。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/MIME_types#textjavascript">text&#x2F;javascript </a> text&#x2F;html text&#x2F;css</p><p><code>multipart/byteranges</code> 用于把部分的响应报文发送回浏览器</p><h3 id="session和cookie、token"><a href="#session和cookie、token" class="headerlink" title="session和cookie、token"></a>session和cookie、token</h3><p>Session（会话机制，能识别哪个请求由哪个用户发起的机制，生成的能识别用户身份信息的字符串称为 sessionId）是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中；</p><p><strong>客户端请求后，由<a href="https://www.zhihu.com/search?q=%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%99%A8&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2064471064%7D">负载均衡器</a>（如 Nginx）来决定到底打到哪台机器</strong></p><p>对应三种解决方案：</p><ul><li>session复制：所有服务器都有，都一样，性能消耗大，冗余大</li><li>session粘连：不同的session（根据ID）放在不同机器上，可靠性低</li><li>session共享：将 session 保存在 redis，<a href="https://www.zhihu.com/search?q=memcached&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2064471064%7D">memcached</a> 等中间件中，请求到来时，各个机器去这些中间件取一下 session ，多了一次内部连接，消耗了一点性能</li></ul><p>Cookie是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现Session的一种方式。每当客户端要与服务端通信时，附送 cookie 可以让服务端识别用户身份，找到对应用户之前保留在服务端的信息。一般由第一次客户端访问服务端时，服务端生成并发送给客户端。</p><p>token：请求方输入自己的用户名，密码，然后 server 据此生成 token，客户端拿到 token 后会保存到本地，之后向 server 请求时在请求头带上此 token 即可。</p><ul><li>server 会有一套校验机制，校验这个 token 是否合法。</li><li>token 本身可以带 uid 信息，解密后就可以获取</li></ul><p>jwt token 主要由三部分组成 ——base64编码</p><ol><li>header：指定了签名算法 </li><li>payload：可以指定用户 id，过期时间等非敏感数据 </li><li>Signature: 签名，server 根据 header 知道它该用哪种签名算法，再用密钥根据此签名算法对 head + payload 生成签名，这样一个 token 就生成了。</li></ol><p>Token 一般是放在 header 的 Authorization 自定义头里，不是放在 Cookie 里的，这主要是为了解决跨域不能共享 Cookie 的问题 ——单点登录SSO，向其中一个网站发送请求，获得token，可以用该token发送给其它信任组网站，方便快捷。</p><p>缺点：太长了，不太安全，<strong>适合一次性的命令认证，设置一个比较短的有效期</strong></p><p>CSRF 攻击的根本原因在于对于同样域名的每个请求来说，它的 cookie 都会被自动带上，这个是浏览器的机制决定的，所以很多人据此认定 cookie 不安全。<em>CSRF</em>（<em>Cross-site request forgery</em>）跨站请求伪造</p><p>cookie和token都保存在local storage，会被js读取，前者是存储方式，后者是验证方式</p><h3 id="浏览器缓存"><a href="#浏览器缓存" class="headerlink" title="浏览器缓存"></a>浏览器缓存</h3><p>在浏览器中，浏览器会在js和图片等文件解析执行后直接存入内存缓存中，那么当刷新页面时只需直接从内存缓存中读取；而css文件则会存入硬盘文件中，所以每次渲染页面都需要从硬盘读取缓存。</p><p><img src="/2022/11/02/Frontend/web%E7%BC%93%E5%AD%98%E7%B1%BB%E5%9E%8B.png" alt="web缓存类型"></p><p>所谓浏览器缓存其实就是指在本地使用的计算机中开辟一个内存区，同时也开辟一个硬盘区作为数据传输的缓冲区，然后用这个缓冲区来暂时保存用户以前访问过的信息。</p><h4 id="Web-Storage"><a href="#Web-Storage" class="headerlink" title="Web Storage"></a>Web Storage</h4><ul><li><code>sessionStorage</code> 为每一个给定的源（given origin）维持一个独立的存储区域，该存储区域在页面会话期间可用（即只要浏览器处于打开状态，包括页面重新加载和恢复）。</li><li><code>localStorage</code> 同样的功能，但是在浏览器关闭，然后重新打开后数据仍然存在。</li></ul><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//以下均可设置localStorage</span>localStorage<span class="token punctuation">.</span>colorSetting <span class="token operator">=</span> <span class="token string">'#a4509b'</span><span class="token punctuation">;</span>localStorage<span class="token punctuation">[</span><span class="token string">'colorSetting'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'#a4509b'</span><span class="token punctuation">;</span>localStorage<span class="token punctuation">.</span><span class="token function">setItem</span><span class="token punctuation">(</span><span class="token string">'colorSetting'</span><span class="token punctuation">,</span> <span class="token string">'#a4509b'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>storage常用方法</p><pre class="language-none"><code class="language-none">Storage.key()该方法接受一个数值 n 作为参数，并返回存储中的第 n 个键名。Storage.getItem()该方法接受一个键名作为参数，返回键名对应的值。Storage.setItem()该方法接受一个键名和值作为参数，将会把键值对添加到存储中，如果键名存在，则更新其对应的值。Storage.removeItem()该方法接受一个键名作为参数，并把该键名从存储中删除。Storage.clear()调用该方法会清空存储中的所有键名。</code></pre><p>浏览器缓存细节：</p><ul><li>浏览器每次发起请求，都会<code>先在浏览器缓存中查找该请求的结果以及缓存标识</code></li><li>浏览器每次拿到返回的请求结果都会<code>将该结果和缓存标识存入浏览器缓存中</code></li></ul><p>强制缓存和协商缓存情况：</p><ul><li>浏览器请求在缓存中找不到缓存结果和缓存标识，则向服务器请求文件，服务器返回文件同时带上缓存标识，客户端把文件缓存到浏览器缓存中，此时是强制缓存范畴。</li><li>浏览器请求在缓存中能找到缓存结果和标识但已经过期，于是携带缓存标识向服务器请求，服务器决定客户端的浏览器缓存是否仍然可用有两种情况：<ul><li>仍可用，返回304，客户端再到浏览器缓存请求读取，返回。</li><li>不可用，返回200和请求结果，客户端再更新浏览器缓存。</li></ul></li><li>能找到浏览器缓存结果和标识且未过期，直接使用。-强制缓存</li></ul><h4 id="强制缓存中的HTTP响应报文字段："><a href="#强制缓存中的HTTP响应报文字段：" class="headerlink" title="强制缓存中的HTTP响应报文字段："></a>强制缓存中的HTTP响应报文字段：</h4><p>expires 和 cache-control，作用相似，后者优先级高</p><ul><li><h5 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h5><p>Expires是HTTP&#x2F;1.0控制网页缓存的字段，其值为服务器返回该请求结果<code>缓存的到期时间</code>，即再次发起该请求时，如果客户端的时间小于Expires的值时，直接使用缓存结果。</p></li><li><h5 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h5><p>在HTTP&#x2F;1.1中，Cache-Control是最重要的规则，主要用于控制网页缓存，主要取值为：</p><ul><li>public：所有内容都将被缓存（客户端和代理服务器都可缓存）</li><li>private：所有内容只有客户端可以缓存，Cache-Control的默认取值</li><li>no-cache：客户端缓存内容，但是是否使用缓存则需要经过协商缓存来验证决定</li><li>no-store：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存</li><li>max-age&#x3D;xxx (xxx is numeric)：缓存内容将在xxx秒后失效</li></ul></li></ul><h4 id="协商缓存的两对字段："><a href="#协商缓存的两对字段：" class="headerlink" title="协商缓存的两对字段："></a>协商缓存的两对字段：</h4><p>Last-Modified &#x2F; If-Modified-Since和 Etag &#x2F; If-None-Match，两对中的每一对的两个字段分别为响应header字段和请求header字段，后面这一对优先级高</p><ul><li><p>Last-Modified &#x2F; If-Modified-Since</p><p>Last-Modified 是服务器响应报文中记录返回资源最后在服务器中修改时间是的值， If-Modified-Since 是客户端在浏览器缓存中找到的已过期缓存的 Last-Modified 值，携带向服务器请求资源，服务器检查 If-Modified-Since 记录的值是否和自身对应资源的 Last-Modified 相同，如果相同返回304未更改，不相同则返回200和新资源及Last-Modified。</p></li><li><p>Etag &#x2F; If-None-Match</p><p>Etag 是服务器响应报文返回资源的唯一标识，If-None-Match 是客户端请求向服务器时携带的对应资源在浏览器缓存中记录的 Etag，该资源在浏览器缓存中已过期。服务器收到后比对 If-None-Match 和服务器资源 Etag 是否相同，相同则返回304资源未修改，否则返回200和新资源及对应新 Etag。</p></li></ul><h4 id="刷新对于强缓存和协商缓存的影响"><a href="#刷新对于强缓存和协商缓存的影响" class="headerlink" title="刷新对于强缓存和协商缓存的影响"></a>刷新对于强缓存和协商缓存的影响</h4><ol><li>当ctrl+f5强制刷新网页时，直接从服务器加载，跳过强缓存和协商缓存。</li><li>当f5刷新网页时，跳过强缓存，但是会检查协商缓存。</li><li>浏览器地址栏中写入URL，回车 浏览器发现缓存中有这个文件了，不用继续请求了，直接去缓存拿。（最快）</li></ol><h3 id="Location"><a href="#Location" class="headerlink" title="Location"></a>Location</h3><p>http中的头部字段</p><p><strong><code>Location</code></strong> 首部指定的是需要将页面重新定向至的地址。一般在响应码为 3xx 的响应中才会有意义。</p><p>发送新请求，获取 Location 指向的新页面所采用的方法与初始请求使用的方法以及重定向的类型相关：</p><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/303"><code>303</code></a> (See Also) 始终引致请求使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/GET"><code>GET</code></a> 方法，而，而 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/307"><code>307</code></a> (Temporary Redirect) 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/308"><code>308</code></a> (Permanent Redirect) 则不转变初始请求中的所使用的方法；</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/301"><code>301</code></a> (Permanent Redirect) 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/302"><code>302</code></a> (Found) 在大多数情况下不会转变初始请求中的方法，不过一些比较早的用户代理可能会引发方法的变更（所以你基本上不知道这一点）。</li></ul><p>状态码为上述之一的所有响应都会带有一个 Location 首部。</p><p>除了重定向响应之外，状态码为 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/201"><code>201</code></a> (Created) 的消息也会带有 Location 首部。它指向的是新创建的资源的地址。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Location"><code>Location</code></a> 与 <code>Content-Location</code>是不同的，前者（<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Location"><code>Location</code></a> ）指定的是一个重定向请求的目的地址（或者新创建的文件的 URL），而后者（ <code>Content-Location</code>）指向的是经过内容协商后的资源的直接地址，不需要进行进一步的内容协商。Location 对应的是响应，而 Content-Location 对应的是要返回的实体。</p><h3 id="网络安全"><a href="#网络安全" class="headerlink" title="网络安全"></a>网络安全</h3><h4 id="跨域攻击"><a href="#跨域攻击" class="headerlink" title="跨域攻击"></a>跨域攻击</h4><p><strong>Cross-site request forgery</strong>, also known as <strong>one-click attack</strong> or <strong>session riding</strong> and abbreviated as <strong>CSRF</strong> (sometimes pronounced <em>sea-surf</em>[<a href="https://en.wikipedia.org/wiki/Cross-site_request_forgery#cite_note-Shiflett-1">1]</a>) or <strong>XSRF</strong>, is a type of malicious <a href="https://en.wikipedia.org/wiki/Exploit_(computer_security)">exploit</a> of a <a href="https://en.wikipedia.org/wiki/Website">website</a> where unauthorized commands are submitted from a <a href="https://en.wikipedia.org/wiki/User_(computing)">user</a> that the web application trusts.</p><p><strong>CSRF</strong>&#x2F;<strong>XSRF</strong></p><p>同源策略：同域名、同协议、同端口</p><h4 id="内容安全策略"><a href="#内容安全策略" class="headerlink" title="内容安全策略"></a>内容安全策略</h4><p>content-security-policy</p><p>配置内容安全策略涉及到添加 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Security-Policy"><code>Content-Security-Policy</code></a> HTTP 头部到一个页面，并配置相应的值，以控制用户代理（浏览器等）可以为该页面获取哪些资源。</p><p>一个策略由一系列策略指令所组成，每个策略指令都描述了一个针对某个特定类型资源以及生效范围的策略。你的策略应当包含一个<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Security-Policy/default-src"><code>default-src</code></a>策略指令，在其他资源类型没有符合自己的策略时应用该策略 (有关完整列表查看<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Security-Policy/default-src"><code>default-src</code></a> )。一个策略可以包含 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Security-Policy/default-src"><code>default-src</code></a> 或者 <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/script-src">script-src (en-US)</a> 指令来防止内联脚本运行，并杜绝<code>eval()</code>的使用。 一个策略也可包含一个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Security-Policy/default-src"><code>default-src</code></a> 或 <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/style-src">style-src </a> 指令去限制来自一个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/style"><code>style</code></a> 元素或者 style 属性的內联样式。</p><p>例如：</p><p>一个网站管理者想要所有内容均来自站点的同一个源 (不包括其子域名)</p><pre class="language-none"><code class="language-none">Content-Security-Policy: default-src &#39;self&#39;</code></pre><p>一个网站管理者允许内容来自信任的域名及其子域名 (域名不必须与 CSP 设置所在的域名相同)</p><pre class="language-none"><code class="language-none">Content-Security-Policy: default-src &#39;self&#39; *.trusted.com</code></pre><p>一个网站管理者允许网页应用的用户在他们自己的内容中包含来自任何源的图片，但是限制音频或视频需从信任的资源提供者 (获得)，所有脚本必须从特定主机服务器获取可信的代码。</p><pre class="language-none"><code class="language-none">Content-Security-Policy: default-src &#39;self&#39;; img-src *; media-src media1.com media2.com; script-src userscripts.example.com</code></pre><p>在这里，各种内容默认仅允许从文档所在的源获取，但存在如下例外：</p><ul><li>图片可以从任何地方加载 (注意 “*” 通配符)。</li><li>多媒体文件仅允许从 media1.com 和 media2.com 加载 (不允许从这些站点的子域名)。</li><li>可运行脚本仅允许来自于 userscripts.example.com。</li></ul><p>一个线上银行网站的管理者想要确保网站的所有内容都要通过 SSL 方式获取，以避免攻击者窃听用户发出的请求。</p><pre class="language-none"><code class="language-none">Content-Security-Policy: default-src https:&#x2F;&#x2F;onlinebanking.jumbobank.com</code></pre><p>该服务器仅允许通过 HTTPS 方式并仅从<code>onlinebanking.jumbobank.com</code>域名来访问文档。</p><p>类似的有Content-Security-Policy-Report-Only头部信息，做测试用途，不会阻止访问但会发送违规信息到 report-uri 指令内容的地址。这意味着两种头部启用报告功能需要在指令中加上 report-uri ，但不加 Report-Only 不仅会发送报告也能同时阻止访问。</p><p>可以有效防止XSS(cross-site scripting)攻击和数据注入攻击。</p><h4 id="OWASP"><a href="#OWASP" class="headerlink" title="OWASP"></a>OWASP</h4><p>是Open Web Application Security Project的缩写，它是一个在线社区，在网络应用安全领域发表文章、方法、文档、工具和技术。</p><p>The Top 10 OWASP vulnerabilities in 2021 are:</p><ul><li>Injection</li><li>Broken authentication</li><li>Sensitive data exposure</li><li>XML external entities (XXE)</li><li>Broken access control</li><li>Security misconfigurations</li><li>Cross site scripting (XSS)</li><li>Insecure deserialization</li><li>Using components with known vulnerabilities</li><li>Insufficient logging and monitoring</li></ul><p><a href="https://sucuri.net/guides/owasp-top-10-security-vulnerabilities-2020/">https://sucuri.net/guides/owasp-top-10-security-vulnerabilities-2020/</a></p><h2 id="http相关"><a href="#http相关" class="headerlink" title="http相关"></a>http相关</h2><h3 id="cookie操作"><a href="#cookie操作" class="headerlink" title="cookie操作"></a>cookie操作</h3><p>服务器使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Set-Cookie"><code>Set-Cookie</code></a> 响应头部向用户代理（一般是浏览器）发送 Cookie 信息。一个简单的 Cookie 可能像这样：</p><pre class="language-none"><code class="language-none">Set-Cookie: &lt;cookie 名&gt;&#x3D;&lt;cookie 值&gt;</code></pre><p>服务器响应信息，该头部告知客户端保存 Cookie 信息。</p><pre class="language-none"><code class="language-none">HTTP&#x2F;1.0 200 OKContent-type: text&#x2F;htmlSet-Cookie: yummy_cookie&#x3D;chocoSet-Cookie: tasty_cookie&#x3D;strawberry[页面内容]</code></pre><p>现在，对该服务器发起的每一次新请求，浏览器都会将之前保存的 Cookie 信息通过 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cookie"><code>Cookie</code></a> 请求头部再发送给服务器。</p><pre class="language-none"><code class="language-none">GET &#x2F;sample_page.html HTTP&#x2F;1.1Host: www.example.orgCookie: yummy_cookie&#x3D;choco; tasty_cookie&#x3D;strawberry</code></pre><h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><p>Cookie 的生命周期可以通过两种方式定义：</p><ul><li>会话期 Cookie 是最简单的 Cookie：浏览器关闭之后它会被自动删除，也就是说它仅在会话期内有效。会话期 Cookie 不需要指定过期时间（<code>Expires</code>）或者有效期（<code>Max-Age</code>）。需要注意的是，有些浏览器提供了会话恢复功能，这种情况下即使关闭了浏览器，会话期 Cookie 也会被保留下来，就好像浏览器从来没有关闭一样，这会导致 Cookie 的生命周期无限期延长。</li><li>持久性 Cookie 的生命周期取决于过期时间（<code>Expires</code>）或有效期（<code>Max-Age</code>）指定的一段时间。</li></ul><pre class="language-none"><code class="language-none">Set-Cookie: id&#x3D;a3fWa; Expires&#x3D;Wed, 21 Oct 2015 07:28:00 GMT;</code></pre><p>还有限制访问、作用域等，详见<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Cookies">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Cookies</a></p><h2 id="html"><a href="#html" class="headerlink" title="html"></a><code>html</code></h2><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><p><code>&amp;lt &lt;  &amp;gt &gt;    &amp;nbsp/&amp;emsp 空格  &amp;copy 版权   &amp;trade-&amp;reg 商标</code></p><p>清浮动 <code>clear:left/right/both</code> <code>overflow</code>:产生块级作用域</p><pre class="language-none"><code class="language-none">&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;catphotourl&quot; placeholder&#x3D;&quot;cat photo URL&quot; required&gt;长下面这样；type限制输入类型，name作为变量名称方便本地调用，placeholder给用户输入暗示，required规定必须有输入元素才能提交表单</code></pre><p><img src="/2022/11/02/Frontend/input%E6%A0%87%E7%AD%BE.png" alt="input标签"></p><p>input标签种类繁多，功能强大，详见<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/Input">https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/Input</a></p><p>type属性对应值及其作用：<a href="https://blog.csdn.net/VickyTsai/article/details/94839889">https://blog.csdn.net/VickyTsai/article/details/94839889</a></p><table><thead><tr><th>属性值</th><th>用于</th></tr></thead><tbody><tr><td>① text</td><td>定义 <strong>单行的 输入文本</strong> 字段，用户可在其中输入文本。默认宽度为 20 个字符。单行文本字段。换行符 将自动 从输入值中删除。</td></tr><tr><td>② checkbox</td><td>定义 <strong>复选框</strong>。 允许 选择&#x2F;取消选择 单个值 的复选框。</td></tr><tr><td>③ password</td><td>定义 <strong>密码</strong> 字段。该字段中的字符 被掩码。值被隐藏的 单行文本字段。使用<code>maxlength</code>和<code>minlength</code>属性指定 可输入值的最大长度。</td></tr><tr><td>④ hidden</td><td><strong>隐藏的 输入值</strong>: 定义 隐藏的 输入字段。不显示 但其值 提交给服务器的控件。</td></tr><tr><td>⑤ file</td><td><strong>选择文件</strong>. 定义输入字段和 “浏览”按钮，供 文件上传。允许用户 选择文件的控件。使用<code>accept</code>属性 定义控件 可以选择的 文件类型。</td></tr><tr><td>⑥ button</td><td><strong>无 默认行为的按钮</strong>: 定义 可点击<strong>按钮</strong>（多数情况下，用于通过 JavaScript 启动脚本）。一个没有默认行为的按钮。</td></tr><tr><td>⑦ radio</td><td>定义 <strong>单选 按钮</strong>。一个单选按钮，允许 从多个选项中 选择一个值。</td></tr><tr><td>⑧ reset</td><td>定义 <strong>重置按钮</strong>。重置按钮会 清除表单中的 所有数据。将表单内容重 置为默认值的按钮。</td></tr><tr><td>⑨ submit</td><td>定义 <strong>提交按钮</strong>。提交按钮 会把表单 数据发送到 服务器。提交表单的 按钮。</td></tr><tr><td>⑩ image</td><td><strong>图片提交按钮</strong>: 定义 图像形式的 提交按钮。 一个图形化的 提交按钮。必须使用<code>src</code>属性 定义图像的源，使用<code>alt</code>属性定义 替代文本。可以使用<code>height</code>高度和<code>width</code>宽度属性 以像素为单位 定义图像的大小。</td></tr></tbody></table><p>html5还有新增</p><p>value 属性为 input 元素设定值。</p><p>对于不同的输入类型，value 属性的用法也不同：</p><ul><li>type&#x3D;”button”, “reset”, “submit” - 定义按钮上的显示的文本</li><li>type&#x3D;”text”, “password”, “hidden” - 定义输入字段的初始值</li><li>type&#x3D;”checkbox”, “radio”, “image” - 定义与输入相关联的值</li></ul><p><strong>注释：</strong><code>&lt;input type=&quot;checkbox&quot;&gt;</code> 和<code> &lt;input type=&quot;radio&quot;&gt;</code> 中必须设置 value 属性。</p><p><strong>注释：</strong>value 属性无法与<code> &lt;input type=&quot;file&quot;&gt;</code> 一同使用。</p><p>select和option搭配使用</p><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>label</span> <span class="token attr-name">for</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>pet-select<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Choose a pet:<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>label</span><span class="token punctuation">></span></span>//注意 multiple 和 disable 的用法<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>pets<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>pet-select<span class="token punctuation">"</span></span> <span class="token attr-name">multiple</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>option</span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token punctuation">"</span></span> <span class="token attr-name">disabled</span><span class="token punctuation">></span></span>--Please choose an option--<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>option</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>option</span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>dog<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Dog<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>option</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>option</span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>cat<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Cat<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>option</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>option</span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>hamster<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Hamster<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>option</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>option</span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>parrot<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Parrot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>option</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>option</span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>spider<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Spider<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>option</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>option</span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>goldfish<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Goldfish<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>option</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span></code></pre><p>form标签的action属性是一个表单当中必须的属性，action属性规定当提交表单时，向何处发送表单数据。</p><p>label标签可以把input包裹起来，让点击文本和点击按钮都让按钮被点击生效。</p><ul><li>属性for可以将label绑定到for对应value为ID的标签，但是仅表示关联且需和绑定标签相邻，没有什么特殊效果。</li></ul><pre class="language-markup" data-language="markup"><code class="language-markup">For the styling of the page to look similar on mobile as it does on a desktop or laptop, you need to add a meta element with a special content attribute.<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>width=device-width, initial-scale=1.0<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span></code></pre><p>link标签的<code>rel</code>属性：此属性命名链接文档与当前文档的关系。type属性：这个属性被用于定义链接的内容的类型。这个属性的值应该是像 text&#x2F;html，text&#x2F;css 等 MIME 类型。这个属性常用的用法是定义链接的样式表，最常用的值是表明了 CSS 的 text&#x2F;css。</p><p>块级元素block：可以设定宽高，换行排列行内元素inline：只能由内容撑开，同一行排列行内块级元素inline-block：可以摆在同一行且能设定宽高</p><p>calc计算中不同表达式元素必须间隔空格，以区分变量名称和运算符。并且支持混合单位运算。vh单位是视窗大小的百分比。</p><p>布局视口和视觉视口。视口基本上是当前文档的可见部分，</p><p>box-sizing属性可分配值：content box(default)，border box；当指定宽度或高度时分别指内容高宽和内容+内边距+边界高宽</p><h2 id="css"><a href="#css" class="headerlink" title="css"></a>css</h2><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p>块级元素之间的外边距会发生折叠。这意味着，如果一个具有上边距的元素排在在一个具有下边距的元素之下时，他们之间的间距不会是这两个外边距的和，即外边距会发生折叠，简单来说就是，间距与两个外边距中的较大者一样大。</p><p>外边距叠加：相邻元素间距会按照两者各自外边距大的算</p><p>内联盒子的宽度和高度被忽略了。外边距、内边距和边框是生效的，但它们不会改变其他内容与内联盒子的关系，因此内边距和边框会与段落中的其他单词重叠。</p><p>inline-block却能在设置宽高、内外边距的同时推开其它内联盒子</p><p>盒子四边缩写是从顶边顺时针</p><h3 id="常用长度单位"><a href="#常用长度单位" class="headerlink" title="常用长度单位"></a>常用长度单位</h3><p>相对长度单位</p><table><thead><tr><th align="left">单位</th><th align="left">相对于</th></tr></thead><tbody><tr><td align="left"><code>em</code></td><td align="left">在 font-size 中使用是相对于父元素的字体大小，在其他属性中使用是相对于自身的字体大小，如 width</td></tr><tr><td align="left"><code>ex</code></td><td align="left">字符“x”的高度</td></tr><tr><td align="left"><code>ch</code></td><td align="left">数字“0”的宽度</td></tr><tr><td align="left"><code>rem</code></td><td align="left">根元素的字体大小，html文档中默认字体大小为 16px</td></tr><tr><td align="left"><code>lh</code></td><td align="left">元素的 line-height</td></tr><tr><td align="left"><code>vw</code></td><td align="left">视窗<strong>宽度</strong>的 1%</td></tr><tr><td align="left"><code>vh</code></td><td align="left">视窗<strong>高度</strong>的 1%</td></tr><tr><td align="left"><code>vmin</code></td><td align="left">视窗较小尺寸的 1%</td></tr><tr><td align="left"><code>vmax</code></td><td align="left">视图大尺寸的 1%</td></tr></tbody></table><h3 id="常用属性"><a href="#常用属性" class="headerlink" title="常用属性"></a>常用属性</h3><h4 id="box-shadow"><a href="#box-shadow" class="headerlink" title="box-shadow"></a>box-shadow</h4><p>用于在元素的框架上添加阴影效果，两个长度值为x、y轴偏移量，三个时第三个为blur-radius，第四个为spread-radius</p><ul><li>可选，<code>inset</code>关键字。</li><li>可选，<code>&lt;color&gt;</code>值。</li><li>若要对同一个元素添加多个阴影效果，请使用逗号将每个阴影规则分隔开。</li></ul><pre class="language-css" data-language="css"><code class="language-css"><span class="token comment">/* x 偏移量 | y 偏移量 | 阴影颜色 */</span><span class="token property">box-shadow</span><span class="token punctuation">:</span> 60px -16px teal<span class="token punctuation">;</span><span class="token comment">/* x 偏移量 | y 偏移量 | 阴影模糊半径 | 阴影颜色 */</span><span class="token property">box-shadow</span><span class="token punctuation">:</span> 10px 5px 5px black<span class="token punctuation">;</span><span class="token comment">/* x 偏移量 | y 偏移量 | 阴影模糊半径 | 阴影扩散半径 | 阴影颜色 */</span><span class="token property">box-shadow</span><span class="token punctuation">:</span> 2px 2px 2px 1px <span class="token function">rgba</span><span class="token punctuation">(</span>0<span class="token punctuation">,</span> 0<span class="token punctuation">,</span> 0<span class="token punctuation">,</span> 0.2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/* 插页 (阴影向内) | x 偏移量 | y 偏移量 | 阴影颜色 */</span><span class="token property">box-shadow</span><span class="token punctuation">:</span> inset 5em 1em gold<span class="token punctuation">;</span><span class="token comment">/* 任意数量的阴影，以逗号分隔 */</span><span class="token property">box-shadow</span><span class="token punctuation">:</span> 3px 3px red<span class="token punctuation">,</span> -1em 0 0.4em olive<span class="token punctuation">;</span><span class="token comment">/* 全局关键字 */</span><span class="token property">box-shadow</span><span class="token punctuation">:</span> inherit<span class="token punctuation">;</span><span class="token property">box-shadow</span><span class="token punctuation">:</span> initial<span class="token punctuation">;</span><span class="token property">box-shadow</span><span class="token punctuation">:</span> unset<span class="token punctuation">;</span></code></pre><p>元素设置了border-radius时，转变为圆角阴影</p><h3 id="盒模型、正常流"><a href="#盒模型、正常流" class="headerlink" title="盒模型、正常流"></a>盒模型、正常流</h3><p>盒子模型：外边距（<a href="https://so.csdn.net/so/search?q=margin&spm=1001.2101.3001.7020">margin</a>）+ border（边框） + 内边距（padding）+ content（内容）</p><pre class="language-none"><code class="language-none">标准盒子模型，一般浏览器也都默认为标准盒子模型。即：box-sizing:content-box怪异盒子模型，一般根据实际项目需要自行设置。即：box-sizing:border-boxpadding和border的值就不会影响元素的宽高，相当于把padding和border的值都算在content里</code></pre><h3 id="浏览器前缀"><a href="#浏览器前缀" class="headerlink" title="浏览器前缀"></a>浏览器前缀</h3><ul><li><code>-webkit-</code> （谷歌，Safari，新版 Opera 浏览器，以及几乎所有 iOS 系统中的浏览器（包括 iOS 系统中的火狐浏览器）；基本上所有基于 WebKit 内核的浏览器）</li><li><code>-moz-</code> （火狐浏览器）</li><li><code>-o-</code> （旧版 Opera 浏览器）</li><li><code>-ms-</code> （IE 浏览器 和 Edge 浏览器）</li></ul><h3 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h3><h4 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h4><p>最近的祖先样式比其他祖先样式优先级高。</p><p>“直接样式”比”祖先样式”优先级高。</p><p>内联样式 &gt; ID 选择器# &gt; 类选择器.class &#x3D; 属性选择器 &#x3D; 伪类选择器 &gt; 标签选择器element &#x3D; 伪元素选择器</p><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p><strong>伪类</strong> 是添加到选择器的关键字，指定要选择的元素的特殊状态。例如，<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:hover"><code>:hover</code></a> 可被用于在用户将鼠标悬停在按钮上时改变按钮的颜色。</p><p><strong>伪元素</strong>以类似方式表现，不过表现得是像你往标记文本中加入全新的 HTML 元素一样，而不是向现有的元素上应用类。例如<code>::first-line</code></p><h4 id="参考节"><a href="#参考节" class="headerlink" title="参考节"></a><a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/Building_blocks/Selectors/Pseudo-classes_and_pseudo-elements#%E5%8F%82%E8%80%83%E8%8A%82">参考节</a></h4><h3 id="flex布局"><a href="#flex布局" class="headerlink" title="flex布局"></a>flex布局</h3><p>flexbox弹性布局，一维布局模型display:flex</p><p>容器属性</p><p>flex-direction：四种摆放方向，垂直和水平的正反</p><ul><li><code>row</code></li><li><code>row-reverse</code></li><li><code>column</code></li><li><code>column-reverse</code></li></ul><p>flex-wrap：指定 flex 元素单行显示还是多行显示。如果允许换行，这个属性允许你控制行的堆叠方向。</p><ul><li><p>nowrap</p><p>flex 的元素被摆放到到一行，这可能导致 flex 容器溢出。<strong>cross-start</strong> 会根据 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/flex-direction"><code>flex-direction</code></a> 的值等价于 <strong>start</strong> 或 <strong>before</strong>。为该属性的默认值。</p></li><li><p>wrap</p><p>flex 元素 被打断到多个行中。<strong>cross-start</strong> 会根据 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/flex-direction"><code>flex-direction</code></a> 的值等价于 <strong>start</strong> 或<strong>before</strong>。<strong>cross-end</strong> 为确定的 <strong>cross-start</strong> 的另一端。</p></li><li><p>wrap-reverse</p><p>和 wrap 的行为一样，但是 <strong>cross-start</strong> 和 <strong>cross-end</strong> 互换。</p></li></ul><p>flex-flow：前两个属性的结合</p><p>justify-content：主轴对齐方式</p><p>align-items：交叉轴对齐方式</p><p>align-content：定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。</p><p>​五种对齐方式：这里的左右是相对于轴方向而言</p><ul><li><code>flex-start</code>（默认值）：左对齐</li><li><code>flex-end</code>：右对齐</li><li><code>center</code>： 居中</li><li><code>space-between</code>：两端对齐，项目之间的间隔都相等。</li><li><code>space-around</code>：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。</li></ul><p>内部元素属性</p><p>order：<code>order</code>属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。</p><p>flex-grow：对容器内剩余空间的处理，为容器内的每个元素进行分配，分配的值依此属性值而定。定义项目的放大比例，默认为<code>0</code>，即如果存在剩余空间，也不放大。</p><p>flex-shrink：对溢出空间的处理，对容器内每个元素的压缩的值依此属性的值而定。属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。</p><p>flex-basis：定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为<code>auto</code>，即项目的本来大小。</p><p>flex：flex属性是<code>flex-grow</code>, <code>flex-shrink</code> 和 <code>flex-basis</code>的简写，默认值为<code>0 1 auto</code>。后两个属性可选。</p><p>align-self：<code>align-self</code>属性允许单个项目有与其他项目不一样的对齐方式，可覆盖<code>align-items</code>属性。默认值为<code>auto</code>，表示继承父元素的<code>align-items</code>属性，如果没有父元素，则等同于<code>stretch</code>。</p><h3 id="grid布局"><a href="#grid布局" class="headerlink" title="grid布局"></a>grid布局</h3><p>二维布局。container 和 item</p><h4 id="container属性："><a href="#container属性：" class="headerlink" title="container属性："></a>container属性：</h4><ul><li>display：我们通过在元素上声明 <code>display：grid</code> 或 <code>display：inline-grid</code> 来创建一个网格容器。声明 <code>display：grid</code> 则该容器是一个块级元素，设置成 <code>display: inline-grid</code> 则容器元素为行内元素</li><li></li></ul><h4 id="item属性："><a href="#item属性：" class="headerlink" title="item属性："></a>item属性：</h4><h3 id="定位position"><a href="#定位position" class="headerlink" title="定位position"></a>定位position</h3><ul><li>static静态定位，默认属性</li><li>relative相对定位，相对于为static父标签的偏移，同时需要指定偏移方向和位移</li><li>absolute绝对定位，相对于不为static父标签的偏移</li><li>fixed固定定位，相对于浏览器窗口的偏移，不随父标签的属性改变而改变</li><li>sticky粘性定位，未滚动到预定位置就是relative，到预定位置就是fixed，实现比如固定在页面顶部的导航栏</li></ul><p>页面的普通流，static 和 relative 都不会更改元素的正常文档流，block 元素还是width 为100%，inline 元素还是宽高无效</p><pre class="language-css" data-language="css"><code class="language-css"><span class="token comment">/*relative示例*/</span><span class="token selector">span</span> <span class="token punctuation">&#123;</span>     <span class="token property">background</span><span class="token punctuation">:</span> #b6ff00<span class="token punctuation">;</span>     <span class="token property">position</span><span class="token punctuation">:</span> relative<span class="token punctuation">;</span>     <span class="token property">top</span><span class="token punctuation">:</span> 10px<span class="token punctuation">;</span>     <span class="token property">left</span><span class="token punctuation">:</span> 10px<span class="token punctuation">;</span>     <span class="token property">width</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></code></pre><h3 id="浮动float"><a href="#浮动float" class="headerlink" title="浮动float"></a>浮动float</h3><p>float 属性定义元素在哪个方向浮动，常用属性值有 left、right，即向左浮动和向右浮动。设置了 float 的元素，会脱离文档流，然后向左或向右移动，直到碰到父容器的边界或者碰到另一个浮动元素。块级元素会忽略 float 元素，文本和行内元素却会环绕</p><p>会影响自身及后面的元素，不推荐使用有相对应的clear属性，清除浮动，也能影响自身及后面的元素</p><ul><li>left</li><li>right</li></ul><h3 id="规则"><a href="#规则" class="headerlink" title="@规则"></a>@规则</h3><p>一个 <strong>at-rule</strong> 是一个<a href="https://developer.mozilla.org/en/CSS/Syntax#CSS_statements">CSS 语句，</a>以 at 符号开头， ‘<code>@</code>‘ (<code>U+0040 COMMERCIAL AT</code>), 后跟一个标识符，并包括直到下一个分号的所有内容， ‘<code>;</code>‘ (<code>U+003B SEMICOLON</code>), 或下一个 CSS 块，以先到者为准。</p><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/@charset"><code>@charset</code></a>, 定义样式表使用的字符集。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/@import"><code>@import</code></a>, 告诉 CSS 引擎引入一个外部样式表。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/@namespace"><code>@namespace</code></a>, 告诉 CSS 引擎必须考虑 XML 命名空间。</li><li>嵌套 @规则，是嵌套语句的子集，不仅可以作为样式表里的一个语句，也可以用在条件规则组里：<ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/@media"><code>@media</code></a>, 如果满足媒介查询的条件则条件规则组里的规则生效。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/@page"><code>@page</code></a>, 描述打印文档时布局的变化。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/@font-face"><code>@font-face</code></a>, 描述将下载的外部的字体。 Experimental</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/@keyframes"><code>@keyframes</code></a>, 描述 CSS 动画的中间步骤 . Experimental</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/@supports"><code>@supports</code></a>, 如果满足给定条件则条件规则组里的规则生效。 Experimental</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/@document"><code>@document</code></a>, 如果文档样式表满足给定条件则条件规则组里的规则生效。 <em>(推延至 CSS Level 4 规范)</em></li></ul></li></ul><p><strong>条件规则组</strong>. 这些语句使用相同的语法。它们都嵌套语句，或者是<em>规则</em>或者是*@规则*。它们都表达：它们所指的条件 (类型不同) 总等效于 <strong>true</strong> 或者 <strong>false</strong>，如果为 <strong>true</strong> 那么它们里面的语句生效。</p><h3 id="scss"><a href="#scss" class="headerlink" title="scss"></a>scss</h3><p>sass3.0之后的进步版本，采用花括号分段而非缩进</p><p><a href="https://sass-lang.com/">Sass: Syntactically Awesome Style Sheets</a></p><p>css的超集</p><p>变量开头是$</p><h4 id="mixin"><a href="#mixin" class="headerlink" title="mixin"></a>mixin</h4><p>类似函数，变量参数以 $ 开头，定义用@mixin前缀，调用用@include 前缀</p><pre class="language-none"><code class="language-none">&lt;style type&#x3D;&#39;text&#x2F;scss&#39;&gt;@mixin border-radius($radius)&#123;  -webkit-border-radius:$radius;  -moz-border-radius:$radius;  -ms-border-radius:$radius;  border-radius:$radius;&#125;  #awesome &#123;    width: 150px;    height: 150px;    background-color: green;    @include border-radius(15px);  &#125;&lt;&#x2F;style&gt;&lt;div id&#x3D;&quot;awesome&quot;&gt;&lt;&#x2F;div&gt;</code></pre><h3 id="Less"><a href="#Less" class="headerlink" title="Less"></a>Less</h3><h4 id="Variables"><a href="#Variables" class="headerlink" title="Variables"></a>Variables</h4><p>变量，@开头，在最外层定义</p><pre class="language-less" data-language="less"><code class="language-less"><span class="token variable">@width<span class="token punctuation">:</span></span> 10px<span class="token punctuation">;</span><span class="token variable">@height<span class="token punctuation">:</span></span> <span class="token variable">@width</span> <span class="token operator">+</span> 10px<span class="token punctuation">;</span><span class="token selector">#header</span> <span class="token punctuation">&#123;</span>  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token variable">@width</span><span class="token punctuation">;</span>  <span class="token property">height</span><span class="token punctuation">:</span> <span class="token variable">@height</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//编译为</span><span class="token selector">#header</span><span class="token punctuation">&#123;</span>    <span class="token property">width</span><span class="token punctuation">:</span>10px<span class="token punctuation">;</span>    <span class="token property">height</span><span class="token punctuation">:</span>20px<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h4 id="Mixins"><a href="#Mixins" class="headerlink" title="Mixins"></a>Mixins</h4><p>混合</p><h4 id="Nesting"><a href="#Nesting" class="headerlink" title="Nesting"></a>Nesting</h4><p>嵌套</p><p><code>&amp;</code> 表示当前选择器的父级</p><pre class="language-less" data-language="less"><code class="language-less"><span class="token selector">.clearfix</span> <span class="token punctuation">&#123;</span>  <span class="token property">display</span><span class="token punctuation">:</span> block<span class="token punctuation">;</span>  <span class="token property">zoom</span><span class="token punctuation">:</span> 1<span class="token punctuation">;</span>  <span class="token selector">&amp;:after</span> <span class="token punctuation">&#123;</span>    <span class="token property">content</span><span class="token punctuation">:</span> <span class="token string">" "</span><span class="token punctuation">;</span>    <span class="token property">display</span><span class="token punctuation">:</span> block<span class="token punctuation">;</span>    <span class="token property">font-size</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>    <span class="token property">height</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>    <span class="token property">clear</span><span class="token punctuation">:</span> both<span class="token punctuation">;</span>    <span class="token property">visibility</span><span class="token punctuation">:</span> hidden<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="Stylus"><a href="#Stylus" class="headerlink" title="Stylus"></a><strong><code>Stylus</code></strong></h3><h2 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h2><p>document object model 文档对象模型，HTML的节点树</p><p>接口：Document，Window，Element，</p><p>基本操作分四类：增、删、查、改</p><p>查的方法：获取DOM节点</p><ul><li><p>js中执行document上的成员函数，传入 id、class、tagName等指定条件，获取DOM结点</p></li><li><p>通过css选择器查询DOM结点</p></li><li><p>通过已访问到的DOM节点对象访问其它相关的父子兄弟结点。</p></li><li><p><code>document.getElementById(id)</code></p></li><li><p><code>document.getElementsByTagName(name)</code>，参数是标签名，返回nodelist，类数组</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document/getElementsByClassName"><code>Document.getElementsByClassName()</code></a>，参数类名，返回nodelist</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document/querySelector"><code>document.querySelector()</code></a>，参数是css选择器语法，加引号，返回第一个符合选择器语法的element</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document/querySelectorAll"><code>document.querySelectorAll()</code></a>，参数同上，但返回nodelist</p></li></ul><p>增(例如定位element对象，为其增加子节点)、删(element.remove())、改(Element对象的方法)</p><h3 id="DOM事件"><a href="#DOM事件" class="headerlink" title="DOM事件"></a>DOM事件</h3><p>0级(其实并不存在这个标准)，1级(映射文档结构，特定于HTML的对象和方法)，2级(增加模块以支持新的接口：追踪文档不同视图的接口、事件及事件处理接口、处理元素css样式的接口、遍历和操作DOM树的接口)，3级(增加了以统一的方式加载和保存文档的方法（包含在一个叫 DOM  Load and Save 的新模块中），还有验证文档的方法（DOM Validation）)，4级(替代 Mutation Events 的 Mutation Observers)</p><ul><li>事件发生，触发设定好的应对函数(事件监听函数)，是js和HTML的交互基础，常用的有鼠标事件、触摸事件、键盘事件、媒体事件、剪切板事件、资源事件等</li><li>事件流，三个阶段：事件捕获Capture-&gt;目标事件Target-&gt;事件冒泡Bubbling      onclick和addEventListener的区别，前者不支持一个事件绑定多个事件处理函数，后者支持</li></ul><p>addEventListener的第三个参数为指定事件是否在捕获或冒泡阶段执行，<u>设置为true表示事件在捕获阶段执行，而设置为false表示事件在冒泡阶段执行。</u>默认值为true</p><p>event属性</p><ul><li><code>event.target</code>指向<strong>引起触发事件的元素</strong>，而<code>event.currentTarget</code>则是<strong>事件绑定的元素</strong>。</li></ul><pre class="language-none"><code class="language-none">target.addEventListener(type, listener[, useCapture]);target.removeEventListener(type, listener[, useCapture]);&#x2F;*方法中包含3个参数，分别是绑定的事件处理属性名称（不包含on）、事件处理函数、是否在捕获时执行事件处理函数*&#x2F;</code></pre><p>event方法</p><ul><li><p>stopPropagation方法主要用于阻止事件的进一步传播，配合addeventlistener第三个参数可以实现在事件捕获阶段阻止事件向下传播或在事件冒泡阶段阻止事件向上传播</p></li><li><p>preventDefault方法用于取消事件的默认操作，比如a链接的跳转行为和表单自动提交行为就可以用preventDefault方法来取消。</p></li><li><p>和stopPropagation相比，stopImmediatePropagation同样可以阻止事件的传播，不同点在于其还可以把这个元素绑定的同类型事件也阻止了。</p></li></ul><h3 id="虚拟DOM"><a href="#虚拟DOM" class="headerlink" title="虚拟DOM"></a>虚拟DOM</h3><p>Virtual dom, 即虚拟DOM节点。它通过JS的Object对象模拟DOM中的节点，然后再通过特定的render方法将其渲染成真实的DOM节点。</p><p>包含了<code>tag</code>、<code>props</code>、<code>children</code>三个属性。分别代表当前元素的标签名称字符串，当前标签的属性对象，子元素对象数组，也就是说可以无限嵌套。</p><pre class="language-none"><code class="language-none">render方法转换属性时要考虑多种情况。像value、style等属性需要做特殊处理function createElement(type, props, children) &#123;    return new Element(type, props, children);&#125;class Element &#123;    constructor(type, props, children) &#123;        this.type &#x3D; type;        this.props &#x3D; props;        this.children &#x3D; children;    &#125;&#125;function render(eleObj) &#123;    let el &#x3D; document.createElement(eleObj.type); &#x2F;&#x2F; 创建元素    for(let key in eleObj.props) &#123;        &#x2F;&#x2F; 设置属性的方法        setAttr(el, key, eleObj.props[key])    &#125;    eleObj.children.forEach(child &#x3D;&gt; &#123;        &#x2F;&#x2F; 判断子元素是否是Element类型，是则递归，不是则创建文本节点        child &#x3D; (child instanceof Element) ? render(child) : document.createTextNode(child);        el.appendChild(child);    &#125;);    return el;&#125;function setAttr(node, key, value) &#123;    switch(key) &#123;        case &#39;value&#39;: &#x2F;&#x2F; node是一个input或者textarea            if(node.tagName.toUpperCase() &#x3D;&#x3D;&#x3D; &#39;INPUT&#39; || node.tagName.toUpperCase() &#x3D;&#x3D;&#x3D; &#39;TEXTAREA&#39;) &#123;                node.value &#x3D; value;            &#125; else &#123; &#x2F;&#x2F; 普通属性                node.setAttribute(key, value);            &#125;        break;        case &#39;style&#39;:            node.style.cssText &#x3D; value;        break;        default:            node.setAttribute(key, value);        break;    &#125;&#125;&#x2F;&#x2F;renderDom接受 el 真实DOM和target 渲染目标两个参数，负责将真实DOM添加到浏览器上function renderDom(el, target) &#123;    target.appendChild(el);&#125;</code></pre><h3 id="DOM-Diff"><a href="#DOM-Diff" class="headerlink" title="DOM Diff"></a>DOM Diff</h3><p>通过<code>JS</code>层面的计算，返回一个patch对象，即补丁对象，再通过特定的操作解析<code>patch</code>对象，完成页面的重新渲染。</p><p>1.用JS对象模拟DOM（虚拟DOM）<br>2.把此虚拟DOM转成真实DOM并插入页面中（render）<br>3.如果有事件发生修改了虚拟DOM，比较两棵虚拟DOM树的差异，得到差异对象（diff）<br>4.把差异对象应用到真正的DOM树上（patch）</p><h2 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h2><p>Browser Object Model 浏览器对象模型，控制浏览器的行为的接口</p><p>window是浏览器对象模型</p><h3 id="window-location"><a href="#window-location" class="headerlink" title="window.location"></a>window.location</h3><h4 id="hash属性"><a href="#hash属性" class="headerlink" title="hash属性"></a>hash属性</h4><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Location"><code>Location</code></a> 接口的 <strong><code>hash</code></strong> 属性返回一个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String"><code>USVString</code></a>，其中会包含 URL 标识中的 <code>&#39;#&#39;</code> 和 后面 URL 片段标识符。这里 fragment 不会经过<a href="https://developer.mozilla.org/en-US/docs/Glossary/percent-encoding">百分比编码</a>（URL 编码）。如果 URL 中没有 fragment，该属性会包含一个空字符串，<code>&quot;&quot;</code></p><p>通过监听 window 对象的 hashChange 事件实现简单的路由</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript">window<span class="token punctuation">.</span><span class="token function-variable function">onhashchange</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">var</span> hash <span class="token operator">=</span> window<span class="token punctuation">.</span>location<span class="token punctuation">.</span>hash  <span class="token keyword">var</span> path <span class="token operator">=</span> hash<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>  <span class="token keyword">switch</span> <span class="token punctuation">(</span>path<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">case</span> <span class="token string">'/'</span><span class="token operator">:</span>      <span class="token function">showHome</span><span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token keyword">break</span>    <span class="token keyword">case</span> <span class="token string">'/users'</span><span class="token operator">:</span>      <span class="token function">showUsersList</span><span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token keyword">break</span>    <span class="token keyword">default</span><span class="token operator">:</span>      <span class="token function">show404NotFound</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;持续更新&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;h2 id=&quot;web基础知识&quot;&gt;&lt;a href=&quot;#web基础知识&quot; class=</summary>
      
    
    
    
    <category term="Frontend" scheme="https://hhumar.com/categories/Frontend/"/>
    
    
    <category term="Web" scheme="https://hhumar.com/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>Python</title>
    <link href="https://hhumar.com/2022/10/31/Python/"/>
    <id>https://hhumar.com/2022/10/31/Python/</id>
    <published>2022-10-31T01:57:20.000Z</published>
    <updated>2022-11-05T18:10:35.733Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>持续更新</p></blockquote><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="变量相关"><a href="#变量相关" class="headerlink" title="变量相关"></a>变量相关</h3><ul><li><p>Numbers（数字）</p><ul><li>int（有符号整型） <em>Python3.X 版本中 long 类型被移除，使用 int 替代。</em></li><li>float（浮点型）<ul><li>float(‘inf’) 表示正无穷 -float(‘inf’) 或 float(‘-inf’) 表示负无穷 其中，inf 均可以写成 Inf</li></ul></li><li>complex（复数）复数由实数部分和虚数部分构成，可以用 a + bj,或者 complex(a,b) 表示， 复数的实部 a 和虚部 b 都是浮点型。</li></ul></li><li><p>String（字符串）</p><ul><li><p>u&#x2F;U:表示unicode字符串<br>不是仅仅是针对中文, 可以针对任何的字符串，代表是对字符串进行unicode编码。<br>一般英文字符在使用各种编码下, 基本都可以正常解析, 所以一般不带u；但是中文, 必须表明所需编码, 否则一旦编码转换就会出现乱码。<br>建议所有编码方式采用utf-8，即在py文件开头添加: # coding: utf-8</p></li><li><p>r&#x2F;R:非转义的原始字符串<br>与普通字符相比，其他相对特殊的字符，其中可能包含转义字符，即那些，反斜杠加上对应字母，表示对应的特殊含义的，比如最常见的”\n”表示换行，”\t”表示Tab等。而如果是以r开头，那么说明后面的字符，都是普通的字符了，即如果是“\n”那么表示一个反斜杠字符，一个字母n，而不是表示换行了。<br>以r开头的字符，常用于正则表达式，对应着re模块。</p></li><li><p>F-strings python3.6开始支持，类似js的模板字符串</p><pre class="language-python" data-language="python"><code class="language-python">str_p <span class="token operator">=</span> <span class="token string-interpolation"><span class="token string">f'顺子是</span><span class="token interpolation"><span class="token punctuation">&#123;</span>add_string<span class="token punctuation">(</span><span class="token builtin">str</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span></span><span class="token string">'</span></span></code></pre></li></ul></li><li><p>List（列表）</p></li><li><p>Tuple（元组）</p></li><li><p>Dictionary（字典），类似js的map和object结合，键值可以为字符串也可以为number</p></li></ul><p>None 是 NoneType 数据类型的唯一值</p><p>python中除号用&#x2F;表示，但是和C语言不同的是&#x2F;得到的值总是<a href="https://so.csdn.net/so/search?q=%E6%B5%AE%E7%82%B9&spm=1001.2101.3001.7020">浮点</a>数，&#x2F;&#x2F; 两数相除，向下取整</p><p>未声明为非局部变量的变量是只读的，（写入只读变量会在最内层作用域中创建一个 <strong>新的</strong> 局部变量，而同名的外部变量保持不变。）</p><p>空字符串、空列表、空元组、空字典、空集合均为false</p><h3 id="内置类型"><a href="#内置类型" class="headerlink" title="内置类型"></a>内置类型</h3><p><a href="https://docs.python.org/zh-cn/3/library/stdtypes.html?highlight=maketrans#text-sequence-type-str">https://docs.python.org/zh-cn/3/library/stdtypes.html?highlight=maketrans#text-sequence-type-str</a></p><p>数字类型 — <a href="https://docs.python.org/zh-cn/3/library/functions.html#int"><code>int</code></a>, <a href="https://docs.python.org/zh-cn/3/library/functions.html#float"><code>float</code></a>, <a href="https://docs.python.org/zh-cn/3/library/functions.html#complex"><code>complex</code></a></p><p>序列类型 — <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html?highlight=maketrans#list"><code>list</code></a>, <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html?highlight=maketrans#tuple"><code>tuple</code></a>, <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html?highlight=maketrans#range"><code>range</code></a><a href="https://docs.python.org/zh-cn/3/library/stdtypes.html?highlight=maketrans#sequence-types-list-tuple-range">¶</a></p><p>文本序列类型 — <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html?highlight=maketrans#str"><code>str</code></a><a href="https://docs.python.org/zh-cn/3/library/stdtypes.html?highlight=maketrans#text-sequence-type-str">¶</a></p><p>…</p><h3 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h3><p>list() 可以直接把字符串转为字符数组，split方法则不行</p><p>chr()函数取整数值作为Unicode码转换为字符，ord() 获取单个字符输出 Unicode 码</p><h3 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h3><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>in &#x2F; not in</td><td>成员运算符</td></tr><tr><td>is &#x2F; not is</td><td>身份运算符</td></tr></tbody></table><h3 id="基础语句"><a href="#基础语句" class="headerlink" title="基础语句"></a>基础语句</h3><ul><li><p>yield语句：与 return 的差别在于会保留执行状态，下次调用会从上次执行点继续执行</p></li><li><p><code>if</code> 、<code>elif</code> 、<code>else</code>条件控制语句</p><p>支持a&lt;x&lt;b这种连比</p></li><li><p>循环语句：</p><ul><li><p>while……else</p></li><li><p>for循环，start默认为0，step默认为1，&lt;stop，不会等于stop</p><pre class="language-none"><code class="language-none">for i in range(satrt, stop, step):    业务逻辑</code></pre></li></ul><p><code>pass 语句</code> 是 Python 中的空语句，程序执行到此语句直接跳过，不会做任何的操作，仅作占位语句，但它在保持程序结构的完整性方面，有一定价值。</p><ul><li><p>列表推导式效率远高于for循环语句</p><p>out_list &#x3D; [表达式 for 变量 in 列表 条件判断语句等]</p><pre class="language-none"><code class="language-none">&gt;&gt;&gt; out_list &#x3D; [i**2 for i in range(10) if i % 2 &#x3D;&#x3D;0]&gt;&gt;&gt; out_list[0, 4, 16, 36, 64]</code></pre></li></ul></li><li><p>match…case</p><ul><li>变量名 <code>_</code> 作为 通配符 并确保目标将总是被匹配，是可选的，如果没有又之前 case 未得到匹配，则会执行一个空操作（no-op）</li></ul></li><li><p>try…except…as… 捕获异常</p><pre class="language-none"><code class="language-none">try:    a&#x3D;1+&quot;b&quot;except Exception as e:    print(e)</code></pre></li><li><p>lambda函数</p><pre class="language-none"><code class="language-none">lambda arg1,arg2,arg3… :&lt;表达式&gt;lambda x, y: x*y；函数输入是x和y，输出是它们的积x*ylambda:None；函数没有输入参数，输出是Nonelambda *args: sum(args); 输入是任意个数的参数，输出是它们的和(隐性要求是输入参数必须能够进行加法运算)lambda **kwargs: 1；输入是任意键值对参数，输出是1</code></pre></li></ul><h3 id="数据值传递和引用"><a href="#数据值传递和引用" class="headerlink" title="数据值传递和引用"></a>数据值传递和引用</h3><p>字符串，数值，元组均为静态变量，列表，字典为动态变量。一般静态变量值传递为拷贝，动态变量值传递为引用。利用 id() 可以查看变量存储地址。</p><p>注：对静态变量首次传递时也是引用，当需要修改静态变量时，因为静态变量不能改变，所以需要生成一个新的空间存储数据。</p><p>所以更准确地说，python中只有引用传递，只不过静态类型不可改变，要改变对应名称的值只能改变其指向的内存地址。</p><p><strong>is比较的是两个对象的内存地址是否相等，&#x3D;&#x3D;比较的是两个对象的值是否相等</strong>。</p><pre class="language-python" data-language="python"><code class="language-python">a <span class="token operator">=</span> <span class="token number">1</span>b <span class="token operator">=</span> <span class="token number">1</span>a <span class="token operator">==</span> b <span class="token comment"># True</span>a <span class="token keyword">is</span> b <span class="token comment"># True</span>a <span class="token operator">=</span> <span class="token number">888</span>b <span class="token operator">=</span> <span class="token number">888</span>a <span class="token operator">==</span> b <span class="token comment"># True</span>a <span class="token keyword">is</span> b <span class="token comment"># False</span>a <span class="token operator">=</span> <span class="token string">'hello'</span>b <span class="token operator">=</span> <span class="token string">'hello'</span>a <span class="token keyword">is</span> b <span class="token comment"># True</span>a <span class="token operator">==</span> b <span class="token comment"># True</span>a <span class="token operator">=</span> <span class="token string">'hello world'</span>b <span class="token operator">=</span> <span class="token string">'hello world'</span>a <span class="token operator">==</span> b <span class="token comment"># True</span>a <span class="token keyword">is</span> b <span class="token comment"># False</span></code></pre><p>部分代表小整数的对象都会指向小整数池，类似的，Python解释器中使用了 intern（字符串驻留），使值同样的字符串对象仅仅会保存一份，放在一个字符串储蓄池中，是共用的，如果字符串中有空格，默认不启用intern机制。对字符串储蓄池中的字符串使用 is 和 &#x3D;&#x3D; 比较会得到相同的结果。</p><p><strong>在shell中，仅有以下划线、数字、字母组成的字符串会被intern。而pycharm中只要是同一个字符串不超过20个字符都被加入到池中</strong></p><p>需要严格根据解释环境判断，在IDLE中id都一样。</p><p>垃圾回收：引用计数，当某个对象在其作用域内不再被其他对象引用的时候，Python 就自动清除对象；</p><p>注意深浅拷贝：</p><ul><li>a.append(tmp)a.append(tmp[:])</li></ul><h3 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h3><p>切片使用2个冒号分隔的3个数字来完成：</p><ul><li>第一个数字表示切片的开始位置，默认为0</li><li>第二个数字表是切片的截止（但不包含）位置（默认为列表长度）</li><li>第三个数字表示切片的步长(默认为1)，当步长省略时，顺便可以省略最后一个冒号。</li></ul><p><code>a[:]</code>是深复制，<code>a</code>是浅复制，相当于赋值<code>a</code>的话是赋值了指针，赋值<code>a[:]</code>相当于复制了<code>a</code>对应的那段空间</p><h3 id="解包"><a href="#解包" class="headerlink" title="解包"></a>解包</h3><p>解包赋值，是zip函数的逆操作。</p><h2 id="基础数据结构类型"><a href="#基础数据结构类型" class="headerlink" title="基础数据结构类型"></a>基础数据结构类型</h2><h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><p>中括号<code>[]</code>创建一个列表，列表内可含有各种不同类型，包括再嵌套列表。</p><p><code>append</code>一次添加1个元素，<code>insert</code>在指定位置添加元素</p><pre class="language-none"><code class="language-none">a.insert(2,5) # insert 在索引2处添加元素5</code></pre><p><code>remove</code>直接删除元素，若被删除元素在列表内重复出现多次，则只删除第一次</p><p><code>pop</code>方法若不带参数默认删除列表最后一个元素；若带参数则删除此参数代表的索引处的元素</p><p>列表封装的其他方法还包括如下：</p><pre class="language-none"><code class="language-none">clear&#96;,&#96;index&#96;,&#96;count&#96;,&#96;sort&#96;,&#96;reverse&#96;,&#96;copy</code></pre><h3 id="tuple"><a href="#tuple" class="headerlink" title="tuple"></a>tuple</h3><p>元组是一类不允许添加删除元素的特殊列表，也就是一旦创建后续决不允许增加、删除、修改。<code>()</code>创建元组。</p><h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p><strong>基本用法</strong> set是一种里面不能含有重复元素的数据结构，这种特性天然的使用于列表的去重。</p><h3 id="dict"><a href="#dict" class="headerlink" title="dict"></a>dict</h3><p><code>&#123;&#125;</code>创建，键值可以为数字、字符串甚至是元祖</p><p>元组可以作为 dict 的 key，但列表不能作为元组的 key。这是由于 dict 要求 key 必须是不可变类型，但列表是可变类型，因此列表不能作为元组的 key。</p><p>items()、keys()、values() 分别用于获取字典中的所有 key-value 对、所有 key、所有 value。这三个方法依次返回 dict_items、dict_keys 和 dict_values 对象，Python 不希望用户直接操作这几个方法，但可通过 list() 函数把它们转换成列表。</p><ul><li>dict.has_key(key)<br>如果键在字典dict里返回true，否则返回false</li><li>dict.get(key, default&#x3D;None) 返回指定键的值，如果值不在字典中返回default值</li></ul><h3 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h3><p>collections.deque()</p><p><em>class</em> <code>collections.``deque</code>([<em>iterable</em>[, <em>maxlen</em>]])</p><ul><li><p><code>append</code>(<em>x</em>)</p><p>添加 <em>x</em> 到右端。</p></li><li><p><code>appendleft</code>(<em>x</em>)</p><p>添加 <em>x</em> 到左端。</p></li><li><p><code>pop</code>()</p><p>移去并且返回一个元素，deque 最右侧的那一个。 如果没有元素的话，就引发一个 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#IndexError"><code>IndexError</code></a>。</p></li><li><p><code>popleft</code>()</p><p>移去并且返回一个元素，deque 最左侧的那一个。 如果没有元素的话，就引发 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#IndexError"><code>IndexError</code></a>。</p></li><li><p>Deque对象同样提供了一个只读属性:</p><ul><li><p><code>maxlen</code></p><p>Deque的最大尺寸，如果没有限定的话就是 <code>None</code> 。</p></li></ul></li></ul><h3 id="Counter"><a href="#Counter" class="headerlink" title="Counter"></a>Counter</h3><h3 id="OrderedDict"><a href="#OrderedDict" class="headerlink" title="OrderedDict"></a>OrderedDict</h3><p>collections. 有序字典</p><h3 id="heapq"><a href="#heapq" class="headerlink" title="heapq"></a>heapq</h3><h3 id="defaultdict"><a href="#defaultdict" class="headerlink" title="defaultdict"></a>defaultdict</h3><h3 id="ChainMap"><a href="#ChainMap" class="headerlink" title="ChainMap"></a>ChainMap</h3><h2 id="常用函数、方法"><a href="#常用函数、方法" class="headerlink" title="常用函数、方法"></a>常用函数、方法</h2><pre class="language-none"><code class="language-none">a &#x3D; &#39;123456&#39;a[2:3]&#x2F;&#x2F;&#39;3&#39; 冒号前包后不包string.isdigit() &#x2F;&#x2F;如果 string 只包含数字则返回 True 否则返回 False.</code></pre><h3 id="enumerate"><a href="#enumerate" class="headerlink" title="enumerate()"></a><strong>enumerate()</strong></h3><p>遍历列表(数组)，可以同时获取索引和值，下面是例子</p><pre class="language-python" data-language="python"><code class="language-python">arr1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"a"</span><span class="token punctuation">,</span><span class="token string">"b"</span><span class="token punctuation">,</span><span class="token string">"c"</span><span class="token punctuation">,</span><span class="token string">"d"</span><span class="token punctuation">]</span><span class="token keyword">for</span> index<span class="token punctuation">,</span>value <span class="token keyword">in</span> <span class="token builtin">enumerate</span><span class="token punctuation">(</span>arr1<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token keyword">print</span><span class="token punctuation">(</span>index<span class="token punctuation">,</span>value<span class="token punctuation">)</span><span class="token comment"># 结果</span><span class="token number">0</span> a<span class="token number">1</span> b<span class="token number">2</span> c<span class="token number">3</span> d</code></pre><h3 id="json模块"><a href="#json模块" class="headerlink" title="json模块"></a>json模块</h3><p>把字符串转换成字典对象json.loads()</p><p>把对象转换成字符串json.dumps()</p><p>json.dump(data,file)把字典对象转换成字符串并写入文件</p><p>字符串转换成字典对象时，字符串里只能使用双引号</p><h3 id="‘’-join-拼接字符串"><a href="#‘’-join-拼接字符串" class="headerlink" title="‘’.join() 拼接字符串"></a>‘’.join() 拼接字符串</h3><pre class="language-python" data-language="python"><code class="language-python">arr <span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">"a"</span><span class="token punctuation">,</span><span class="token string">"b"</span><span class="token punctuation">,</span><span class="token string">"c"</span><span class="token punctuation">]</span>arr_str <span class="token operator">=</span> <span class="token string">"-"</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>arr_str<span class="token punctuation">)</span><span class="token comment"># 输出结果 a-b-c</span><span class="token string">''</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>chain<span class="token punctuation">(</span><span class="token operator">*</span>mat<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">//</span>拼接二维矩阵</code></pre><h3 id="math-comb"><a href="#math-comb" class="headerlink" title="math.comb()"></a>math.comb()</h3><p>Python中的method方法用于获取从n个项目中选择k个项目(不重复且无顺序)的方法数量</p><h3 id="os-path-split-‘PATH’"><a href="#os-path-split-‘PATH’" class="headerlink" title="os.path.split(‘PATH’)"></a>os.path.split(‘PATH’)</h3><p>以 “PATH” 中最后一个 ‘&#x2F;‘ 作为分隔符，分隔后，将索引为0的视为目录（路径），将索引为1的视为文件名</p><h3 id="print"><a href="#print" class="headerlink" title="print"></a>print</h3><p> print(i,end&#x3D;’\n’)，可指定末尾字符，默认为换行</p><h3 id="round"><a href="#round" class="headerlink" title="round()"></a>round()</h3><p>四舍五入取整</p><h3 id="str-maketrans-intab-outtab"><a href="#str-maketrans-intab-outtab" class="headerlink" title="str.maketrans(intab.outtab)"></a>str.maketrans(intab.outtab)</h3><ul><li>intab – 字符串中要替代的字符组成的字符串。</li><li>outtab – 相应的映射字符的字符串。</li></ul><p>内建函数: bytearray.maketrans()、bytes.maketrans()、str.maketrans()</p><p>通常和 translate 方法配合使用</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token comment">#!/usr/bin/python3</span> intab <span class="token operator">=</span> <span class="token string">"aeiou"</span>outtab <span class="token operator">=</span> <span class="token string">"12345"</span>deltab <span class="token operator">=</span> <span class="token string">"thw"</span> trantab1 <span class="token operator">=</span> <span class="token builtin">str</span><span class="token punctuation">.</span>maketrans<span class="token punctuation">(</span>intab<span class="token punctuation">,</span>outtab<span class="token punctuation">)</span> <span class="token comment"># 创建字符映射转换表</span>trantab2 <span class="token operator">=</span> <span class="token builtin">str</span><span class="token punctuation">.</span>maketrans<span class="token punctuation">(</span>intab<span class="token punctuation">,</span>outtab<span class="token punctuation">,</span>deltab<span class="token punctuation">)</span> <span class="token comment">#创建字符映射转换表，并删除指定字符</span> test <span class="token operator">=</span> <span class="token string">"this is string example....wow!!!"</span> <span class="token keyword">print</span><span class="token punctuation">(</span>test<span class="token punctuation">.</span>translate<span class="token punctuation">(</span>trantab1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>test<span class="token punctuation">.</span>translate<span class="token punctuation">(</span>trantab2<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><h3 id="str-split"><a href="#str-split" class="headerlink" title="str.split()"></a>str.split()</h3><p>语法：str.split(str&#x3D;” “,num&#x3D;string.count(str))</p><p>参数说明：<br>str： 表示为分隔符，默认为空格，但是不能为空串。若字符串中没有分隔符，则把整个字符串作为列表的一个元素。<br>num：表示分割次数。如果存在参数num，则仅分隔成 num+1 个子字符串。</p><p>默认空格分隔时会忽略分割后的空串，包括\n\t\r （\r\n表示回车换行）</p><pre class="language-none"><code class="language-none">s.split(&#39;.&#39;,-1) #尽可能多的分隔，与不加num参数相同</code></pre><p>注意：str为不可变对象，所以此方法不会修改原对象，若需处理分割后的字符串需要转储返回值</p><pre class="language-none"><code class="language-none">sNew &#x3D; str.split()</code></pre><h3 id="str-strip-chars"><a href="#str-strip-chars" class="headerlink" title="str.strip([chars])"></a>str.strip([chars])</h3><p>strip() 方法用于移除<a href="https://so.csdn.net/so/search?q=%E5%AD%97%E7%AC%A6%E4%B8%B2&spm=1001.2101.3001.7020">字符串</a>头尾指定的字符（默认为空格或换行符）或字符序列。</p><p>还有lstrip和rstrip，去除头部或尾部</p><h3 id="和"><a href="#和" class="headerlink" title="* 和 **"></a>* 和 **</h3><ul><li><code>*args</code>：argument用于列表、元组、集合</li><li><code>**kwargs</code>：kwargument用于字典</li></ul><p>1.解包可迭代对象</p><pre class="language-none"><code class="language-none">nums1&#x3D;[*nums1,*nums2]nums1+&#x3D;nums2nums1.extend(nums2)</code></pre><p>2.函数可变参数</p><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p><a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#nonlocal"><code>nonlocal</code></a> 语句会使得所列出的名称指向之前在最近的包含作用域中绑定的除全局变量以外的变量。</p><p><a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#global"><code>global</code></a> 语句是作用于整个当前代码块的声明。 它意味着所列出的标识符将被解读为全局变量。 要给全局变量赋值不可能不用到 <code>global</code> 关键字，不过自由变量也可以指向全局变量而不必声明为全局变量。</p><p>在 <a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#global"><code>global</code></a> 语句中列出的名称不得在同一代码块内该 <code>global</code> 语句之前的位置中使用。</p><p>在 <a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#global"><code>global</code></a> 语句中列出的名称不能被定义为形式参数，也不能被作为 <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#with"><code>with</code></a> 语句或 <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#except"><code>except</code></a> 子句的目标，以及 <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#for"><code>for</code></a> 循环的目标列表、<a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#class"><code>class</code></a> 定义、函数定义、<a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#import"><code>import</code></a> 语句或变量标注等等。</p><pre class="language-none"><code class="language-none">def scope_test():    def do_local():        spam &#x3D; &quot;local spam&quot;    def do_nonlocal():        nonlocal spam        spam &#x3D; &quot;nonlocal spam&quot;    def do_global():        global spam        spam &#x3D; &quot;global spam&quot;    spam &#x3D; &quot;test spam&quot;    do_local()    print(&quot;After local assignment:&quot;, spam)    do_nonlocal()    print(&quot;After nonlocal assignment:&quot;, spam)    do_global()    print(&quot;After global assignment:&quot;, spam)scope_test()print(&quot;In global scope:&quot;, spam)输出：After local assignment: test spamAfter nonlocal assignment: nonlocal spamAfter global assignment: nonlocal spamIn global scope: global spam</code></pre><h2 id="可迭代对象，迭代器，生成器"><a href="#可迭代对象，迭代器，生成器" class="headerlink" title="可迭代对象，迭代器，生成器"></a>可迭代对象，迭代器，生成器</h2><p>常见可迭代对象</p><ol><li>集合或序列类型（如<code>list</code>、<code>tuple</code>、<code>set</code>、<code>dict</code>、<code>str</code>）</li><li>文件对象</li><li>在类中定义了<code>__iter__()</code>方法的对象，可以被认为是 <code>Iterable</code>对象，但自定义的可迭代对象要能在<code>for</code>循环中正确使用，就需要保证<code>__iter__()</code>实现必须是正确的（即可以通过内置<code>iter()</code>函数转成<code>Iterator</code>对象。<code>iter()</code>函数是能够将一个可迭代对象转成迭代器对象，然后在<code>for</code>中使用）</li><li>在类中实现了如果只实现<code>__getitem__()</code>的对象可以通过<code>iter()</code>函数转化成迭代器但其本身不是可迭代对象。所以当一个对象能够在<code>for</code>循环中运行，但不一定是<code>Iterable</code>对象。</li></ol><p><code>可迭代对象（Iteratable Object）</code> 是能够一次返回其中一个成员的对象，<strong>都构建了 <code>__iter__</code> 方法</strong></p><p><code>迭代器（Iterator）</code> 是同时实现<code>__iter__() 与 __next__()</code> 方法的对象。</p><pre class="language-none"><code class="language-none">class IterObj:    def __init__(self):        self.a &#x3D; [3, 5, 7, 11, 13, 17, 19]        self.n &#x3D; len(self.a)        self.i &#x3D; 0    def __iter__(self):        return iter(self.a)    def __next__(self):        while self.i &lt; self.n:            v &#x3D; self.a[self.i]            self.i +&#x3D; 1            return v        else:            self.i &#x3D; 0            raise StopIteration()</code></pre><p>定义生成器两种方法：</p><ol><li>列表生成器——生成器表达式</li><li>使用<code>yield</code>定义生成器函数——生成器函数</li></ol><p>Python 中，包含 yield 关键词的普通函数就是生成器。</p><p>定义二维数组</p><pre class="language-python" data-language="python"><code class="language-python">list_three <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">]</span></code></pre><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>对象方法、静态方法、类方法等，归属权分别为obj、cls、cls</p><h3 id="基础-1"><a href="#基础-1" class="headerlink" title="基础"></a>基础</h3><p>当（从结尾处）正常离开类定义时，将创建一个 <em>类对象</em>。 这基本上是一个包围在类定义所创建命名空间内容周围的包装器，原始的（在进入类定义之前起作用的）局部作用域将重新生效，类对象将在这里被绑定到类定义头所给出的类名称</p><p>任何形式为 <code>__spam</code> 的标识符（至少带有两个前缀下划线，至多一个后缀下划线）的文本将被替换为 <code>_classname__spam</code>，其中 <code>classname</code> 为去除了前缀下划线的当前类名称。 这种改写不考虑标识符的句法位置，只要它出现在类定义内部就会进行。__init__类似构造函数</p><pre class="language-none"><code class="language-none">class Student(object):    ...    def set_score(self, score):        self.__score &#x3D; score</code></pre><p>以双下划线开头，并且以双下划线结尾的，是特殊变量，特殊变量是可以直接访问的，不是private变量，所以，不能用<code>__name__</code>、<code>__score__</code>这样的变量名</p><p>t.ppr()等同于Test.ppr(t)</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">ppr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span>t <span class="token operator">=</span> Test<span class="token punctuation">(</span><span class="token punctuation">)</span>t<span class="token punctuation">.</span>ppr<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">#Test.ppr(t)</span><span class="token comment">#没有传参数，error:</span>Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>  File <span class="token string">"cl.py"</span><span class="token punctuation">,</span> line <span class="token number">6</span><span class="token punctuation">,</span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">></span>    t<span class="token punctuation">.</span>ppr<span class="token punctuation">(</span><span class="token punctuation">)</span>TypeError<span class="token punctuation">:</span> ppr<span class="token punctuation">(</span><span class="token punctuation">)</span> takes <span class="token number">0</span> positional arguments but <span class="token number">1</span> was given</code></pre><p>ins，用来表示调用它的类实例</p><p>cls，类</p><p>类本身的方法是函数对象，实例的方法是方法对象，实现原理如下：</p><p>​当一个实例的非数据属性被引用时，将搜索实例所属的类。 如果被引用的属性名称表示一个有效的类属性中的函数对象，会通过打包（指向）查找到的实例对象和函数对象到一个抽象对象的方式来创建方法对象：这个抽象对象就是方法对象。 当附带参数列表调用方法对象时，将基于实例对象和参数列表构建一个新的参数列表，并使用这个新参数列表调用相应的函数对象。</p><h3 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h3><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Parent</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">pprt</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token keyword">class</span> <span class="token class-name">Child</span><span class="token punctuation">(</span>Parent<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">cprt</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span>c <span class="token operator">=</span> Child<span class="token punctuation">(</span><span class="token punctuation">)</span>c<span class="token punctuation">.</span>cprt<span class="token punctuation">(</span><span class="token punctuation">)</span>c<span class="token punctuation">.</span>pprt<span class="token punctuation">(</span><span class="token punctuation">)</span>p <span class="token operator">=</span> Parent<span class="token punctuation">(</span><span class="token punctuation">)</span>p<span class="token punctuation">.</span>pprt<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">#output:</span><span class="token operator">&lt;</span>__main__<span class="token punctuation">.</span>Child <span class="token builtin">object</span> at <span class="token number">0x0000000002A47080</span><span class="token operator">></span><span class="token operator">&lt;</span>__main__<span class="token punctuation">.</span>Child <span class="token builtin">object</span> at <span class="token number">0x0000000002A47080</span><span class="token operator">></span><span class="token operator">&lt;</span>__main__<span class="token punctuation">.</span>Parent <span class="token builtin">object</span> at <span class="token number">0x0000000002A47240</span><span class="token operator">></span></code></pre><h3 id="类中的方法："><a href="#类中的方法：" class="headerlink" title="类中的方法："></a>类中的方法：</h3><ul><li><code>__init__</code>方法的第一参数永远是<code>self</code>，表示创建的类<strong>实例本身</strong>，因此，在<code>__init__</code>方法内部，就可以把各种属性绑定到self，因为self就指向创建的实例本身。（2）、有了<code>__init__</code>方法，在创建实例的时候，就不能传入空的参数了，必须传入与<code>__init__</code>方法匹配的参数，但self不需要传，Python解释器会自己把实例变量传进去：</li></ul><p>也分实例属性和类属性，后者所有实例共享</p><p><strong>实例属性访问优先级比类属性高</strong></p><p>千万不要在实例上修改类属性，它实际上并没有修改类属性，而是给实例绑定了一个实例属性。</p><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><h3 id="解释器信息"><a href="#解释器信息" class="headerlink" title="解释器信息"></a>解释器信息</h3><p>#!&#x2F;usr&#x2F;bin&#x2F;python</p><p>分成两种情况：</p><p>（1）如果调用 python 脚本时，使用:</p><pre class="language-none"><code class="language-none">python script.py </code></pre><p>#!&#x2F;usr&#x2F;bin&#x2F;python 被忽略，等同于注释</p><p>（2）如果调用python脚本时，使用:</p><pre class="language-none"><code class="language-none">.&#x2F;script.py </code></pre><p>#!&#x2F;usr&#x2F;bin&#x2F;python 指定解释器的路径</p><p>PS：shell 脚本中在第一行也有类似的声明。</p><h3 id="复杂类型注解"><a href="#复杂类型注解" class="headerlink" title="复杂类型注解"></a>复杂类型注解</h3><p>List[int]即由int组成的列表，但是，实际中，只要这个列表中存在nt（其他的可以为任何类型），就不会出现警告</p><h3 id="模块信息"><a href="#模块信息" class="headerlink" title="模块信息"></a>模块信息</h3><p>__name__</p><p>直接执行一段脚本的时候，这段脚本的 **<strong>name</strong>**变量等于 <strong>‘<strong>main</strong>‘<strong>，当这段脚本被导入其他程序的时候，</strong><strong>name</strong></strong> 变量等于脚本本身的名字。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;持续更新&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;h2 id=&quot;基础&quot;&gt;&lt;a href=&quot;#基础&quot; class=&quot;headerlin</summary>
      
    
    
    
    <category term="常用编程语言基础知识" scheme="https://hhumar.com/categories/%E5%B8%B8%E7%94%A8%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="Python" scheme="https://hhumar.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript</title>
    <link href="https://hhumar.com/2022/10/30/js/"/>
    <id>https://hhumar.com/2022/10/30/js/</id>
    <published>2022-10-30T07:29:37.000Z</published>
    <updated>2022-11-05T18:11:20.750Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>持续更新</p></blockquote><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><pre class="language-none"><code class="language-none">JS和python都是解释型语言，仅需解释器在每次执行时编译并解释执行，编译型语言如c++，Java编译一次后，产生可执行文件可多次执行，效率高&lt;!--本地路径&#x2F;和\是等效的--&gt;&lt;img src&#x3D;&quot;.\Image\20161025\guo.jpg&quot; &#x2F;&gt;&lt;img src&#x3D;&quot;.&#x2F;Image&#x2F;20161025&#x2F;guo.jpg&quot; &#x2F;&gt;&lt;img src&#x3D;&quot;.\Image&#x2F;20161025&#x2F;guo.jpg&quot; &#x2F;&gt;&lt;img src&#x3D;&quot;.&#x2F;Image\20161025\guo.jpg&quot; &#x2F;&gt;&lt;!--网络文件路径一定要使用正斜杠&#x2F;--&gt;</code></pre><p>诞生于1995，出现时用于处理网页中的<strong>前端验证</strong>，发展中遵循ECMAScript标准，完整的JavaScript由三部分组成：<strong>ECMAScript标准，DOM文档对象模型，BOM浏览器对象模型</strong></p><p>解释型语言，无需编译直接运行，动态语言，基于原型的面向对象，写在script标签中，从上到下逐条执行；标识符命名仅可以含有字母、数字、_、$</p><h2 id="变量性质、关键字和特性"><a href="#变量性质、关键字和特性" class="headerlink" title="变量性质、关键字和特性"></a>变量性质、关键字和特性</h2><p>区分大小写，允许Unicode字母、数字和表意文字(意味着可以用汉字定义变量但不推荐)</p><p>当浏览器开辟出供代码执行的栈<a href="https://so.csdn.net/so/search?q=%E5%86%85%E5%AD%98&spm=1001.2101.3001.7020">内存</a>后，代码并没有自上而下立即执行，而是继续做了一些事情：<strong>把当前作用域中所有带var&#x2F;function关键字的进行提前的声明和定义 &#x3D;&gt; 变量提升机制</strong></p><p>typeof 操作符</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">typeof</span> <span class="token string">'aaa'</span><span class="token punctuation">;</span><span class="token comment">//"string"</span></code></pre><h3 id="let和var的区别"><a href="#let和var的区别" class="headerlink" title="let和var的区别"></a><code>let</code>和<code>var</code>的区别</h3><p> <code>let</code>和<code>const</code>不存在变量提升机制；<code>var</code>允许重复声明，而<code>let</code>不允许重复声明； <code>let</code>能解决<code>typeof</code>检测时出现的暂时性死区问题（<code>let</code>比<code>var</code>更严谨）；let创建的全局变量没有给window设置对应的属性；let会产生块级作用域</p><ul><li><code>var</code>声明是全局作用域或函数作用域，而<code>let</code>和<code>const</code>是块作用域。</li><li><code>var</code>变量可以在其范围内更新和重新声明； <code>let</code>变量可以被更新但不能重新声明； <code>const</code>变量既不能更新也不能重新声明。</li><li>它们都被提升到其作用域的顶端。但是，虽然使用变量<code>undefined</code>初始化了<code>var</code>变量，但未初始化<code>let</code>和<code>const</code>变量。</li><li>尽管可以在不初始化的情况下声明<code>var</code>和<code>let</code>，但是在声明期间必须初始化<code>const</code>。</li></ul><p>暂时性死区：在块级顶部到变量正式申明这块区域去访问这个变量的话，直接报错</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//报错而不是到外部引用x</span>    <span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="六种数据类型"><a href="#六种数据类型" class="headerlink" title="六种数据类型"></a>六种数据类型</h3><p><code>String</code> <code>Number</code> <code>Boolean</code>  <code>Undefined</code> <code>Symbol</code> <code>Object</code> </p><p><code>Object</code>为引用数据类型  </p><ul><li><p>Number</p><p>均采用IEEE 754存储数字，会把能转换为整数的小数转换为整数。科学计数法：3.123e7等效于3.123*10^7</p><p>八进制值用0o做前缀，十六进制0x前缀</p><p>浮点值最高精度为1e-17，不宜用js做科学计算</p><p><code>NaN</code>表示<code>Not a Number</code>，数据类型也是<code>Number</code>，有<code>Number.MIN_VALUE</code>&#x3D;5E-324，<code>Number.MAX_VALUE</code>&#x3D;1.797e308，还有正无穷 Infinity 和负无穷 -Infinity。函数 isFinite()可以判断数值是不是有限</p><p>isNaN()函数可以判断所给参数是否能转换为数值，不能则返回 true</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token function">isNan</span><span class="token punctuation">(</span><span class="token string">'10'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//返回false，因为能转化为数字</span>num<span class="token punctuation">.</span><span class="token function">toFixed</span><span class="token punctuation">(</span>digits<span class="token punctuation">)</span><span class="token comment">//浮点数规整化，digits为小数点后保留位数</span>Math<span class="token punctuation">.</span><span class="token function">trunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//return the integer portion of a number</span></code></pre><p>即将支持的 BigInt 大数，在number字面量后加上 n 即可。可以表示任意大整数。</p></li><li><p><code>null</code>值用来表示一个为空的对象，<code>typeof null</code>时返回<code>object</code>类型。原则上 null 表示一个空指针</p></li><li><p>string：将其他数据类型转换为String类型：<code>toString</code>方法和<code>String</code>函数，前者不能转换null和undefined类型，后者可以，凡遇字母转换为<code>NaN</code>。  转换为Number类型：Number函数，针对字符串有<code>parseInt</code>和<code>parseFloat</code>，这两个函数遇到其他类型时会先将对象转换为字符串再进行转换。</p><p>toString()方法在用于数值对象时可以接受参数，表示转换为不同进制的数字字符。</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> num <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>num<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// "10" </span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>num<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// "1010" </span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>num<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// "12" </span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>num<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// "10" </span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>num<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// "a" </span></code></pre><p><em>用加号操作符给一个值加上一个空字符串””也可以将其转换为字符串</em></p><ul><li><p>&#96;&#96;反引号，不同于单引号’’和双引号””，可以包裹模板字符串，能够允许嵌入表达式的字符串字面量，嵌入${expression}即可</p></li><li><p>标签函数标签函数 会接收被插值记号分隔后的模板和对每个表达式求值的结果。 标签函数本身是一个常规函数，通过前缀到模板字面量来应用自定义行为。</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span> <span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token number">9</span><span class="token punctuation">;</span> <span class="token keyword">function</span> <span class="token function">simpleTag</span><span class="token punctuation">(</span><span class="token parameter">strings<span class="token punctuation">,</span> <span class="token operator">...</span>expressions</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>     console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>strings<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">const</span> expression <span class="token keyword">of</span> expressions<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>         console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>expression<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span>     <span class="token keyword">return</span> <span class="token string">'foobar'</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token keyword">let</span> taggedResult <span class="token operator">=</span> simpleTag<span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span> a <span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token string"> + </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span> b <span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token string"> = </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span> a <span class="token operator">+</span> b <span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span> <span class="token comment">// ["", " + ", " = ", ""] 字符串数组</span><span class="token comment">// 6 </span><span class="token comment">// 9 </span><span class="token comment">// 15 </span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>taggedResult<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// "foobar" </span></code></pre></li><li><p>用模板字面量也可以直接获取原始的模板字面量内容。在标签函数的第一个参数中，存在一个特殊的属性<code>raw</code>，其他地方无法对字符串数组使用。</p></li></ul></li><li><p>Symbol类型：唯一标识符，具有唯一性、隐藏性（用作对象属性名时无法通过object.key访问，而需要定制的object.getOwnPropertySymbols()方法得到对象中所有用作属性名的symbol）</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> id1 <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token string">'id'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> id2 <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token string">'id'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>id1<span class="token operator">===</span>id2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//false</span><span class="token keyword">let</span> id3 <span class="token operator">=</span> Symbol<span class="token punctuation">.</span><span class="token function">for</span><span class="token punctuation">(</span><span class="token string">'id'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>id1<span class="token operator">===</span>id3<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//false</span><span class="token keyword">let</span> id4  <span class="token operator">=</span>Symbol<span class="token punctuation">.</span><span class="token function">for</span><span class="token punctuation">(</span><span class="token string">'id'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>id3<span class="token operator">===</span>id4<span class="token punctuation">)</span><span class="token comment">//true</span></code></pre><p>全局注册并登记，使得相同参数注册的值symbol相等。前提是都通过for注册登记。</p></li></ul><p>数字0，空字符串，NaN，空指针null，undefined都可以自动转化为false</p><p>null 其实属于自己的类型 Null，而不属于Object类型，typeof 之所以会判定为 Object 类型，是因为JavaScript 数据类型在底层都是以二进制的形式表示的，二进制的前三位为 0 会被 typeof 判断为对象类型，而 null 的二进制位恰好都是 0 ，因此，null 被误判断为 Object 类型。 <strong>对象被赋值了null 以后，对象对应的堆内存中的值就是游离状态了，GC 会择机回收该值并释放内存。</strong>因此，<strong>需要释放某个对象，就将变量设置为 null，即表示该对象已经被清空，目前无效状态。</strong></p><h2 id="基础语句"><a href="#基础语句" class="headerlink" title="基础语句"></a>基础语句</h2><p>==运算符会做强制类型转换===不会，单引号双引号和python一样，都可以用来包裹字符串，无区别。</p><p>typeof 操作符，返回其后变量或字面量的类型</p><p>+ 能做数字间的加减运算，当任一对象为字符串时会把另一参加运算对象转化为字符串再进行字符串拼接，参与运算对象为 object 或其他类型时会先转换为字符串再按如上规则运算</p><ul><li><p>try{}catch{}finally{}</p><p>1.try中有return, 会先将值暂存，无论finally语句中对该值做什么处理，最终返回的都是try语句中的暂存值。</p><p>2.当try与finally语句中均有return语句，会忽略try中return。</p></li></ul><h3 id="空值合并运算符"><a href="#空值合并运算符" class="headerlink" title="空值合并运算符"></a>空值合并运算符</h3><p><strong>空值合并操作符</strong>（**<code>??</code>**）是一个逻辑操作符，当左侧的操作数为 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/null"><code>null</code></a> 或者 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/undefined"><code>undefined</code></a> 时，返回其右侧操作数，否则返回左侧操作数。</p><p>与[逻辑或操作符（<code>||</code>）不同，逻辑或操作符会在左侧操作数为<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Falsy">假值</a>时返回右侧操作数。也就是说，如果使用 <code>||</code> 来为某些变量设置默认值，可能会遇到意料之外的行为。比如为假值（例如，<code>&#39;&#39;</code> 或 <code>0</code>）时。</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> foo <span class="token operator">=</span> <span class="token keyword">null</span> <span class="token operator">??</span> <span class="token string">'default string'</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// expected output: "default string"</span><span class="token keyword">const</span> baz <span class="token operator">=</span> <span class="token number">0</span> <span class="token operator">??</span> <span class="token number">42</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>baz<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// expected output: 0</span><span class="token keyword">const</span> baz <span class="token operator">=</span> <span class="token number">0</span> <span class="token operator">||</span> <span class="token number">42</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>baz<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// expected output: 42</span></code></pre><p>逻辑空赋值 ??&#x3D;</p><p>x ??&#x3D; y ，x为null或undefined时才赋值为右值。</p><h3 id="可选链操作符"><a href="#可选链操作符" class="headerlink" title="可选链操作符"></a>可选链操作符</h3><p>?.TS中遇到过</p><p>判断是否为空</p><h3 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h3><p>ES6 </p><ul><li><p>数组结构赋值：</p><p>只要某种数据结构具有 Iterator 接口，都可以采用数组形式的解构赋值。</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> <span class="token punctuation">[</span>a<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span>b<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span></code></pre></li><li><p>对象解构赋值：</p><p>注意loc: { start }和loc: start是不一样的，前者把start也作为模式串，而后者只有loc是模式串</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> node <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  <span class="token literal-property property">loc</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token literal-property property">start</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>      <span class="token literal-property property">line</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>      <span class="token literal-property property">column</span><span class="token operator">:</span> <span class="token number">5</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">let</span> <span class="token punctuation">&#123;</span> loc<span class="token punctuation">,</span> <span class="token literal-property property">loc</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span> start <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token literal-property property">loc</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span> <span class="token literal-property property">start</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span> line <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span> <span class="token operator">=</span> node<span class="token punctuation">;</span>line <span class="token comment">// 1</span>loc  <span class="token comment">// Object &#123;start: Object&#125;</span>start <span class="token comment">// Object &#123;line: 1, column: 5&#125;</span></code></pre><p>默认值，生效的条件是，对象的属性值严格等于<code>undefined</code>。</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> <span class="token punctuation">&#123;</span>x <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">&#125;</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token literal-property property">x</span><span class="token operator">:</span> <span class="token keyword">undefined</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>x <span class="token comment">// 3var </span><span class="token punctuation">&#123;</span>x <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">&#125;</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token literal-property property">x</span><span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>x <span class="token comment">// null</span></code></pre><p>由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构。</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">let</span> <span class="token punctuation">&#123;</span><span class="token number">0</span> <span class="token operator">:</span> first<span class="token punctuation">,</span> <span class="token punctuation">[</span>arr<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">:</span> last<span class="token punctuation">&#125;</span> <span class="token operator">=</span> arr<span class="token punctuation">;</span><span class="token comment">//index</span>first <span class="token comment">// 1</span>last <span class="token comment">// 3</span></code></pre></li></ul><h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h3><pre class="language-none"><code class="language-none">&#x2F;&#x2F; 箭头函数forEach(() &#x3D;&gt; &#123; &#x2F;* … *&#x2F; &#125; )forEach((value) &#x3D;&gt; &#123; &#x2F;* … *&#x2F; &#125; )forEach((value, key) &#x3D;&gt; &#123; &#x2F;* … *&#x2F; &#125; )forEach((value, key, map) &#x3D;&gt; &#123; &#x2F;* … *&#x2F; &#125; )&#x2F;&#x2F; 回调函数forEach(callbackFn)forEach(callbackFn, thisArg)&#x2F;&#x2F; 内联回调函数forEach(function() &#123; &#x2F;* … *&#x2F; &#125;)forEach(function(value) &#123; &#x2F;* … *&#x2F; &#125;)forEach(function(value, key) &#123; &#x2F;* … *&#x2F; &#125;)forEach(function(value, key, map) &#123; &#x2F;* … *&#x2F; &#125;)forEach(function(value, key, map) &#123; &#x2F;* … *&#x2F; &#125;, thisArg)</code></pre><h2 id="Map和Set"><a href="#Map和Set" class="headerlink" title="Map和Set"></a>Map和Set</h2><ul><li>一个 Object 的键只能是字符串或者 Symbols，但一个 Map 的键可以是任意值。</li><li>Map 的键值对个数可以从 size 属性获取，而 Object 的键值对个数只能手动计算。</li></ul><p>Set 对象允许你存储任何类型的唯一值，无论是原始值或者是对象引用。重复值的元素会被略去。</p><pre class="language-none"><code class="language-none">Set.prototype.add(value)在Set对象尾部添加一个元素。返回该 Set 对象Set.prototype.delete(value)移除值为 value 的元素，并返回一个布尔值来表示是否移除成功。Set.prototype.has(value) 会在此之后返回 false。Set.prototype.has(value)返回一个布尔值，表示该值在 Set 中存在与否。Set.prototype.clear()移除Set对象内的所有元素。Set.prototype.forEach(callbackFn[, thisArg])按照插入顺序，为 Set 对象中的每一个值调用一次 callBackFn。如果提供了thisArg参数，回调中的 this 会是这个参数。Set.prototype.values()返回一个新的迭代器对象，该对象包含 Set 对象中的按插入顺序排列的所有元素的值。</code></pre><p>let newArray &#x3D; Array.from(set)，可以把括号内的对象转换为array并返回</p><pre class="language-none"><code class="language-none">Map.prototype.size返回 Map 对象中的键值对数量。Map.prototype.get(key)返回与 key 关联的值，若不存在关联的值，则返回 undefined。Map.prototype.has(key)返回一个布尔值，用来表明 Map 对象中是否存在与 key 关联的值。Map.prototype.set(key, value)在 Map 对象中设置与指定的键 key 关联的值 value，并返回 Map 对象。Map.prototype.delete(key)移除 Map 对象中指定的键值对，如果键值对存在并成功被移除，返回 true，否则返回 false。调用 delete 后再调用 Map.prototype.has(key) 将返回 false。</code></pre><h3 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h3><p><strong><code>WeakMap</code></strong> 对象是一组键&#x2F;值对的集合，其中的键是弱引用的。其键必须是对象，而值可以是任意的。</p><p>map API <em>可以</em> 通过使其四个 API 方法共用两个数组（一个存放键，一个存放值）来实现。给这种 map 设置值时会同时将键和值添加到这两个数组的末尾。从而使得键和值的索引在两个数组中相对应。当从该 map 取值的时候，需要遍历所有的键，然后使用索引从存储值的数组中检索出相应的值。</p><p>但是存在两个缺点：</p><ol><li>首先赋值和搜索操作都是 <em>O(*n</em>)* 的时间复杂度（<em>n</em> 是键值对的个数），因为这两个操作都需要遍历全部整个数组来进行匹配。</li><li>另外一个缺点是可能会导致内存泄漏，因为数组会一直引用着每个键和值。这种引用使得垃圾回收算法不能回收处理他们，即使没有其他任何引用存在了。</li></ol><p>相比之下，原生的 <code>WeakMap</code> 持有的是每个键对象的“弱引用”，这意味着在没有其他引用存在时垃圾回收能正确进行。原生 <code>WeakMap</code> 的结构是特殊且有效的，其用于映射的 key _只有_在其没有被回收时才是有效的。</p><p><strong>正由于这样的弱引用，<code>WeakMap</code> 的 key 是不可枚举的</strong>（没有方法能给出所有的 key）。如果 key 是可枚举的话，其列表将会受垃圾回收机制的影响，从而得到不确定的结果。因此，如果你想要这种类型对象的 key 值的列表，你应该使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map"><code>Map</code></a>。</p><ul><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/WeakMap/delete"><code>WeakMap.prototype.delete(key)</code></a></p><p>删除 WeakMap 中与 <code>key</code> 相关联的值。删除之后， <code>WeakMap.prototype.has(key)</code> 将会返回 <code>false</code>。</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/WeakMap/get"><code>WeakMap.prototype.get(key)</code></a></p><p>返回 WeakMap 中与 <code>key</code> 相关联的值，如果 <code>key</code> 不存在则返回 <code>undefined</code>。</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/WeakMap/has"><code>WeakMap.prototype.has(key)</code></a></p><p>返回一个布尔值，断言一个值是否已经与 <code>WeakMap</code> 对象中的 <code>key</code> 关联。</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/WeakMap/set"><code>WeakMap.prototype.set(key, value)</code></a></p><p>给 <code>WeakMap</code> 中的 <code>key</code> 设置一个 <code>value</code>。该方法返回一个 <code>WeakMap</code> 对象。</p></li></ul><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><pre class="language-none"><code class="language-none">pop()删除末尾元素 ，返回移除的数组元素；push(ele)末尾添加元素 ele，返回添加后数组的长度；shift()删除首元素并移动数组位置 ，返回添加后数组的长度；unshift(ele)在数组首位置添加元素ele，返回添加后数组的长度；shift() 方法用于把数组的第一个元素从其中删除，并返回第一个元素的值。unshift方法unshift() 方法将一个或多个元素添加到数组的开头，并返回该数组的新长度（该方法修改原有数组）arr.unshift(element1, ..., elementN)返回其 length 属性值Array.isArray(val):判断val是不是数组Array.prototype 属性表示 Array 构造函数的原型，并允许向所有Array对象添加新的属性和方法。或者说，允许利用prototype向任何对象添加属性和方法，从而应用到对象的所有实例上</code></pre><h3 id="遍历操作"><a href="#遍历操作" class="headerlink" title="遍历操作"></a>遍历操作</h3><p>最常用for (var i &#x3D; 0; i &lt; a.length; i++) {<br>    &#x2F;&#x2F; Do something with a[i]<br>}</p><p>for (. of array)：for (const currentValue of a)  {&#x2F;&#x2F; Do something with currentValue}</p><p>for(. in array)：for (var i in a) {&#x2F;&#x2F; 操作 a[i]}遍历索引，如果直接向 Array.prototype 添加了新的属性，使用这样的循环这些属性也同样会被遍历。不推荐这个循环</p><p>forEach()：<br>array.forEach(function(currentValue, index, array) {&#x2F;&#x2F; 操作 currentValue 或者 array[index]});</p><p>注: forEach() 对于空数组是不会执行回调函数的。</p><h3 id="Array-prototype-at"><a href="#Array-prototype-at" class="headerlink" title="Array.prototype.at()"></a><a href="https://link.segmentfault.com/?enc=gIfegOUoZxxLBOg/nmpAvw==.it+TiWVsG0Y95ewedhlKoMS2CPXZSbhECA0MBePgVHbbS3pnn4r95vxFQo8Wnk+rFcIZQbnMXjwFeEBW9uTMx/mnhkJ0ck8W/V9MIZGB4SZb5GqmV1RLVPtXvNkMw7kq">Array.prototype.at()</a></h3><ul><li>返回at中参数指向的index的数组元素，支持负数</li></ul><h3 id="array-prototype-concat"><a href="#array-prototype-concat" class="headerlink" title="array.prototype.concat()"></a>array.prototype.concat()</h3><p>拼接两个数组</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token function">concat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">concat</span><span class="token punctuation">(</span>value0<span class="token punctuation">)</span><span class="token function">concat</span><span class="token punctuation">(</span>value0<span class="token punctuation">,</span> value1<span class="token punctuation">)</span><span class="token function">concat</span><span class="token punctuation">(</span>value0<span class="token punctuation">,</span> value1<span class="token punctuation">,</span> <span class="token comment">/* … ,*/</span> valueN<span class="token punctuation">)</span></code></pre><p><code>valueN</code> 可选</p><p>数组和&#x2F;或值，将被合并到一个新的数组中。如果省略了所有 <code>valueN</code> 参数，则 <code>concat</code> 会返回调用此方法的现存数组的一个浅拷贝。详情请参阅下文描述。</p><h3 id="array-indexOf"><a href="#array-indexOf" class="headerlink" title="array.indexOf"></a>array.indexOf</h3><ul><li>判断数组中是否存在某个值，如果存在返回数组元素的下标，否则返回-1</li></ul><h3 id="array-includes-searchElement-fromIndex"><a href="#array-includes-searchElement-fromIndex" class="headerlink" title="array.includes(searchElement[, fromIndex])"></a>array.includes(searchElement[, fromIndex])</h3><ul><li>判断一个数组是否包含一个指定的值，如果存在返回 true，否则返回false。</li></ul><h3 id="reduce-方法"><a href="#reduce-方法" class="headerlink" title="reduce()方法"></a>reduce()方法</h3><p><strong><code>reduce()</code></strong> 方法对数组中的每个元素按序执行一个由您提供的 <strong>reducer</strong> 函数，每一次运行 <strong>reducer</strong> 会将先前元素的计算结果作为参数传入，最后将其结果汇总为单个返回值。</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript">array<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">total<span class="token punctuation">,</span>currentValue<span class="token punctuation">,</span><span class="token punctuation">[</span>currentIndex<span class="token punctuation">,</span><span class="token punctuation">[</span>arr<span class="token punctuation">]</span><span class="token punctuation">]</span></span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">[</span>initialValue<span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre><p>reduce() 方法接收一个回调函数作为参数，reduce 为数组中的每一个元素依次执行回调函数，回调函数接受四个参数：初始值（或者上一次回调函数的返回值），当前元素值，当前索引，调用 reduce 的数组。<br>reduce方法的返回值为回调函数最后的返回值。</p><p>如果没有提供initialValue，那么reduce的第一轮回调函数中的“total”就arr[0]，“current_Value”就是arr[1]，index就是1；</p><p>如果提供initialValue，那么reduce的第一轮回调函数中的“total”就是initialValue，“current_Value”就是arr[0]，index就是0。</p><p>所以在使用reduce函数时，回调函数中return最好不要省，而且initialValue也最好不要省！！！</p><h3 id="filter-方法"><a href="#filter-方法" class="headerlink" title="filter() 方法"></a>filter() 方法</h3><p>返回一个新数组，其包含通过所提供函数实现的测试的所有元素。 </p><p>var newArray &#x3D; arr.filter(callback(element[, index[, array]])[, thisArg])</p><p>上式中 element 必需，后三者都可选，但没传 index 则 array 也不能传</p><p>注：当所过滤的数组是对象数组的情况时，对新返回的数组元素属性做出修改，同时对原数组也会造成影响；当过滤数组为纯数组时，修改不会改变原数组。也就是浅拷贝</p><h3 id="from方法"><a href="#from方法" class="headerlink" title="from方法"></a>from方法</h3><p>Array.from(arrayLike[, mapFn[, thisArg]])参数分别为伪数组对象或可迭代对象，新数组中的每个元素会执行的回调函数，执行回调函数 mapFn 时 this 对象<br>返回一个新的数组实例。</p><p>Array.from(arrayLike[, mapFunction[, thisArg]])：arrayLike：必传参数，想要转换成数组的伪数组对象或可迭代对象。<br>mapFunction：可选参数，mapFunction(item，index){…} 是在集合中的每个项目上调用的函数。返回的值将插入到新集合中。<br>thisArg：可选参数，执行回调函数 mapFunction 时 this 对象。这个参数很少使用。</p><h3 id="array-map-方法"><a href="#array-map-方法" class="headerlink" title="array.map() 方法"></a>array.map() 方法</h3><p>返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值，按照原始数组元素顺序依次处理元素。<br>array_back&#x3D;array.map(function(currentValue,index,arr), thisValue)</p><p>注：map()方法不会对空数组进行检测；也不会改变原数组</p><p>eg.let arr &#x3D; new Array( 2 ).fill( 0 ).map( _ &#x3D;&gt; new Array( 3 ) ); &#x2F;&#x2F;作用类似C语言：int arr[2][3]</p><h3 id="arr-slice-begin-end"><a href="#arr-slice-begin-end" class="headerlink" title="arr.slice([begin[, end]])"></a>arr.slice([begin[, end]])</h3><ul><li><code>begin</code> 可选，可为负。如果 <code>begin</code> 大于<a href="https://so.csdn.net/so/search?q=%E6%95%B0%E7%BB%84&spm=1001.2101.3001.7020">数组</a>长度，返回空数组。slice(-1) 提取最后一个元素，slice(-2)提取最后两个元素，依次类推。前包后不包。<br><a href="https://so.csdn.net/so/search?q=slice&spm=1001.2101.3001.7020">slice</a>() 返回整个数组。</li></ul><h3 id="array-splice-start-deleteCount-item1-item2-…"><a href="#array-splice-start-deleteCount-item1-item2-…" class="headerlink" title="array.splice(start[, deleteCount[, item1[, item2[, …]]]])"></a>array.splice(start[, deleteCount[, item1[, item2[, …]]]])</h3><ul><li>start 指定修改的开始位置（从 0 计数）。如果超出了数组的长度，则从数组末尾开始添加内容；如果是负值，则表示从数组末位开始的第几位（从 -1 计数，这意味着 -n 是倒数第 n 个元素并且等价于 <code>array.length-n</code>）；如果负数的绝对值大于数组的长度，则表示开始位置为第 0 位。</li><li>deleteCount :整数，表示要移除的数组元素的个数。如果 <code>deleteCount</code> 大于 <code>start</code> 之后的元素的总数，则从 <code>start</code> 后面的元素都将被删除（含第 <code>start</code> 位）。如果 <code>deleteCount</code> 被省略了，或者它的值大于等于<code>array.length - start</code>(也就是说，如果它大于或者等于<code>start</code>之后的所有元素的数量)，那么<code>start</code>之后数组的所有元素都会被删除。如果 <code>deleteCount</code> 是 0 或者负数，则不移除元素。这种情况下，至少应添加一个新元素。</li><li>item:从start位置要添加进数组的元素，不指定时 splice 将只删除元素。</li></ul><p>返回被删除的元素</p><h3 id="arr-sort-compareFn"><a href="#arr-sort-compareFn" class="headerlink" title="arr.sort([compareFn])"></a>arr.sort([compareFn])</h3><p>如果没有指明 <code>compareFn</code> ，那么元素会按照转换为的字符串的诸个字符的 Unicode 位点进行排序。例如 “Banana” 会被排列到 “cherry” 之前。当数字按由小到大排序时，9 出现在 80 之前，但因为（没有指明 <code>compareFn</code>），比较的数字会先被转换为字符串，所以在 Unicode 顺序上 “80” 要比 “9” 要靠前。</p><ul><li>如果 <code>compareFn(a, b)</code> 大于 0 ， b 会被排列到 a 之前。</li><li>如果 <code>compareFn(a, b)</code> 小于 0 ，那么 a 会被排列到 b 之前；</li><li>如果 <code>compareFn(a, b)</code> 等于 0 ， a 和 b 的相对位置不变。备注： ECMAScript 标准并不保证这一行为，而且也不是所有浏览器都会遵守（例如 Mozilla 在 2003 年之前的版本）；</li><li><code>compareFn(a, b)</code> 必须总是对相同的输入返回相同的比较结果，否则排序的结果将是不确定的。</li></ul><h3 id="strArr-join-separator"><a href="#strArr-join-separator" class="headerlink" title="strArr.join(separator)"></a>strArr.join(separator)</h3><ul><li>用输入参数分隔输入字符串数组的每个元素，返回新字符串</li></ul><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>可以直接用比较符号比较字符串</p><h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><p>escape-unescape方法不会对 ASCII 字母和数字进行编码，也不会对下面这些 ASCII 标点符号进行编码： * @ - _ + . &#x2F; 。其他所有的字符都会被转义序列替换。</p><p>encodeURI-decodeURI对以下在 URI 中具有特殊含义的 ASCII 标点符号，encodeURI() 函数是不会进行转义的： , &#x2F; ? : @ &amp; &#x3D; + $ # </p><p>encodeURIComponent-decodeURIComponent该方法不会对 ASCII 字母和数字进行编码，也不会对这些 ASCII 标点符号进行编码： - _ . ! ~ * ‘ ( ) 。其他字符（比如 ：;&#x2F;?:@&amp;&#x3D;+$,# 这些用于分隔 URI 组件的标点符号），都是由一个或多个十六进制的转义序列替换的。</p><p><strong>1、如果只是<a href="https://www.zhihu.com/search?q=%E7%BC%96%E7%A0%81%E5%AD%97%E7%AC%A6%E4%B8%B2&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:20300871%7D">编码字符串</a>，不和URL有半毛钱关系，那么用escape。</strong></p><p><strong>2、如果你需要编码整个URL，然后需要使用这个URL，那么用encodeURI。</strong></p><p>比如</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token function">encodeURI</span><span class="token punctuation">(</span><span class="token string">"http://www.cnblogs.com/season-huang/some other thing"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>编码后会变为</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token string">"http://www.cnblogs.com/season-huang/some%20other%20thing"</span><span class="token punctuation">;</span></code></pre><p>其中，空格被编码成了%20。但是如果你用了encodeURIComponent，那么结果变为</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token string">"http%3A%2F%2Fwww.cnblogs.com%2Fseason-huang%2Fsome%20other%20thing"</span></code></pre><p>看到了区别吗，连 “&#x2F;“ 都被编码了，整个URL已经没法用了。</p><p><strong>3、当你需要编码URL中的参数的时候，那么encodeURIComponent是最好方法。</strong></p><h3 id="String-prototype-charAt-index"><a href="#String-prototype-charAt-index" class="headerlink" title="String.prototype.charAt(index)"></a>String.prototype.charAt(index)</h3><p>指定 <code>index</code> 处字符，参数不在 0 和字符串的 length-1 之间，则返回空字符串</p><h3 id="String-prototype-charCodeAt-index"><a href="#String-prototype-charCodeAt-index" class="headerlink" title="String.prototype.charCodeAt(index)"></a>String.prototype.charCodeAt(index)</h3><p>index：一个大于等于 <code>0</code>，小于字符串长度的整数。如果不是一个数值，则默认为 <code>0</code>。</p><p>返回值：指定 <code>index</code> 处字符的 UTF-16 代码单元值的一个数字；如果 <code>index</code> 超出范围，<code>charCodeAt()</code> 返回 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/NaN"><code>NaN</code></a>。</p><p>如果指定的 <code>index</code> 小于 <code>0</code> 、等于或大于字符串的长度，则 <code>charCodeAt</code> 返回 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/NaN"><code>NaN</code></a>。</p><h3 id="String-fromCharCode"><a href="#String-fromCharCode" class="headerlink" title="String.fromCharCode()"></a>String.fromCharCode()</h3><p>静态 <strong><code>String.fromCharCode()</code></strong> 方法返回由指定的 UTF-16 代码单元序列创建的字符串。</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript">String<span class="token punctuation">.</span><span class="token function">fromCharCode</span><span class="token punctuation">(</span>str<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">charCodeAt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </code></pre><h3 id="indexOf-和-lastIndexOf"><a href="#indexOf-和-lastIndexOf" class="headerlink" title="indexOf() 和 lastIndexOf()"></a>indexOf() 和 lastIndexOf()</h3><p>使用字符串的 indexOf() 和 lastIndexOf() 方法，可以根据参数字符串，返回指定子字符串的下标位置。这两个方法都有两个参数，说明如下。</p><ul><li>第一个参数为一个子字符串，指定要查找的目标。</li><li>第二个参数为一个整数，指定查找的起始位置，取值范围是 0~length-1。</li></ul><p>对于第二个参数来说，需要注意一下几个特殊情况。</p><ul><li>如果值为负数，则视为 0，相当于从第一个字符开始查找。</li><li>如果省略了这个参数，也将从字符串的第一个字符开始查找。</li><li>如果值大于等于 length 属性值，则视为当前字符串中没有指定的子字符串，返回 -1。</li></ul><h3 id="str-match-reg"><a href="#str-match-reg" class="headerlink" title="str.match(reg)"></a>str.match(reg)</h3><p>&#x2F;.&#x2F;g</p><p>方法对字符串对象进行检索,返回包含所有匹配结果的数组。而 正则表达式 &#x2F;.&#x2F;g 匹配的是所有的字符， 所以str.match(&#x2F;.&#x2F;g)返回的是由字符串str中所有的字符组成的数组，以此达到将字符串转换为数组的目的。 </p><h3 id="str-replace-pattern-replacement"><a href="#str-replace-pattern-replacement" class="headerlink" title="str.replace(pattern, replacement)"></a>str.replace(pattern, replacement)</h3><p>两个参数均为字符串，寻找到模式串替换为后者。</p><h3 id="str-search-regexp"><a href="#str-search-regexp" class="headerlink" title="str.search(regexp)"></a>str.search(regexp)</h3><p>返回 str 中给定正则表达式对应索引</p><h3 id="str-slice-a-b"><a href="#str-slice-a-b" class="headerlink" title="str.slice(a,b)"></a>str.slice(a,b)</h3><p>前包后不包；截取出来的字符串的长度为第二个参数与第一个参数之间的差；若参数值为负数,则将该值加上字符串长度后转为正值；若第一个参数等于大于第二个参数,则返回空字符串.</p><h3 id="str-substring-a-b"><a href="#str-substring-a-b" class="headerlink" title="str.substring(a,b)"></a>str.substring(a,b)</h3><p>前包后不包；若参数值为负数,则将该值转为0;两个参数中,取较小值作为开始位置,截取出来的字符串的长度为较大值与较小值之间的差.</p><h3 id="str-split-separator"><a href="#str-split-separator" class="headerlink" title="str.split(separator)"></a>str.split(separator)</h3><p>分割字符串，返回字符数组</p><h3 id="str-substr-a-length"><a href="#str-substr-a-length" class="headerlink" title="str.substr(a,length)"></a>str.substr(a,length)</h3><p>第一个参数代表开始位置,第二个参数代表截取的长度</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="基础-1"><a href="#基础-1" class="headerlink" title="基础"></a>基础</h3><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> <span class="token function-variable function">avg</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token operator">&lt;=</span><span class="token operator">></span><span class="token keyword">function</span> <span class="token function">avg</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token comment">//js创建函数有两种：一是函数声明function fnName () &#123;…&#125;;，二是函数表达式var fnName = function () &#123;…&#125;;前者因 js 具有 函数声明提升 所以定义在任何位置均可成功调用，而后者必须等到定义语句被解释后才能正常调用(与 var 的变量定义提升不同)</span><span class="token comment">//还有一种匿名函数：function () &#123;…&#125;; 使用function关键字声明一个函数，但未给函数命名，所以叫匿名函数，匿名函数属于函数表达式，匿名函数有很多作用，赋予一个变量则创建函数，赋予一个事件则成为事件处理程序或创建闭包等等。</span>函数表达式后面可以加括号立即调用该函数，<span class="token operator">*</span><span class="token function">函数声明不可以，只能以fnName</span><span class="token punctuation">(</span><span class="token punctuation">)</span>形式调用<span class="token operator">*</span> 存疑，在控制台中调用成功。是因为在函数定义前面加了运算符，比如用括号包裹，把它也转换为了表达式。<span class="token function">总结一下就是当把函数定义为表达式时总能在后面加上括号来立即调用。</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token keyword">var</span> <span class="token function-variable function">a</span><span class="token operator">=</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  三者均能立即调用。</code></pre><p>由 <code>Function</code> 构造函数创建的函数不会创建当前环境的闭包，它们总是被创建于全局环境，因此在运行时它们只能访问全局变量和自己的局部变量，不能访问它们被 <code>Function</code> 构造函数创建时所在的作用域的变量。这一点与使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/eval"><code>eval()</code></a> 执行创建函数的代码不同。</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function">too</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">2</span>    <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token function">too</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 1, not 2</span></code></pre><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">lambda</span> x<span class="token punctuation">:</span> x <span class="token operator">*</span> <span class="token number">8</span>let ans<span class="token operator">=</span>x <span class="token operator">=</span><span class="token operator">></span> x<span class="token operator">*</span><span class="token number">8</span><span class="token punctuation">;</span></code></pre><p>js的&#x3D;&gt;符号类似于lambda</p><pre class="language-none"><code class="language-none">&#x3D;&gt;是es6中的arrow function语法(x) &#x3D;&gt; x + 6相当于function(x)&#123;return x + 6;&#125;;const funcname&#x3D;(args)&#x3D;&gt;&#123;...&#125;函数调用：funcname(args)</code></pre><p>eval()函数，参数是一个字符串。如果字符串表示的是表达式，<code>eval()</code> 会对表达式进行求值。如果参数表示一个或多个 JavaScript 语句，那么<code>eval()</code> 就会执行这些语句。如果 <code>eval()</code> 的参数不是字符串， <code>eval()</code> 会将参数原封不动地返回。</p><p>永远不要使用eval()</p><h3 id="回调"><a href="#回调" class="headerlink" title="回调"></a>回调</h3><p>嵌套函数可以访问父函数作用域中的变量，可以利用这个特性减少全局变量的数量，有效地防止“污染”你的全局命名空间——你可以称它为“局部全局（local global）”。换种思路，把全局当作整体函数，那么就能形成作用域链(scope chain)，嵌套者能访问被嵌套者的变量，反之则不行，寻找变量的定义时总是从当前嵌套层或者说从金字塔的当前区域往外(往下)寻找，就近选择。需要注意的是每个函数的金字塔是不同的，在该函数被定义的时候就已经确定了，所以当在函数内部调用之前已定义的函数时，应当回到那个函数的“金字塔”寻找其所需要的变量，当前函数的作用域不会与产生交集。</p><p>头等函数(first-class functions)，可以当作参数被传递的函数。回调函数(callback)是被作为参数传递的函数，注意是函数作为参数，而非函数返回值作为参数，与其对应的是高阶函数，是使用回调函数的函数。</p><p>回调机制包括三方：起始函数，中间函数，回调函数；起始函数调用中间函数，把回调函数作为参数传递给中间函数。起始函数一般是当前运行的主函数，一般隐藏忽略，主要关注回调函数和把回调函数作为参数的中间函数。</p><p>回调实际上有两种：阻塞式回调和延迟式回调。两者的区别在于：阻塞式回调里，回调函数的调用一定发生在起始函数返回之前；而延迟式回调里，回调函数的调用有可能是在起始函数返回之后。</p><h3 id="call、apply和bind"><a href="#call、apply和bind" class="headerlink" title="call、apply和bind"></a>call、apply和bind</h3><p><code>myfunc(...args)&lt;=&gt;myfunc.apply(null,args)</code>展开语法将数组展开为数组元素。<strong>剩余参数</strong>语法允许我们将一个不定数量的参数表示为一个数组，与展开语法恰恰相反，形式为定义函数时<code>function fun1(...theArgs)&#123;alert(theArgs.length);&#125;</code>。剩余参数也可以被解构为包含变量，形式为<code>function f(...[a, b, c]) &#123;return a + b + c;&#125;</code>. </p><p><code>apply()</code> 的第一个参数应该是一个被当作 <code>this</code> 来看待的对象。于是这里是全局对象。</p><p><code>apply()</code> 有一个姐妹函数，名叫 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/call"><code>call</code></a>，它也可以允许你设置 <code>this</code>，但它带有一个扩展的参数列表而不是一个数组。</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>thisArg<span class="token punctuation">,</span> arg1<span class="token punctuation">,</span> arg2<span class="token punctuation">,</span> <span class="token operator">...</span><span class="token punctuation">)</span></code></pre><p>thisArg是函数执行时的 this 对象。call 实现</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">myCall</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">context<span class="token punctuation">,</span><span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 判断调用对象</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token keyword">this</span> <span class="token operator">!==</span> <span class="token string">"function"</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">"Type error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token comment">// 判断 context 是否传入，如果没有传就设置为 window</span>    context <span class="token operator">=</span> context <span class="token operator">||</span> window<span class="token punctuation">;</span>args <span class="token operator">=</span> args <span class="token operator">?</span> args <span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">const</span> key <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    context<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span><span class="token comment">//通过隐式绑定的方式调用函数</span>    result <span class="token operator">=</span> context<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 删除手动增加的属性方法</span>    <span class="token keyword">delete</span> context<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment">// 将执行结果返回</span>    <span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><p>类似的apply实现</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">myApply</span><span class="token operator">=</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">context<span class="token punctuation">,</span>args</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token keyword">this</span> <span class="token operator">!==</span> <span class="token string">"function"</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">"Type error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    args <span class="token operator">=</span> args <span class="token operator">?</span> args <span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> key <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    context<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token operator">=</span><span class="token keyword">this</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> result <span class="token operator">=</span> context<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">delete</span> context<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>bind先返回一个绑定了this的函数，再次执行则在this中执行</p><pre class="language-none"><code class="language-none">var a &#x3D;&#123;name : &quot;Cherry&quot;,fn : function (a,b) &#123;console.log( a + b)&#125;&#125;var b &#x3D; a.fn;b.bind(a,1,2)()           &#x2F;&#x2F; 3</code></pre><p>bind利用apply实现</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">myBind</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">context<span class="token punctuation">,</span> <span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> fn <span class="token operator">=</span> <span class="token keyword">this</span>    args <span class="token operator">=</span> args <span class="token operator">?</span> args <span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token function">newFn</span><span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>newFnArgs</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token keyword">instanceof</span> <span class="token class-name">newFn</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">fn</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">,</span> <span class="token operator">...</span>newFnArgs<span class="token punctuation">)</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token operator">...</span>args<span class="token punctuation">,</span><span class="token operator">...</span>newFnArgs<span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="函数柯里化"><a href="#函数柯里化" class="headerlink" title="函数柯里化"></a>函数柯里化</h3><p>将接受 <strong>n 个参数的 1 个函数改为只接受一个参数的 n 个互相嵌套的函数</strong>，当前置部分参数一致时，可以通过固定前置参数生成指定函数，简化代码。</p><p>对应偏函数是柯里化的宽松情况，不一定需要每一层都只固定一个参数，继承思想即可。</p><h3 id="函数参数的传递"><a href="#函数参数的传递" class="headerlink" title="函数参数的传递"></a>函数参数的传递</h3><p>有值传递和引用传递，基本类型传递值，引用类型(对象)传递对象的地址，如果在函数中对对象重新赋值，则传递进来的地址改变，即在堆中重新分配一段空间，改变传递进来地址的值指向这个新的地址，不影响原对象。</p><pre class="language-none"><code class="language-none">function changeAgeAndReference(person) &#123;    person.age &#x3D; 25;    person &#x3D; &#123;        name: &quot;John&quot;,        age: 50    &#125;;    return person;&#125;var personObj1 &#x3D; &#123;    name: &quot;Alex&quot;,    age: 30&#125;;var personObj2 &#x3D; changeAgeAndReference(personObj1);console.log(personObj1); &#x2F;&#x2F; -&gt; &#123;name: &#39;Alex&#39;, age: 25&#125;console.log(personObj2); &#x2F;&#x2F; -&gt; &#123;name: &#39;John&#39;, age: 50&#125;</code></pre><p>对对象的重新赋值在任何地方都是如此：在动态堆中重新分配内存空间并赋值，再把原地址的值改为新对象的地址。</p><p>当一个对象没有对应地址指向时，也就是上一段中原对象的情况，这个对象的内存地址会被回收，这是js的垃圾回收机制</p><p>“如果连续五次垃圾回收之后，内存占用一次比一次大，就有内存泄漏。这就要求实时查看内存占用。”避免内存泄漏的要点在于往后不会使用的变量要及时赋空。</p><h2 id="闭包、词法环境-作用域"><a href="#闭包、词法环境-作用域" class="headerlink" title="闭包、词法环境(作用域)"></a>闭包、词法环境(作用域)</h2><p>一个函数和对其周围状态（<strong>lexical environment，词法环境</strong>）的引用捆绑在一起（或者说函数被引用包围），这样的组合就是<strong>闭包</strong>（<strong>closure</strong>）。</p><ul><li>用于保存私有属性：将不需要对外暴露的属性、函数保存在闭包函数的父函数里，避免外部操作对值的干扰</li><li>避免局部属性污染全局变量空间导致的命名空间混乱</li><li>模块化封装，将对立的功能模块通过闭包进去封装，只暴露较少的 API 供外部应用使用</li></ul><p>缺点：内存消耗，由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题。</p><p>c语言退出函数时局部变量也会退出其作用域，所以难以创建闭包；js创建函数时会保留其能访问的变量的地址，这也是创建闭包的前提所在。</p><p>词法环境有两大成员：<strong>「Environment Record（环境记录）」</strong>，可能为 null 的 <strong>「Outer Lexical Environment（外部词法环境引用）」</strong>。<strong>任何在环境记录中的标识符都可以在当前词法环境直接以标识符形式访问</strong>。</p><p>Environment Record 是一个抽象类，存在三个具体的子类，<strong>「Declarative Environment Record」</strong> ，<strong>「Object Environment Record」</strong>，<strong>「Global Environment Record（全局环境记录）」</strong></p><p>声明式环境记录保存 let、const、function 等非 var 声明标识符，对象式环境记录保存 var 声明标识符。 </p><h3 id="对象式环境记录"><a href="#对象式环境记录" class="headerlink" title="对象式环境记录"></a>对象式环境记录</h3><p>对象式记录也是用于记录标识符与变量的映射，但是它只记录var声明的标识符 ； 并且它有一个关联的绑定对象(binding object)。</p><ul><li><p>在词法环境中，会为对象式环境记录中所有的标识符绑定到绑定对象的同名属性上。<br>例如var number&#x3D;1000; , 也能够通过window.number形式获取到number的值。</p></li><li><p>反过来也可以，会将绑定对象的所有属性名（自然也必须是能做标识符的）绑定到对象式环境记录中的同名标识符上。<br>例如：window.thousand &#x3D; 1000; 然后直接以 thousand就能获取到该值（严格模式下报错）</p></li><li><p>每个标识符在绑定后都会直接实例化并初始化为undefined ，如果标识符已经绑定了绑定对象上的原有属性上，那么该变量就是对应属性值 。<br>比如之前的isNaN在声明前使用时就有值，就是这个原因。<br>变量提升也是这个原因造成的。</p></li><li><p>如果标识符已经存在，那么无视之，所以var可以重复声明。</p></li></ul><h3 id="声明式环境记录"><a href="#声明式环境记录" class="headerlink" title="声明式环境记录"></a>声明式环境记录</h3><p>同样的，声明式环境记录也比较特殊，它只记录非var声明的标识符，例如let、const、function……声明的标识符等等。并且它没有关联的绑定对象。</p><ul><li><p>所有声明的标识符（这里应该包含var声明的标识符，但不建立关联）都位于此处。</p></li><li><p>将所有非var声明的标识符实例化，但不初始化，也就是变量处于uninitialized状态。也就是说内存中已经为变量预留出空间，但是还没有和对应的标识符建立绑定关系。</p></li><li><p>在执行上下文的运行（perform状态）阶段，并执行到声明语句时，才会真正初始化并默认赋值为undefined。<br>所以你就懂了，let声明的标识符之前无法访问，就是因为还没有建立绑定。<br>暂存死区的根本原因在此。</p></li><li><p>在声明式环境记录中，<strong>不允许出现重复的标识符</strong>，所以它无法重复。甚至和var声明的标识符冲突。注意，它会在代码加载后的预编译阶段（只能说是运行前，因为JS没有真正的预编译啊……）就已经完成。</p></li></ul><p>全局环境记录包含前两者，是底层记录形式，绑定对象为 window 。</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span>b</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">var</span> t <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> sum <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">let</span> sum <span class="token operator">=</span> a<span class="token operator">+</span>b<span class="token punctuation">;</span>        <span class="token keyword">var</span> mul <span class="token operator">=</span> a<span class="token operator">*</span>b <span class="token operator">+</span>sum<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span>  mul<span class="token operator">*</span>t<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">,</span><span class="token number">30</span><span class="token punctuation">)</span> <span class="token comment">// 6500</span><span class="token comment">//词法环境</span>FunctionEnv <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token literal-property property">This</span><span class="token operator">:</span><span class="token operator">&lt;</span>window<span class="token operator">></span>    <span class="token literal-property property">outerEnv</span><span class="token operator">:</span><span class="token operator">&lt;</span>GlobalEnv<span class="token operator">></span><span class="token punctuation">,</span>    <span class="token literal-property property">ObjRec</span><span class="token operator">:</span><span class="token punctuation">&#123;</span>        <span class="token literal-property property">t</span><span class="token operator">:</span><span class="token operator">&lt;</span><span class="token number">10</span><span class="token operator">></span><span class="token punctuation">,</span>        <span class="token literal-property property">mul</span><span class="token operator">:</span><span class="token operator">&lt;</span><span class="token number">650</span><span class="token operator">></span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token literal-property property">DecRec</span><span class="token operator">:</span><span class="token punctuation">&#123;</span>        <span class="token literal-property property">sum</span><span class="token operator">:</span><span class="token operator">&lt;</span><span class="token number">10</span><span class="token operator">></span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>BlockEnv<span class="token operator">=</span><span class="token punctuation">&#123;</span>    <span class="token literal-property property">This</span><span class="token operator">:</span><span class="token operator">&lt;</span>window<span class="token operator">></span><span class="token punctuation">,</span>    <span class="token literal-property property">outerEnv</span><span class="token operator">:</span><span class="token operator">&lt;</span>FunctionEnv<span class="token operator">></span><span class="token punctuation">,</span>    <span class="token literal-property property">DecRec</span><span class="token operator">:</span><span class="token punctuation">&#123;</span>        <span class="token literal-property property">sum</span><span class="token operator">:</span><span class="token operator">&lt;</span><span class="token number">50</span><span class="token operator">></span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>函数属于声明式环境记录是因为存在块级作用域，var 剥离出的环境记录只有全局作用域和函数作用域。</p><p>声明式对应 LexEnv，对象式对应 VarEnv</p><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p>this和new</p><pre class="language-none"><code class="language-none">this 使用在函数中时被用来指向当前调用函数的对象，也即在对象上使用. or [] 访问属性或者方法时，this就相当于这个对象，如果没有. or []依附对象进行直接访问时，this将指向全局对象（global object），也即访问全局属性&#x2F;变量或者方法&#x2F;函数。Global execution context in scripts:this指全局对象-一个名字叫global的对象Global execution context in modules：this返回undefinednew 创建一个崭新的空对象，然后使用指向那个对象的 this 调用特定的函数，修改this对象的属性。如果你没有使用 new 运算符，构造函数会像其他的常规函数一样被调用，并不会创建一个对象。在这种情况下，this 的指向也是不一样的。</code></pre><p>for … in object 可以遍历对象的所有属性，利用全局对象Object的方法keys可以获得属性名数组，例如有对象实例student，Object.keys(student)为student的所有属性名数组。判断对象是否包含某一属性可以用 in ，’keyName’ in objectName 是bool值。当通过类实例化时，虽然方法可以访问，in也报true，但方法不属于对象本身，而是属于类。</p><p>const objectName&#x3D;{}，引用关系不可变，但引用内容可变，意思是仍然可以为对象分配属性。</p><p>类也是对象。js引擎会自动把常量包装成对象，以能使用对应的对象方法。如length等。</p><p>ES6中在对象中添加方法时可以不写key而是直接像下面这样</p><pre class="language-none"><code class="language-none">objectName&#123;...funcName(args...)&#123;...&#125;...&#125;;same asobjectName&#123;...funcName:function(args...)&#123;...&#125;...&#125;;λ-calculus</code></pre><p>以下写法在ES6中合法</p><pre class="language-none"><code class="language-none">let obj&#x3D;&#123;name:&quot;hh&quot;,age:&quot;13&quot;&#125;let &#123;name,age&#125;&#x3D;obj;</code></pre><p><code>Object.defineProperty(object, property, methods)</code></p><p>第一个参数是一个对象，第二个参数是给该对象设置的属性名称，第三个参数是配置该属性的方法，比如set&#x2F;get方法</p><p>在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象。</p><h2 id="防抖节流"><a href="#防抖节流" class="headerlink" title="防抖节流"></a>防抖节流</h2><p>防抖：多次连续触发只执行一次</p><p>节流：一段时间内连续触发只执行一次，冷却时间过了可以继续</p><pre class="language-vue" data-language="vue"><code class="language-vue">&lt;template&gt;    &lt;div id&#x3D;&quot;content&quot;          style&#x3D;&quot;height:150px;                line-height:150px;                text-align:center;                 color: #fff;background-color:black;                font-size:80px;&quot;&gt;    &lt;&#x2F;div&gt;&lt;&#x2F;template&gt; &lt;script&gt;    let num &#x3D; 1;    const content &#x3D; document.getElementById(&#39;content&#39;);    function count() &#123;        content.innerHTML &#x3D; num++;    &#125;;    content.onmousemove &#x3D; count;&#x2F;&#x2F;防抖 非立即执行版function debunce(func,wait,...args)&#123;        let timeout;        return function()&#123;            const context &#x3D; this;            if(timeout) clearTimeout(timeout);            timeout &#x3D; setTimeout(()&#x3D;&gt;&#123;                func.apply(context,args);            &#125;,wait);        &#125;    &#125;    &#x2F;&#x2F;防抖 立即执行    function debunce(func,wait,...args)&#123;        let timeout;        return function()&#123;            const context &#x3D; this;            let callNow &#x3D; !timeout;            if(timeout) clearTimeout(timeout);            timeout &#x3D; setTimeout(()&#x3D;&gt;&#123;                timeout &#x3D; null;            &#125;,wait)            if(callNow) func.apply(context,args);        &#125;    &#125;        &#x2F;&#x2F;节流 时间戳立即执行    function throttle(func,wait,...args)&#123;        let pre&#x3D;0;        return function()&#123;            const context &#x3D; this;            let now &#x3D; Date.now();            if(now-pre&gt;&#x3D;wait)&#123;                func.apply(context,args);                pre&#x3D;Date.now();            &#125;        &#125;    &#125;    &#x2F;&#x2F;节流 延时器延迟执行    function throttle(func,wait,...args)&#123;        let timeout&#x3D;0;        return function()&#123;            const context &#x3D; this;            if(!timeout)&#123;                timeout&#x3D;setTimeout(()&#x3D;&gt;&#123;                    timeout&#x3D;null;                    func.apply(context,args);                &#125;,wait);            &#125;        &#125;    &#125;&lt;&#x2F;script&gt;</code></pre><h2 id="异步和同步"><a href="#异步和同步" class="headerlink" title="异步和同步"></a>异步和同步</h2><p>异步任务分为宏任务和微任务</p><p><strong>宏任务：</strong>script&#x2F;外层同步代码，定时器<code>setTimeout</code>，<code>setInterval</code>，node中的setImmediate，<code>事件绑定</code>，<code>回调函数</code>，<code>node中的fs模块</code></p><p><strong>微任务：</strong><code>new Promise().then(回调)</code>，<code>process.nextTick()</code>，<code>async await</code>,<code>Object.observe</code>,<code>MutaionObserver</code></p><p>Event Loop的执行顺序是：</p><ol><li>首先执行执行栈里的任务。</li><li>执行栈清空后，检查微任务（microtask）队列，将可执行的微任务全部执行。</li><li>取宏任务（macrotask）队列中的第一项执行。</li><li>回到第二步。</li></ol><p>await后面的函数会先执行一遍，然后就会跳出整个async函数来执行后面js栈（后面会详述）的代码。等本轮事件循环执行完了之后又会跳回到async函数中等待await后面表达式的返回值。</p><pre class="language-none"><code class="language-none">console.log(&quot;script start&quot;);async function async1() &#123;  await async2();  console.log(&quot;async1 end&quot;);&#125;async function async2() &#123;  console.log(&quot;async2 end&quot;);&#125;async1();setTimeout(function () &#123;  console.log(&quot;setTimeout&quot;);&#125;, 0);new Promise((resolve) &#x3D;&gt; &#123;  console.log(&quot;Promise&quot;);  resolve();&#125;)  .then(function () &#123;    console.log(&quot;promise1&quot;);  &#125;)  .then(function () &#123;    console.log(&quot;promise2&quot;);  &#125;);console.log(&quot;script end&quot;);&#x2F;&#x2F; script start &#x3D;&gt; async2 end &#x3D;&gt; Promise &#x3D;&gt; script end &#x3D;&gt; async1 end&#x3D;&gt; promise1 &#x3D;&gt; promise2 &#x3D;&gt; setTimeout</code></pre><p>Promise</p><p>第一段调用了Promise构造函数，第二段是调用了promise实例的.then方法。promise的构造函数是同步执行，promise.then中的函数是异步执行。</p><p>promise实例有三种状态：</p><ul><li>pending（待定）</li><li>fulfilled（已执行）&#x2F;或者也可形象地叫做resolved</li><li>rejected（已拒绝）</li></ul><p>调用resolve和reject能将分别将promise实例的状态变成fulfilled和rejected，只有状态变成已完成（即fulfilled和rejected之一），才能触发状态的回调</p><pre class="language-none"><code class="language-none">let p &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;  &#x2F;&#x2F; 做一些事情  &#x2F;&#x2F; 然后在某些条件下resolve，或者reject  if (&#x2F;* 条件随便写^_^ *&#x2F;) &#123;    resolve()  &#125; else &#123;    reject()  &#125;&#125;)p.then(() &#x3D;&gt; &#123;    &#x2F;&#x2F; 如果p的状态被resolve了，就进入这里&#125;, () &#x3D;&gt; &#123;    &#x2F;&#x2F; 如果p的状态被reject&#125;)</code></pre><ul><li><p>多个 then() 链式调用，<strong>并不是连续的创建了多个微任务并推入微任务队列</strong>，因为 then() 的返回值必然是一个 Promise，而后续的 then() 是上一步 then() 返回的 Promise 的回调</p></li><li><p>按照规范</p><pre class="language-arcade" data-language="arcade"><code class="language-arcade">async function async1()&#123;  console.log(&#39;async1 start&#39;)  await async2()  console.log(&#39;async1 end&#39;)&#125;</code></pre><p>可以转化为：</p><pre class="language-arcade" data-language="arcade"><code class="language-arcade">function async1()&#123;  console.log(&#39;async1 start&#39;)  return RESOLVE(async2())      .then(() &#x3D;&gt; &#123; console.log(&#39;async1 end&#39;) &#125;);&#125;</code></pre></li><li><p><code>RESOLVE(p)</code>接近于<code>Promise.resolve(p)</code>，不过有微妙而重要的区别：p 如果本身已经是 Promise 实例，Promise.resolve 会直接返回 p 而不是产生一个新 promise；</p></li><li><p>如果<code>RESOLVE(p)</code>严格按照标准，应该产生一个新的 promise，尽管该 promise 确定会 resolve 为 p，<strong>但这个过程本身是异步的</strong>，也就是现在进入 job 队列的是<strong>新 promise 的 resolve 过程</strong>，所以该 promise 的 then 不会被立即调用，而要等到当前 job 队列执行到前述 resolve 过程才会被调用，然后其回调（也就是继续 await 之后的语句）才加入 job 队列，所以时序上就晚了</p></li><li><p>所以上述的 async1 函数我们可以进一步转换一下：</p><pre class="language-arcade" data-language="arcade"><code class="language-arcade">function async1()&#123;  console.log(&#39;async1 start&#39;)  return new Promise(resolve &#x3D;&gt; resolve(async2()))    .then(() &#x3D;&gt; &#123;      console.log(&#39;async1 end&#39;)    &#125;);&#125;</code></pre></li></ul><h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><p>JSON对象有两个方法。JSON支持三种类型值：简单值（不包括 undefined ，字符串、数字、null，布尔值均可），对象，数组。也没有分号</p><p>JSON.stringify()</p><p>JSON.parse()</p><h2 id="网络请求和远程资源"><a href="#网络请求和远程资源" class="headerlink" title="网络请求和远程资源"></a>网络请求和远程资源</h2><p>Ajax</p><p>asynchronous JavaScript and XML</p><h3 id="XMLHttpRequest对象-XHR"><a href="#XMLHttpRequest对象-XHR" class="headerlink" title="XMLHttpRequest对象-XHR"></a>XMLHttpRequest对象-XHR</h3><p>XHR对象类型</p><pre class="language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>    <span class="token comment">//XMR方法</span>open<span class="token operator">:</span>function(method<span class="token punctuation">,</span>url<span class="token punctuation">,</span>isAsync)<span class="token punctuation">,</span><span class="token comment">//必须首先使用的方法</span>setRequestHeader<span class="token operator">:</span>function(HeaderKey<span class="token operator">:</span>string<span class="token punctuation">,</span>HeaderValue<span class="token operator">:</span>any)<span class="token comment">//自定义发送头部的信息，必须在open之后，send之前调用此函数。需要区别于浏览器正常发送头部，因为部分浏览器允许重写默认头部，某些则会引起错误</span>send<span class="token operator">:</span>function(arg)<span class="token punctuation">,</span><span class="token comment">//参数为请求体数据，不存在请求体时参数需显示设置为 null</span><span class="token comment">//readyState变化时自动调用此函数</span>onreadystatechange<span class="token operator">:</span>function()<span class="token punctuation">,</span><span class="token comment">//获取响应头部信息</span>getResponseHeaders<span class="token operator">:</span>function(headerKey<span class="token operator">:</span>string)<span class="token punctuation">,</span>getAllResponseHeaders()<span class="token operator">:</span>function()<span class="token punctuation">,</span><span class="token comment">//send 方法执行得到返回内容之后，这些属性会被填充</span>responseType<span class="token operator">:</span><span class="token string">""</span><span class="token punctuation">,</span>responseText<span class="token operator">:</span><span class="token string">"string"</span><span class="token punctuation">,</span><span class="token comment">//响应体文本</span>responseXML<span class="token operator">:</span>XML DOM<span class="token punctuation">,</span><span class="token comment">//响应类型为 text/xml 或者 application/xml 时返回的包含响应式数据的 XML DOM 文档</span>status<span class="token operator">:</span>statusCode<span class="token punctuation">,</span><span class="token comment">//响应HTTP状态码 2xx表示成功，304表示资源未修改，直接从浏览器缓存读取，此两种情况都表示响应有效</span>statusText<span class="token operator">:</span>'description'<span class="token punctuation">,</span><span class="token comment">//HTTP状态描述信息</span><span class="token comment">//状态属性</span>readyState<span class="token operator">:</span><span class="token number">0</span>|<span class="token number">1</span>|<span class="token number">2</span>|<span class="token number">3</span>|<span class="token number">4</span><span class="token punctuation">,</span><span class="token comment">//五种状态，0表示未调用 open 方法，未初始化，1表示已 open 但未 send，2表示 sent 但未收到响应，3表示收到部分响应 receiving ，4表示完成，已收到所有响应 complete。</span><span class="token comment">//收到响应之前可调用此方法终止异步请求，同时应当取消对该XHR对象的引用</span>abort<span class="token operator">:</span>function()<span class="token punctuation">,</span><span class="token punctuation">&#125;</span></code></pre><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//创建XHR对象</span><span class="token keyword">let</span> xhr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XMLHttpRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//使用XMR对象</span><span class="token comment">//首先必须使用open方法，三个参数依次是请求类型：string，请求URL：string，是否异步：Boolean；这里的URL是相对于代码所在的页面的，必须遵守同源策略（同一域名，同一端口，同一协议），否则抛出安全错误。</span>xhr<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">'get'</span><span class="token punctuation">,</span><span class="token string">'example.com'</span><span class="token punctuation">,</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>xhr<span class="token punctuation">.</span><span class="token function">setRequestHeader</span><span class="token punctuation">(</span><span class="token string">'myHaeder'</span><span class="token punctuation">,</span><span class="token string">'myValue'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>xhr<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>send时XHR默认会发送的头部字段：</p><ul><li>Accept 浏览器可以处理的内容类型</li><li>Accept-Charset 浏览器支持显示的字符集</li><li>Accept-Encoding 浏览器可以处理的压缩编码类型</li><li>Accept-Language 浏览器使用的语言</li><li>Connection 浏览器与服务器的连接类型</li><li>Cookie 页面中设置的Cookie</li><li>Host 发送请求的页面所在的域</li><li>Referer 发送请求的页面的 URL ，将错就错，正确拼法是 referre</li><li>User-Agent 浏览器的用户代理字符串</li></ul><h4 id="Get请求"><a href="#Get请求" class="headerlink" title="Get请求"></a>Get请求</h4><p>The <code>encodeURIComponent()</code> method <strong>encodes</strong> a URI component. Use the <a href="https://www.w3schools.com/jsref/jsref_decodeuricomponent.asp">decodeURIComponent()</a> function to <strong>decode</strong> an encoded URI component.</p><h4 id="Post请求"><a href="#Post请求" class="headerlink" title="Post请求"></a>Post请求</h4><h3 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h3><p>跨域资源共享 Cross-origin Resource Share使用场景：</p><ul><li>由 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest"><code>XMLHttpRequest</code></a> 或 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API">Fetch APIs</a> 发起的跨源 HTTP 请求。</li><li>Web 字体 (CSS 中通过 <code>@font-face</code> 使用跨源字体资源)，<a href="https://www.w3.org/TR/css-fonts-3/#font-fetching-requirements">因此，网站就可以发布 TrueType 字体资源，并只允许已授权网站进行跨站调用</a>。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/WebGL_API/Tutorial/Using_textures_in_WebGL">WebGL 贴图</a></li><li>使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/drawImage"><code>drawImage</code></a> 将 Images&#x2F;video 画面绘制到 canvas。</li><li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Shapes/Shapes_From_Images">来自图像的 CSS 图形 (en-US)</a></li></ul><p>跨源资源共享标准新增了一组 HTTP 首部字段，允许服务器声明哪些源站通过浏览器有权限访问哪些资源。另外，规范要求，对那些可能对服务器数据产生副作用的 HTTP 请求方法（特别是 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/GET"><code>GET</code></a> 以外的 HTTP 请求，或者搭配某些 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/MIME_types">MIME 类型</a> 的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/POST"><code>POST</code></a> 请求），浏览器必须首先使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/OPTIONS"><code>OPTIONS</code></a> 方法发起一个预检请求（preflight request），从而获知服务端是否允许该跨源请求。服务器确认允许之后，才发起实际的 HTTP 请求。在预检请求的返回中，服务器端也可以通知客户端，是否需要携带身份凭证（包括 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Cookies">Cookies</a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Authentication">HTTP 认证</a> 相关数据）。</p><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>setInterval();  指每隔多少毫秒执行一次函数。因此它有两个参数，第一个参数为每次执行的函数，第二个参数为毫秒。如setInterval( fn, 16 )，返回值为id，用于标识一个setInterval调用。 </p><p>setTimeout() 方法只运行一次，也就是说当达到设定的时间后就开始运行指定的代码，运行完后就结束了，次数是一次。 setInterval() 是循环执行的，即每达到指定的时间间隔就执行相应的函数或者表达式，只要窗口不关闭或clearInterval() 调用就会无限循环下去。</p><p>date对象，包含一系列获取时间的方法</p><h2 id="Control-abstraction-objects"><a href="#Control-abstraction-objects" class="headerlink" title="Control abstraction objects"></a><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects#control_abstraction_objects">Control abstraction objects</a></h2><p>控制抽象对象</p><ul><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise"><code>Promise</code></a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator"><code>Generator</code></a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/GeneratorFunction"><code>GeneratorFunction</code></a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/AsyncFunction"><code>AsyncFunction</code></a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/AsyncGenerator"><code>AsyncGenerator</code></a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/AsyncGeneratorFunction"><code>AsyncGeneratorFunction</code></a></li></ul><h2 id="Reflection"><a href="#Reflection" class="headerlink" title="Reflection"></a>Reflection</h2><p><strong>Proxy</strong> 对象用于创建一个对象的代理，从而实现基本操作的拦截和自定义（如属性查找、赋值、枚举、函数调用等）。</p><pre class="language-none"><code class="language-none">const p &#x3D; new Proxy(target, handler)handler 包含捕捉器（trap）的占位符对象，可译为处理器对象。traps提供属性访问的方法。这类似于操作系统中捕获器的概念。target被 Proxy 代理虚拟化的对象。它常被作为代理的存储后端。根据目标验证关于对象不可扩展性或不可配置属性的不变量（保持不变的语义）。</code></pre><p><strong><code>Proxy.revocable()</code></strong> 方法可以用来创建一个可撤销的代理对象。细节见<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy/revocable">此处</a>。</p><pre class="language-none"><code class="language-none">Proxy.revocable(target, handler);</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;持续更新&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;基础&quot;&gt;&lt;a href=&quot;#基础&quot; class=&quot;headerlink&quot; title=&quot;基础&quot;&gt;&lt;/a&gt;基础&lt;/h2&gt;&lt;pre class=&quot;language-none&quot;&gt;&lt;code c</summary>
      
    
    
    
    <category term="常用编程语言基础知识" scheme="https://hhumar.com/categories/%E5%B8%B8%E7%94%A8%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="JavaScript" scheme="https://hhumar.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>回来咯</title>
    <link href="https://hhumar.com/2022/10/25/hello-world/"/>
    <id>https://hhumar.com/2022/10/25/hello-world/</id>
    <published>2022-10-25T07:37:56.643Z</published>
    <updated>2022-10-31T01:54:28.172Z</updated>
    
    <content type="html"><![CDATA[<h2 id="杂谈"><a href="#杂谈" class="headerlink" title="杂谈"></a>杂谈</h2><p>老早之前就建好这个站了，不过嫌弃默认样式太丑又不会自定义，所以就没一直用下去</p><p>这次学了一点前端回来捡起来这个站，当作一个安全的备份记录的地方，希望能早点把真真正正自己写的网站弄出来，暂时把这里当作主要阵地。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;杂谈&quot;&gt;&lt;a href=&quot;#杂谈&quot; class=&quot;headerlink&quot; title=&quot;杂谈&quot;&gt;&lt;/a&gt;杂谈&lt;/h2&gt;&lt;p&gt;老早之前就建好这个站了，不过嫌弃默认样式太丑又不会自定义，所以就没一直用下去&lt;/p&gt;
&lt;p&gt;这次学了一点前端回来捡起来这个站，当作一个安全的</summary>
      
    
    
    
    <category term="生活" scheme="https://hhumar.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
    <category term="first in all" scheme="https://hhumar.com/tags/first-in-all/"/>
    
  </entry>
  
</feed>
