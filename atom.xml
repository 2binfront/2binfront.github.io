<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>hh-blog</title>
  
  <subtitle>Learning</subtitle>
  <link href="https://hhumar.com/atom.xml" rel="self"/>
  
  <link href="https://hhumar.com/"/>
  <updated>2022-11-01T17:15:14.475Z</updated>
  <id>https://hhumar.com/</id>
  
  <author>
    <name>hh</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>前端基础</title>
    <link href="https://hhumar.com/2022/11/02/Frontend/"/>
    <id>https://hhumar.com/2022/11/02/Frontend/</id>
    <published>2022-11-01T16:40:14.000Z</published>
    <updated>2022-11-01T17:15:14.475Z</updated>
    
    <content type="html"><![CDATA[<h2 id="web基础知识"><a href="#web基础知识" class="headerlink" title="web基础知识"></a>web基础知识</h2><h3 id="url到页面"><a href="#url到页面" class="headerlink" title="url到页面"></a>url到页面</h3><p>浏览器中的进程</p><table><thead><tr><th>进程</th><th>说明</th></tr></thead><tbody><tr><td>浏览器进程</td><td>负责浏览器各个子进程的通信，处理浏览器界面，包括地址栏等</td></tr><tr><td>渲染进程</td><td>也就是我们看到的图中的标签页进程，也就是我们常说的浏览器内核，v8就在这个进程。主要负责解析html、js、css渲染页面等</td></tr><tr><td>网络进程</td><td>负责发起网络请求，解析返回头信息</td></tr><tr><td>GUI进程</td><td>负责将渲染进程生成的图块转化成位图</td></tr><tr><td>插件进程</td><td></td></tr></tbody></table><p>从输入页面URL到页面渲染完成大致流程为：</p><ul><li><p>地址栏输入信息处理</p><p>判断输入信息是检索信息还是请求URL</p><ul><li>如果是检索的信息，就构建请求搜索的URL，调用浏览器默认的搜索引擎进行检索。</li><li>如果符合URL格式，浏览器主进程就通过IPC通信机制将URL发送给网络进程。<a href="https://www.jianshu.com/p/c1015f5ffa74">进程间通信IPC (InterProcess Communication)</a></li></ul></li><li><p>网络进程发起网络请求</p><ul><li>解析URL，解码</li><li>查找浏览器本地缓存</li><li>无缓存则DNS解析</li><li>建立TCP&#x2F;IP连接</li><li>发送HTTP请求</li><li>服务器处理请求并返回HTTP报文</li></ul></li><li><p>服务器返回对应资源</p><ul><li>浏览器接收到服务器返回的资源信息，网络进程首先会解析返回的头信息，查看是否有Location字段，如果有的话，再次发起请求，常见例子：请求http的站点，然后重定向到https。</li><li>通过返回头字段<code>Content-Type</code>判断文件类型，如果其他类型，就调用不同的进程处理，如果是html类型，继续处理。</li><li>浏览器根据深度遍历的方式把html节点遍历构建DOM树</li><li>遇到CSS外链，异步加载解析CSS，构建CSS规则树</li><li><strong>遇到script标签，如果是普通JS标签则同步加载并执行，阻塞页面渲染，如果标签上有defer &#x2F; async属性则异步加载JS资源</strong></li><li>将dom树和CSS DOM树构造成render树</li><li>渲染render树</li></ul></li><li><p>四次挥手，资源传输完毕，断开连接</p></li></ul><p><img src="/2022/11/02/Frontend/%E6%B8%B2%E6%9F%93%E8%BF%9B%E7%A8%8B.png" alt="渲染进程"></p><h3 id="MIME类型"><a href="#MIME类型" class="headerlink" title="MIME类型"></a>MIME类型</h3><table><thead><tr><th><code>text</code></th><th>表明文件是普通文本，理论上是人类可读</th><th><code>text/plain</code>, <code>text/html</code>, <code>text/css, text/javascript</code></th></tr></thead><tbody><tr><td><code>image</code></td><td>表明是某种图像。不包括视频，但是动态图（比如动态 gif）也使用 image 类型</td><td><code>image/gif</code>, <code>image/png</code>, <code>image/jpeg</code>, <code>image/bmp</code>, <code>image/webp</code>, <code>image/x-icon</code>, <code>image/vnd.microsoft.icon</code></td></tr><tr><td><code>audio</code></td><td>表明是某种音频文件</td><td><code>audio/midi</code>, <code>audio/mpeg, audio/webm, audio/ogg, audio/wav</code></td></tr><tr><td><code>video</code></td><td>表明是某种视频文件</td><td><code>video/webm</code>, <code>video/ogg</code></td></tr><tr><td><code>application</code></td><td>表明是某种二进制数据</td><td><code>application/octet-stream</code>, <code>application/pkcs12</code>, <code>application/vnd.mspowerpoint</code>, <code>application/xhtml+xml</code>, <code>application/xml</code>, <code>application/pdf</code></td></tr></tbody></table><p>由类型与子类型两个字符串中间用<code>&#39;/&#39;</code>分隔而组成。不允许空格存在。不敏感大小写。</p><p>对于 text 文件类型若没有特定的 subtype，就使用 <code>text/plain</code>。类似的，二进制文件没有特定或已知的 subtype，即使用 <code>application/octet-stream</code>。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/MIME_types#applicationoctet-stream">application&#x2F;octet-stream</a>这是应用程序文件的默认值。意思是 <em>未知的应用程序文件 ，</em>浏览器一般不会自动执行或询问执行。</p><p>text&#x2F;plain文本文件默认值。即使它<em>意味着未知的文本文件</em>，但浏览器认为是可以直接展示的。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/MIME_types#textjavascript">text&#x2F;javascript </a> text&#x2F;html text&#x2F;css</p><p><code>multipart/byteranges</code> 用于把部分的响应报文发送回浏览器</p><h3 id="session和cookie、token"><a href="#session和cookie、token" class="headerlink" title="session和cookie、token"></a>session和cookie、token</h3><p>Session（会话机制，能识别哪个请求由哪个用户发起的机制，生成的能识别用户身份信息的字符串称为 sessionId）是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中；</p><p><strong>客户端请求后，由<a href="https://www.zhihu.com/search?q=%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%99%A8&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2064471064%7D">负载均衡器</a>（如 Nginx）来决定到底打到哪台机器</strong></p><p>对应三种解决方案：</p><ul><li>session复制：所有服务器都有，都一样，性能消耗大，冗余大</li><li>session粘连：不同的session（根据ID）放在不同机器上，可靠性低</li><li>session共享：将 session 保存在 redis，<a href="https://www.zhihu.com/search?q=memcached&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2064471064%7D">memcached</a> 等中间件中，请求到来时，各个机器去这些中间件取一下 session ，多了一次内部连接，消耗了一点性能</li></ul><p>Cookie是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现Session的一种方式。每当客户端要与服务端通信时，附送 cookie 可以让服务端识别用户身份，找到对应用户之前保留在服务端的信息。一般由第一次客户端访问服务端时，服务端生成并发送给客户端。</p><p>token：请求方输入自己的用户名，密码，然后 server 据此生成 token，客户端拿到 token 后会保存到本地，之后向 server 请求时在请求头带上此 token 即可。</p><ul><li>server 会有一套校验机制，校验这个 token 是否合法。</li><li>token 本身可以带 uid 信息，解密后就可以获取</li></ul><p>jwt token 主要由三部分组成 ——base64编码</p><ol><li>header：指定了签名算法 </li><li>payload：可以指定用户 id，过期时间等非敏感数据 </li><li>Signature: 签名，server 根据 header 知道它该用哪种签名算法，再用密钥根据此签名算法对 head + payload 生成签名，这样一个 token 就生成了。</li></ol><p>Token 一般是放在 header 的 Authorization 自定义头里，不是放在 Cookie 里的，这主要是为了解决跨域不能共享 Cookie 的问题 ——单点登录SSO，向其中一个网站发送请求，获得token，可以用该token发送给其它信任组网站，方便快捷。</p><p>缺点：太长了，不太安全，<strong>适合一次性的命令认证，设置一个比较短的有效期</strong></p><p>CSRF 攻击的根本原因在于对于同样域名的每个请求来说，它的 cookie 都会被自动带上，这个是浏览器的机制决定的，所以很多人据此认定 cookie 不安全。<em>CSRF</em>（<em>Cross-site request forgery</em>）跨站请求伪造</p><p>cookie和token都保存在local storage，会被js读取，前者是存储方式，后者是验证方式</p><h3 id="浏览器缓存"><a href="#浏览器缓存" class="headerlink" title="浏览器缓存"></a>浏览器缓存</h3><p>在浏览器中，浏览器会在js和图片等文件解析执行后直接存入内存缓存中，那么当刷新页面时只需直接从内存缓存中读取；而css文件则会存入硬盘文件中，所以每次渲染页面都需要从硬盘读取缓存。</p><p><img src="/2022/11/02/Frontend/web%E7%BC%93%E5%AD%98%E7%B1%BB%E5%9E%8B.png" alt="web缓存类型"></p><p>所谓浏览器缓存其实就是指在本地使用的计算机中开辟一个内存区，同时也开辟一个硬盘区作为数据传输的缓冲区，然后用这个缓冲区来暂时保存用户以前访问过的信息。</p><h4 id="Web-Storage"><a href="#Web-Storage" class="headerlink" title="Web Storage"></a>Web Storage</h4><ul><li><code>sessionStorage</code> 为每一个给定的源（given origin）维持一个独立的存储区域，该存储区域在页面会话期间可用（即只要浏览器处于打开状态，包括页面重新加载和恢复）。</li><li><code>localStorage</code> 同样的功能，但是在浏览器关闭，然后重新打开后数据仍然存在。</li></ul><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//以下均可设置localStorage</span>localStorage<span class="token punctuation">.</span>colorSetting <span class="token operator">=</span> <span class="token string">'#a4509b'</span><span class="token punctuation">;</span>localStorage<span class="token punctuation">[</span><span class="token string">'colorSetting'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'#a4509b'</span><span class="token punctuation">;</span>localStorage<span class="token punctuation">.</span><span class="token function">setItem</span><span class="token punctuation">(</span><span class="token string">'colorSetting'</span><span class="token punctuation">,</span> <span class="token string">'#a4509b'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>storage常用方法</p><pre class="language-none"><code class="language-none">Storage.key()该方法接受一个数值 n 作为参数，并返回存储中的第 n 个键名。Storage.getItem()该方法接受一个键名作为参数，返回键名对应的值。Storage.setItem()该方法接受一个键名和值作为参数，将会把键值对添加到存储中，如果键名存在，则更新其对应的值。Storage.removeItem()该方法接受一个键名作为参数，并把该键名从存储中删除。Storage.clear()调用该方法会清空存储中的所有键名。</code></pre><p>浏览器缓存细节：</p><ul><li>浏览器每次发起请求，都会<code>先在浏览器缓存中查找该请求的结果以及缓存标识</code></li><li>浏览器每次拿到返回的请求结果都会<code>将该结果和缓存标识存入浏览器缓存中</code></li></ul><p>强制缓存和协商缓存情况：</p><ul><li>浏览器请求在缓存中找不到缓存结果和缓存标识，则向服务器请求文件，服务器返回文件同时带上缓存标识，客户端把文件缓存到浏览器缓存中，此时是强制缓存范畴。</li><li>浏览器请求在缓存中能找到缓存结果和标识但已经过期，于是携带缓存标识向服务器请求，服务器决定客户端的浏览器缓存是否仍然可用有两种情况：<ul><li>仍可用，返回304，客户端再到浏览器缓存请求读取，返回。</li><li>不可用，返回200和请求结果，客户端再更新浏览器缓存。</li></ul></li><li>能找到浏览器缓存结果和标识且未过期，直接使用。-强制缓存</li></ul><h4 id="强制缓存中的HTTP响应报文字段："><a href="#强制缓存中的HTTP响应报文字段：" class="headerlink" title="强制缓存中的HTTP响应报文字段："></a>强制缓存中的HTTP响应报文字段：</h4><p>expires 和 cache-control，作用相似，后者优先级高</p><ul><li><h5 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h5><p>Expires是HTTP&#x2F;1.0控制网页缓存的字段，其值为服务器返回该请求结果<code>缓存的到期时间</code>，即再次发起该请求时，如果客户端的时间小于Expires的值时，直接使用缓存结果。</p></li><li><h5 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h5><p>在HTTP&#x2F;1.1中，Cache-Control是最重要的规则，主要用于控制网页缓存，主要取值为：</p><ul><li>public：所有内容都将被缓存（客户端和代理服务器都可缓存）</li><li>private：所有内容只有客户端可以缓存，Cache-Control的默认取值</li><li>no-cache：客户端缓存内容，但是是否使用缓存则需要经过协商缓存来验证决定</li><li>no-store：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存</li><li>max-age&#x3D;xxx (xxx is numeric)：缓存内容将在xxx秒后失效</li></ul></li></ul><h4 id="协商缓存的两对字段："><a href="#协商缓存的两对字段：" class="headerlink" title="协商缓存的两对字段："></a>协商缓存的两对字段：</h4><p>Last-Modified &#x2F; If-Modified-Since和 Etag &#x2F; If-None-Match，两对中的每一对的两个字段分别为响应header字段和请求header字段，后面这一对优先级高</p><ul><li><p>Last-Modified &#x2F; If-Modified-Since</p><p>Last-Modified 是服务器响应报文中记录返回资源最后在服务器中修改时间是的值， If-Modified-Since 是客户端在浏览器缓存中找到的已过期缓存的 Last-Modified 值，携带向服务器请求资源，服务器检查 If-Modified-Since 记录的值是否和自身对应资源的 Last-Modified 相同，如果相同返回304未更改，不相同则返回200和新资源及Last-Modified。</p></li><li><p>Etag &#x2F; If-None-Match</p><p>Etag 是服务器响应报文返回资源的唯一标识，If-None-Match 是客户端请求向服务器时携带的对应资源在浏览器缓存中记录的 Etag，该资源在浏览器缓存中已过期。服务器收到后比对 If-None-Match 和服务器资源 Etag 是否相同，相同则返回304资源未修改，否则返回200和新资源及对应新 Etag。</p></li></ul><h4 id="刷新对于强缓存和协商缓存的影响"><a href="#刷新对于强缓存和协商缓存的影响" class="headerlink" title="刷新对于强缓存和协商缓存的影响"></a>刷新对于强缓存和协商缓存的影响</h4><ol><li>当ctrl+f5强制刷新网页时，直接从服务器加载，跳过强缓存和协商缓存。</li><li>当f5刷新网页时，跳过强缓存，但是会检查协商缓存。</li><li>浏览器地址栏中写入URL，回车 浏览器发现缓存中有这个文件了，不用继续请求了，直接去缓存拿。（最快）</li></ol><h3 id="Location"><a href="#Location" class="headerlink" title="Location"></a>Location</h3><p>http中的头部字段</p><p><strong><code>Location</code></strong> 首部指定的是需要将页面重新定向至的地址。一般在响应码为 3xx 的响应中才会有意义。</p><p>发送新请求，获取 Location 指向的新页面所采用的方法与初始请求使用的方法以及重定向的类型相关：</p><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/303"><code>303</code></a> (See Also) 始终引致请求使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/GET"><code>GET</code></a> 方法，而，而 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/307"><code>307</code></a> (Temporary Redirect) 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/308"><code>308</code></a> (Permanent Redirect) 则不转变初始请求中的所使用的方法；</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/301"><code>301</code></a> (Permanent Redirect) 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/302"><code>302</code></a> (Found) 在大多数情况下不会转变初始请求中的方法，不过一些比较早的用户代理可能会引发方法的变更（所以你基本上不知道这一点）。</li></ul><p>状态码为上述之一的所有响应都会带有一个 Location 首部。</p><p>除了重定向响应之外，状态码为 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/201"><code>201</code></a> (Created) 的消息也会带有 Location 首部。它指向的是新创建的资源的地址。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Location"><code>Location</code></a> 与 <code>Content-Location</code>是不同的，前者（<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Location"><code>Location</code></a> ）指定的是一个重定向请求的目的地址（或者新创建的文件的 URL），而后者（ <code>Content-Location</code>）指向的是经过内容协商后的资源的直接地址，不需要进行进一步的内容协商。Location 对应的是响应，而 Content-Location 对应的是要返回的实体。</p><h3 id="网络安全"><a href="#网络安全" class="headerlink" title="网络安全"></a>网络安全</h3><h4 id="跨域攻击"><a href="#跨域攻击" class="headerlink" title="跨域攻击"></a>跨域攻击</h4><p><strong>Cross-site request forgery</strong>, also known as <strong>one-click attack</strong> or <strong>session riding</strong> and abbreviated as <strong>CSRF</strong> (sometimes pronounced <em>sea-surf</em>[<a href="https://en.wikipedia.org/wiki/Cross-site_request_forgery#cite_note-Shiflett-1">1]</a>) or <strong>XSRF</strong>, is a type of malicious <a href="https://en.wikipedia.org/wiki/Exploit_(computer_security)">exploit</a> of a <a href="https://en.wikipedia.org/wiki/Website">website</a> where unauthorized commands are submitted from a <a href="https://en.wikipedia.org/wiki/User_(computing)">user</a> that the web application trusts.</p><p><strong>CSRF</strong>&#x2F;<strong>XSRF</strong></p><p>同源策略：同域名、同协议、同端口</p><h4 id="内容安全策略"><a href="#内容安全策略" class="headerlink" title="内容安全策略"></a>内容安全策略</h4><p>content-security-policy</p><p>配置内容安全策略涉及到添加 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Security-Policy"><code>Content-Security-Policy</code></a> HTTP 头部到一个页面，并配置相应的值，以控制用户代理（浏览器等）可以为该页面获取哪些资源。</p><p>一个策略由一系列策略指令所组成，每个策略指令都描述了一个针对某个特定类型资源以及生效范围的策略。你的策略应当包含一个<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Security-Policy/default-src"><code>default-src</code></a>策略指令，在其他资源类型没有符合自己的策略时应用该策略 (有关完整列表查看<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Security-Policy/default-src"><code>default-src</code></a> )。一个策略可以包含 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Security-Policy/default-src"><code>default-src</code></a> 或者 <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/script-src">script-src (en-US)</a> 指令来防止内联脚本运行，并杜绝<code>eval()</code>的使用。 一个策略也可包含一个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Security-Policy/default-src"><code>default-src</code></a> 或 <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/style-src">style-src </a> 指令去限制来自一个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/style"><code>style</code></a> 元素或者 style 属性的內联样式。</p><p>例如：</p><p>一个网站管理者想要所有内容均来自站点的同一个源 (不包括其子域名)</p><pre class="language-none"><code class="language-none">Content-Security-Policy: default-src &#39;self&#39;</code></pre><p>一个网站管理者允许内容来自信任的域名及其子域名 (域名不必须与 CSP 设置所在的域名相同)</p><pre class="language-none"><code class="language-none">Content-Security-Policy: default-src &#39;self&#39; *.trusted.com</code></pre><p>一个网站管理者允许网页应用的用户在他们自己的内容中包含来自任何源的图片，但是限制音频或视频需从信任的资源提供者 (获得)，所有脚本必须从特定主机服务器获取可信的代码。</p><pre class="language-none"><code class="language-none">Content-Security-Policy: default-src &#39;self&#39;; img-src *; media-src media1.com media2.com; script-src userscripts.example.com</code></pre><p>在这里，各种内容默认仅允许从文档所在的源获取，但存在如下例外：</p><ul><li>图片可以从任何地方加载 (注意 “*” 通配符)。</li><li>多媒体文件仅允许从 media1.com 和 media2.com 加载 (不允许从这些站点的子域名)。</li><li>可运行脚本仅允许来自于 userscripts.example.com。</li></ul><p>一个线上银行网站的管理者想要确保网站的所有内容都要通过 SSL 方式获取，以避免攻击者窃听用户发出的请求。</p><pre class="language-none"><code class="language-none">Content-Security-Policy: default-src https:&#x2F;&#x2F;onlinebanking.jumbobank.com</code></pre><p>该服务器仅允许通过 HTTPS 方式并仅从<code>onlinebanking.jumbobank.com</code>域名来访问文档。</p><p>类似的有Content-Security-Policy-Report-Only头部信息，做测试用途，不会阻止访问但会发送违规信息到 report-uri 指令内容的地址。这意味着两种头部启用报告功能需要在指令中加上 report-uri ，但不加 Report-Only 不仅会发送报告也能同时阻止访问。</p><p>可以有效防止XSS(cross-site scripting)攻击和数据注入攻击。</p><h4 id="OWASP"><a href="#OWASP" class="headerlink" title="OWASP"></a>OWASP</h4><p>是Open Web Application Security Project的缩写，它是一个在线社区，在网络应用安全领域发表文章、方法、文档、工具和技术。</p><p>The Top 10 OWASP vulnerabilities in 2021 are:</p><ul><li>Injection</li><li>Broken authentication</li><li>Sensitive data exposure</li><li>XML external entities (XXE)</li><li>Broken access control</li><li>Security misconfigurations</li><li>Cross site scripting (XSS)</li><li>Insecure deserialization</li><li>Using components with known vulnerabilities</li><li>Insufficient logging and monitoring</li></ul><p><a href="https://sucuri.net/guides/owasp-top-10-security-vulnerabilities-2020/">https://sucuri.net/guides/owasp-top-10-security-vulnerabilities-2020/</a></p><h2 id="http相关"><a href="#http相关" class="headerlink" title="http相关"></a>http相关</h2><h3 id="cookie操作"><a href="#cookie操作" class="headerlink" title="cookie操作"></a>cookie操作</h3><p>服务器使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Set-Cookie"><code>Set-Cookie</code></a> 响应头部向用户代理（一般是浏览器）发送 Cookie 信息。一个简单的 Cookie 可能像这样：</p><pre class="language-none"><code class="language-none">Set-Cookie: &lt;cookie 名&gt;&#x3D;&lt;cookie 值&gt;</code></pre><p>服务器响应信息，该头部告知客户端保存 Cookie 信息。</p><pre class="language-none"><code class="language-none">HTTP&#x2F;1.0 200 OKContent-type: text&#x2F;htmlSet-Cookie: yummy_cookie&#x3D;chocoSet-Cookie: tasty_cookie&#x3D;strawberry[页面内容]</code></pre><p>现在，对该服务器发起的每一次新请求，浏览器都会将之前保存的 Cookie 信息通过 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cookie"><code>Cookie</code></a> 请求头部再发送给服务器。</p><pre class="language-none"><code class="language-none">GET &#x2F;sample_page.html HTTP&#x2F;1.1Host: www.example.orgCookie: yummy_cookie&#x3D;choco; tasty_cookie&#x3D;strawberry</code></pre><h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><p>Cookie 的生命周期可以通过两种方式定义：</p><ul><li>会话期 Cookie 是最简单的 Cookie：浏览器关闭之后它会被自动删除，也就是说它仅在会话期内有效。会话期 Cookie 不需要指定过期时间（<code>Expires</code>）或者有效期（<code>Max-Age</code>）。需要注意的是，有些浏览器提供了会话恢复功能，这种情况下即使关闭了浏览器，会话期 Cookie 也会被保留下来，就好像浏览器从来没有关闭一样，这会导致 Cookie 的生命周期无限期延长。</li><li>持久性 Cookie 的生命周期取决于过期时间（<code>Expires</code>）或有效期（<code>Max-Age</code>）指定的一段时间。</li></ul><pre class="language-none"><code class="language-none">Set-Cookie: id&#x3D;a3fWa; Expires&#x3D;Wed, 21 Oct 2015 07:28:00 GMT;</code></pre><p>还有限制访问、作用域等，详见<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Cookies">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Cookies</a></p><h2 id="html"><a href="#html" class="headerlink" title="html"></a><code>html</code></h2><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><p><code>&amp;lt &lt;  &amp;gt &gt;    &amp;nbsp/&amp;emsp 空格  &amp;copy 版权   &amp;trade-&amp;reg 商标</code></p><p>清浮动 <code>clear:left/right/both</code> <code>overflow</code>:产生块级作用域</p><pre class="language-none"><code class="language-none">&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;catphotourl&quot; placeholder&#x3D;&quot;cat photo URL&quot; required&gt;长下面这样；type限制输入类型，name作为变量名称方便本地调用，placeholder给用户输入暗示，required规定必须有输入元素才能提交表单</code></pre><p><img src="/2022/11/02/Frontend/input%E6%A0%87%E7%AD%BE.png" alt="input标签"></p><p>input标签种类繁多，功能强大，详见<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/Input">https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/Input</a></p><p>type属性对应值及其作用：<a href="https://blog.csdn.net/VickyTsai/article/details/94839889">https://blog.csdn.net/VickyTsai/article/details/94839889</a></p><table><thead><tr><th>属性值</th><th>用于</th></tr></thead><tbody><tr><td>① text</td><td>定义 <strong>单行的 输入文本</strong> 字段，用户可在其中输入文本。默认宽度为 20 个字符。单行文本字段。换行符 将自动 从输入值中删除。</td></tr><tr><td>② checkbox</td><td>定义 <strong>复选框</strong>。 允许 选择&#x2F;取消选择 单个值 的复选框。</td></tr><tr><td>③ password</td><td>定义 <strong>密码</strong> 字段。该字段中的字符 被掩码。值被隐藏的 单行文本字段。使用<code>maxlength</code>和<code>minlength</code>属性指定 可输入值的最大长度。</td></tr><tr><td>④ hidden</td><td><strong>隐藏的 输入值</strong>: 定义 隐藏的 输入字段。不显示 但其值 提交给服务器的控件。</td></tr><tr><td>⑤ file</td><td><strong>选择文件</strong>. 定义输入字段和 “浏览”按钮，供 文件上传。允许用户 选择文件的控件。使用<code>accept</code>属性 定义控件 可以选择的 文件类型。</td></tr><tr><td>⑥ button</td><td><strong>无 默认行为的按钮</strong>: 定义 可点击<strong>按钮</strong>（多数情况下，用于通过 JavaScript 启动脚本）。一个没有默认行为的按钮。</td></tr><tr><td>⑦ radio</td><td>定义 <strong>单选 按钮</strong>。一个单选按钮，允许 从多个选项中 选择一个值。</td></tr><tr><td>⑧ reset</td><td>定义 <strong>重置按钮</strong>。重置按钮会 清除表单中的 所有数据。将表单内容重 置为默认值的按钮。</td></tr><tr><td>⑨ submit</td><td>定义 <strong>提交按钮</strong>。提交按钮 会把表单 数据发送到 服务器。提交表单的 按钮。</td></tr><tr><td>⑩ image</td><td><strong>图片提交按钮</strong>: 定义 图像形式的 提交按钮。 一个图形化的 提交按钮。必须使用<code>src</code>属性 定义图像的源，使用<code>alt</code>属性定义 替代文本。可以使用<code>height</code>高度和<code>width</code>宽度属性 以像素为单位 定义图像的大小。</td></tr></tbody></table><p>html5还有新增</p><p>value 属性为 input 元素设定值。</p><p>对于不同的输入类型，value 属性的用法也不同：</p><ul><li>type&#x3D;”button”, “reset”, “submit” - 定义按钮上的显示的文本</li><li>type&#x3D;”text”, “password”, “hidden” - 定义输入字段的初始值</li><li>type&#x3D;”checkbox”, “radio”, “image” - 定义与输入相关联的值</li></ul><p><strong>注释：</strong><code>&lt;input type=&quot;checkbox&quot;&gt;</code> 和<code> &lt;input type=&quot;radio&quot;&gt;</code> 中必须设置 value 属性。</p><p><strong>注释：</strong>value 属性无法与<code> &lt;input type=&quot;file&quot;&gt;</code> 一同使用。</p><p>select和option搭配使用</p><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>label</span> <span class="token attr-name">for</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>pet-select<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Choose a pet:<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>label</span><span class="token punctuation">></span></span>//注意 multiple 和 disable 的用法<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>pets<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>pet-select<span class="token punctuation">"</span></span> <span class="token attr-name">multiple</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>option</span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token punctuation">"</span></span> <span class="token attr-name">disabled</span><span class="token punctuation">></span></span>--Please choose an option--<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>option</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>option</span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>dog<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Dog<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>option</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>option</span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>cat<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Cat<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>option</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>option</span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>hamster<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Hamster<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>option</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>option</span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>parrot<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Parrot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>option</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>option</span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>spider<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Spider<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>option</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>option</span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>goldfish<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Goldfish<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>option</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span></code></pre><p>form标签的action属性是一个表单当中必须的属性，action属性规定当提交表单时，向何处发送表单数据。</p><p>label标签可以把input包裹起来，让点击文本和点击按钮都让按钮被点击生效。</p><ul><li>属性for可以将label绑定到for对应value为ID的标签，但是仅表示关联且需和绑定标签相邻，没有什么特殊效果。</li></ul><pre class="language-markup" data-language="markup"><code class="language-markup">For the styling of the page to look similar on mobile as it does on a desktop or laptop, you need to add a meta element with a special content attribute.<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>width=device-width, initial-scale=1.0<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span></code></pre><p>link标签的<code>rel</code>属性：此属性命名链接文档与当前文档的关系。type属性：这个属性被用于定义链接的内容的类型。这个属性的值应该是像 text&#x2F;html，text&#x2F;css 等 MIME 类型。这个属性常用的用法是定义链接的样式表，最常用的值是表明了 CSS 的 text&#x2F;css。</p><p>块级元素block：可以设定宽高，换行排列行内元素inline：只能由内容撑开，同一行排列行内块级元素inline-block：可以摆在同一行且能设定宽高</p><p>calc计算中不同表达式元素必须间隔空格，以区分变量名称和运算符。并且支持混合单位运算。vh单位是视窗大小的百分比。</p><p>布局视口和视觉视口。视口基本上是当前文档的可见部分，</p><p>box-sizing属性可分配值：content box(default)，border box；当指定宽度或高度时分别指内容高宽和内容+内边距+边界高宽</p><h2 id="css"><a href="#css" class="headerlink" title="css"></a>css</h2><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p>块级元素之间的外边距会发生折叠。这意味着，如果一个具有上边距的元素排在在一个具有下边距的元素之下时，他们之间的间距不会是这两个外边距的和，即外边距会发生折叠，简单来说就是，间距与两个外边距中的较大者一样大。</p><p>外边距叠加：相邻元素间距会按照两者各自外边距大的算</p><p>内联盒子的宽度和高度被忽略了。外边距、内边距和边框是生效的，但它们不会改变其他内容与内联盒子的关系，因此内边距和边框会与段落中的其他单词重叠。</p><p>inline-block却能在设置宽高、内外边距的同时推开其它内联盒子</p><p>盒子四边缩写是从顶边顺时针</p><h3 id="常用长度单位"><a href="#常用长度单位" class="headerlink" title="常用长度单位"></a>常用长度单位</h3><p>相对长度单位</p><table><thead><tr><th align="left">单位</th><th align="left">相对于</th></tr></thead><tbody><tr><td align="left"><code>em</code></td><td align="left">在 font-size 中使用是相对于父元素的字体大小，在其他属性中使用是相对于自身的字体大小，如 width</td></tr><tr><td align="left"><code>ex</code></td><td align="left">字符“x”的高度</td></tr><tr><td align="left"><code>ch</code></td><td align="left">数字“0”的宽度</td></tr><tr><td align="left"><code>rem</code></td><td align="left">根元素的字体大小，html文档中默认字体大小为 16px</td></tr><tr><td align="left"><code>lh</code></td><td align="left">元素的 line-height</td></tr><tr><td align="left"><code>vw</code></td><td align="left">视窗<strong>宽度</strong>的 1%</td></tr><tr><td align="left"><code>vh</code></td><td align="left">视窗<strong>高度</strong>的 1%</td></tr><tr><td align="left"><code>vmin</code></td><td align="left">视窗较小尺寸的 1%</td></tr><tr><td align="left"><code>vmax</code></td><td align="left">视图大尺寸的 1%</td></tr></tbody></table><h3 id="常用属性"><a href="#常用属性" class="headerlink" title="常用属性"></a>常用属性</h3><h4 id="box-shadow"><a href="#box-shadow" class="headerlink" title="box-shadow"></a>box-shadow</h4><p>用于在元素的框架上添加阴影效果，两个长度值为x、y轴偏移量，三个时第三个为blur-radius，第四个为spread-radius</p><ul><li>可选，<code>inset</code>关键字。</li><li>可选，<code>&lt;color&gt;</code>值。</li><li>若要对同一个元素添加多个阴影效果，请使用逗号将每个阴影规则分隔开。</li></ul><pre class="language-css" data-language="css"><code class="language-css"><span class="token comment">/* x 偏移量 | y 偏移量 | 阴影颜色 */</span><span class="token property">box-shadow</span><span class="token punctuation">:</span> 60px -16px teal<span class="token punctuation">;</span><span class="token comment">/* x 偏移量 | y 偏移量 | 阴影模糊半径 | 阴影颜色 */</span><span class="token property">box-shadow</span><span class="token punctuation">:</span> 10px 5px 5px black<span class="token punctuation">;</span><span class="token comment">/* x 偏移量 | y 偏移量 | 阴影模糊半径 | 阴影扩散半径 | 阴影颜色 */</span><span class="token property">box-shadow</span><span class="token punctuation">:</span> 2px 2px 2px 1px <span class="token function">rgba</span><span class="token punctuation">(</span>0<span class="token punctuation">,</span> 0<span class="token punctuation">,</span> 0<span class="token punctuation">,</span> 0.2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/* 插页 (阴影向内) | x 偏移量 | y 偏移量 | 阴影颜色 */</span><span class="token property">box-shadow</span><span class="token punctuation">:</span> inset 5em 1em gold<span class="token punctuation">;</span><span class="token comment">/* 任意数量的阴影，以逗号分隔 */</span><span class="token property">box-shadow</span><span class="token punctuation">:</span> 3px 3px red<span class="token punctuation">,</span> -1em 0 0.4em olive<span class="token punctuation">;</span><span class="token comment">/* 全局关键字 */</span><span class="token property">box-shadow</span><span class="token punctuation">:</span> inherit<span class="token punctuation">;</span><span class="token property">box-shadow</span><span class="token punctuation">:</span> initial<span class="token punctuation">;</span><span class="token property">box-shadow</span><span class="token punctuation">:</span> unset<span class="token punctuation">;</span></code></pre><p>元素设置了border-radius时，转变为圆角阴影</p><h3 id="盒模型、正常流"><a href="#盒模型、正常流" class="headerlink" title="盒模型、正常流"></a>盒模型、正常流</h3><p>盒子模型：外边距（<a href="https://so.csdn.net/so/search?q=margin&spm=1001.2101.3001.7020">margin</a>）+ border（边框） + 内边距（padding）+ content（内容）</p><pre class="language-none"><code class="language-none">标准盒子模型，一般浏览器也都默认为标准盒子模型。即：box-sizing:content-box怪异盒子模型，一般根据实际项目需要自行设置。即：box-sizing:border-boxpadding和border的值就不会影响元素的宽高，相当于把padding和border的值都算在content里</code></pre><h3 id="浏览器前缀"><a href="#浏览器前缀" class="headerlink" title="浏览器前缀"></a>浏览器前缀</h3><ul><li><code>-webkit-</code> （谷歌，Safari，新版 Opera 浏览器，以及几乎所有 iOS 系统中的浏览器（包括 iOS 系统中的火狐浏览器）；基本上所有基于 WebKit 内核的浏览器）</li><li><code>-moz-</code> （火狐浏览器）</li><li><code>-o-</code> （旧版 Opera 浏览器）</li><li><code>-ms-</code> （IE 浏览器 和 Edge 浏览器）</li></ul><h3 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h3><h4 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h4><p>最近的祖先样式比其他祖先样式优先级高。</p><p>“直接样式”比”祖先样式”优先级高。</p><p>内联样式 &gt; ID 选择器# &gt; 类选择器.class &#x3D; 属性选择器 &#x3D; 伪类选择器 &gt; 标签选择器element &#x3D; 伪元素选择器</p><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p><strong>伪类</strong> 是添加到选择器的关键字，指定要选择的元素的特殊状态。例如，<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:hover"><code>:hover</code></a> 可被用于在用户将鼠标悬停在按钮上时改变按钮的颜色。</p><p><strong>伪元素</strong>以类似方式表现，不过表现得是像你往标记文本中加入全新的 HTML 元素一样，而不是向现有的元素上应用类。例如<code>::first-line</code></p><h4 id="参考节"><a href="#参考节" class="headerlink" title="参考节"></a><a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/Building_blocks/Selectors/Pseudo-classes_and_pseudo-elements#%E5%8F%82%E8%80%83%E8%8A%82">参考节</a></h4><h3 id="flex布局"><a href="#flex布局" class="headerlink" title="flex布局"></a>flex布局</h3><p>flexbox弹性布局，一维布局模型display:flex</p><p>容器属性</p><p>flex-direction：四种摆放方向，垂直和水平的正反</p><ul><li><code>row</code></li><li><code>row-reverse</code></li><li><code>column</code></li><li><code>column-reverse</code></li></ul><p>flex-wrap：指定 flex 元素单行显示还是多行显示。如果允许换行，这个属性允许你控制行的堆叠方向。</p><ul><li><p>nowrap</p><p>flex 的元素被摆放到到一行，这可能导致 flex 容器溢出。<strong>cross-start</strong> 会根据 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/flex-direction"><code>flex-direction</code></a> 的值等价于 <strong>start</strong> 或 <strong>before</strong>。为该属性的默认值。</p></li><li><p>wrap</p><p>flex 元素 被打断到多个行中。<strong>cross-start</strong> 会根据 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/flex-direction"><code>flex-direction</code></a> 的值等价于 <strong>start</strong> 或<strong>before</strong>。<strong>cross-end</strong> 为确定的 <strong>cross-start</strong> 的另一端。</p></li><li><p>wrap-reverse</p><p>和 wrap 的行为一样，但是 <strong>cross-start</strong> 和 <strong>cross-end</strong> 互换。</p></li></ul><p>flex-flow：前两个属性的结合</p><p>justify-content：主轴对齐方式</p><p>align-items：交叉轴对齐方式</p><p>align-content：定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。</p><p>​五种对齐方式：这里的左右是相对于轴方向而言</p><ul><li><code>flex-start</code>（默认值）：左对齐</li><li><code>flex-end</code>：右对齐</li><li><code>center</code>： 居中</li><li><code>space-between</code>：两端对齐，项目之间的间隔都相等。</li><li><code>space-around</code>：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。</li></ul><p>内部元素属性</p><p>order：<code>order</code>属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。</p><p>flex-grow：对容器内剩余空间的处理，为容器内的每个元素进行分配，分配的值依此属性值而定。定义项目的放大比例，默认为<code>0</code>，即如果存在剩余空间，也不放大。</p><p>flex-shrink：对溢出空间的处理，对容器内每个元素的压缩的值依此属性的值而定。属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。</p><p>flex-basis：定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为<code>auto</code>，即项目的本来大小。</p><p>flex：flex属性是<code>flex-grow</code>, <code>flex-shrink</code> 和 <code>flex-basis</code>的简写，默认值为<code>0 1 auto</code>。后两个属性可选。</p><p>align-self：<code>align-self</code>属性允许单个项目有与其他项目不一样的对齐方式，可覆盖<code>align-items</code>属性。默认值为<code>auto</code>，表示继承父元素的<code>align-items</code>属性，如果没有父元素，则等同于<code>stretch</code>。</p><h3 id="grid布局"><a href="#grid布局" class="headerlink" title="grid布局"></a>grid布局</h3><p>二维布局。container 和 item</p><h4 id="container属性："><a href="#container属性：" class="headerlink" title="container属性："></a>container属性：</h4><ul><li>display：我们通过在元素上声明 <code>display：grid</code> 或 <code>display：inline-grid</code> 来创建一个网格容器。声明 <code>display：grid</code> 则该容器是一个块级元素，设置成 <code>display: inline-grid</code> 则容器元素为行内元素</li><li></li></ul><h4 id="item属性："><a href="#item属性：" class="headerlink" title="item属性："></a>item属性：</h4><h3 id="定位position"><a href="#定位position" class="headerlink" title="定位position"></a>定位position</h3><ul><li>static静态定位，默认属性</li><li>relative相对定位，相对于为static父标签的偏移，同时需要指定偏移方向和位移</li><li>absolute绝对定位，相对于不为static父标签的偏移</li><li>fixed固定定位，相对于浏览器窗口的偏移，不随父标签的属性改变而改变</li><li>sticky粘性定位，未滚动到预定位置就是relative，到预定位置就是fixed，实现比如固定在页面顶部的导航栏</li></ul><p>页面的普通流，static 和 relative 都不会更改元素的正常文档流，block 元素还是width 为100%，inline 元素还是宽高无效</p><pre class="language-css" data-language="css"><code class="language-css"><span class="token comment">/*relative示例*/</span><span class="token selector">span</span> <span class="token punctuation">&#123;</span>     <span class="token property">background</span><span class="token punctuation">:</span> #b6ff00<span class="token punctuation">;</span>     <span class="token property">position</span><span class="token punctuation">:</span> relative<span class="token punctuation">;</span>     <span class="token property">top</span><span class="token punctuation">:</span> 10px<span class="token punctuation">;</span>     <span class="token property">left</span><span class="token punctuation">:</span> 10px<span class="token punctuation">;</span>     <span class="token property">width</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></code></pre><h3 id="浮动float"><a href="#浮动float" class="headerlink" title="浮动float"></a>浮动float</h3><p>float 属性定义元素在哪个方向浮动，常用属性值有 left、right，即向左浮动和向右浮动。设置了 float 的元素，会脱离文档流，然后向左或向右移动，直到碰到父容器的边界或者碰到另一个浮动元素。块级元素会忽略 float 元素，文本和行内元素却会环绕</p><p>会影响自身及后面的元素，不推荐使用有相对应的clear属性，清除浮动，也能影响自身及后面的元素</p><ul><li>left</li><li>right</li></ul><h3 id="规则"><a href="#规则" class="headerlink" title="@规则"></a>@规则</h3><p>一个 <strong>at-rule</strong> 是一个<a href="https://developer.mozilla.org/en/CSS/Syntax#CSS_statements">CSS 语句，</a>以 at 符号开头， ‘<code>@</code>‘ (<code>U+0040 COMMERCIAL AT</code>), 后跟一个标识符，并包括直到下一个分号的所有内容， ‘<code>;</code>‘ (<code>U+003B SEMICOLON</code>), 或下一个 CSS 块，以先到者为准。</p><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/@charset"><code>@charset</code></a>, 定义样式表使用的字符集。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/@import"><code>@import</code></a>, 告诉 CSS 引擎引入一个外部样式表。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/@namespace"><code>@namespace</code></a>, 告诉 CSS 引擎必须考虑 XML 命名空间。</li><li>嵌套 @规则，是嵌套语句的子集，不仅可以作为样式表里的一个语句，也可以用在条件规则组里：<ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/@media"><code>@media</code></a>, 如果满足媒介查询的条件则条件规则组里的规则生效。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/@page"><code>@page</code></a>, 描述打印文档时布局的变化。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/@font-face"><code>@font-face</code></a>, 描述将下载的外部的字体。 Experimental</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/@keyframes"><code>@keyframes</code></a>, 描述 CSS 动画的中间步骤 . Experimental</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/@supports"><code>@supports</code></a>, 如果满足给定条件则条件规则组里的规则生效。 Experimental</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/@document"><code>@document</code></a>, 如果文档样式表满足给定条件则条件规则组里的规则生效。 <em>(推延至 CSS Level 4 规范)</em></li></ul></li></ul><p><strong>条件规则组</strong>. 这些语句使用相同的语法。它们都嵌套语句，或者是<em>规则</em>或者是*@规则*。它们都表达：它们所指的条件 (类型不同) 总等效于 <strong>true</strong> 或者 <strong>false</strong>，如果为 <strong>true</strong> 那么它们里面的语句生效。</p><h3 id="scss"><a href="#scss" class="headerlink" title="scss"></a>scss</h3><p>sass3.0之后的进步版本，采用花括号分段而非缩进</p><p><a href="https://sass-lang.com/">Sass: Syntactically Awesome Style Sheets</a></p><p>css的超集</p><p>变量开头是$</p><h4 id="mixin"><a href="#mixin" class="headerlink" title="mixin"></a>mixin</h4><p>类似函数，变量参数以 $ 开头，定义用@mixin前缀，调用用@include 前缀</p><pre class="language-none"><code class="language-none">&lt;style type&#x3D;&#39;text&#x2F;scss&#39;&gt;@mixin border-radius($radius)&#123;  -webkit-border-radius:$radius;  -moz-border-radius:$radius;  -ms-border-radius:$radius;  border-radius:$radius;&#125;  #awesome &#123;    width: 150px;    height: 150px;    background-color: green;    @include border-radius(15px);  &#125;&lt;&#x2F;style&gt;&lt;div id&#x3D;&quot;awesome&quot;&gt;&lt;&#x2F;div&gt;</code></pre><h3 id="Less"><a href="#Less" class="headerlink" title="Less"></a>Less</h3><h4 id="Variables"><a href="#Variables" class="headerlink" title="Variables"></a>Variables</h4><p>变量，@开头，在最外层定义</p><pre class="language-less" data-language="less"><code class="language-less"><span class="token variable">@width<span class="token punctuation">:</span></span> 10px<span class="token punctuation">;</span><span class="token variable">@height<span class="token punctuation">:</span></span> <span class="token variable">@width</span> <span class="token operator">+</span> 10px<span class="token punctuation">;</span><span class="token selector">#header</span> <span class="token punctuation">&#123;</span>  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token variable">@width</span><span class="token punctuation">;</span>  <span class="token property">height</span><span class="token punctuation">:</span> <span class="token variable">@height</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//编译为</span><span class="token selector">#header</span><span class="token punctuation">&#123;</span>    <span class="token property">width</span><span class="token punctuation">:</span>10px<span class="token punctuation">;</span>    <span class="token property">height</span><span class="token punctuation">:</span>20px<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h4 id="Mixins"><a href="#Mixins" class="headerlink" title="Mixins"></a>Mixins</h4><p>混合</p><h4 id="Nesting"><a href="#Nesting" class="headerlink" title="Nesting"></a>Nesting</h4><p>嵌套</p><p><code>&amp;</code> 表示当前选择器的父级</p><pre class="language-less" data-language="less"><code class="language-less"><span class="token selector">.clearfix</span> <span class="token punctuation">&#123;</span>  <span class="token property">display</span><span class="token punctuation">:</span> block<span class="token punctuation">;</span>  <span class="token property">zoom</span><span class="token punctuation">:</span> 1<span class="token punctuation">;</span>  <span class="token selector">&amp;:after</span> <span class="token punctuation">&#123;</span>    <span class="token property">content</span><span class="token punctuation">:</span> <span class="token string">" "</span><span class="token punctuation">;</span>    <span class="token property">display</span><span class="token punctuation">:</span> block<span class="token punctuation">;</span>    <span class="token property">font-size</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>    <span class="token property">height</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>    <span class="token property">clear</span><span class="token punctuation">:</span> both<span class="token punctuation">;</span>    <span class="token property">visibility</span><span class="token punctuation">:</span> hidden<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="Stylus"><a href="#Stylus" class="headerlink" title="Stylus"></a><strong><code>Stylus</code></strong></h3><h2 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h2><p>document object model 文档对象模型，HTML的节点树</p><p>接口：Document，Window，Element，</p><p>基本操作分四类：增、删、查、改</p><p>查的方法：获取DOM节点</p><ul><li><p>js中执行document上的成员函数，传入 id、class、tagName等指定条件，获取DOM结点</p></li><li><p>通过css选择器查询DOM结点</p></li><li><p>通过已访问到的DOM节点对象访问其它相关的父子兄弟结点。</p></li><li><p><code>document.getElementById(id)</code></p></li><li><p><code>document.getElementsByTagName(name)</code>，参数是标签名，返回nodelist，类数组</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document/getElementsByClassName"><code>Document.getElementsByClassName()</code></a>，参数类名，返回nodelist</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document/querySelector"><code>document.querySelector()</code></a>，参数是css选择器语法，加引号，返回第一个符合选择器语法的element</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document/querySelectorAll"><code>document.querySelectorAll()</code></a>，参数同上，但返回nodelist</p></li></ul><p>增(例如定位element对象，为其增加子节点)、删(element.remove())、改(Element对象的方法)</p><h3 id="DOM事件"><a href="#DOM事件" class="headerlink" title="DOM事件"></a>DOM事件</h3><p>0级(其实并不存在这个标准)，1级(映射文档结构，特定于HTML的对象和方法)，2级(增加模块以支持新的接口：追踪文档不同视图的接口、事件及事件处理接口、处理元素css样式的接口、遍历和操作DOM树的接口)，3级(增加了以统一的方式加载和保存文档的方法（包含在一个叫 DOM  Load and Save 的新模块中），还有验证文档的方法（DOM Validation）)，4级(替代 Mutation Events 的 Mutation Observers)</p><ul><li>事件发生，触发设定好的应对函数(事件监听函数)，是js和HTML的交互基础，常用的有鼠标事件、触摸事件、键盘事件、媒体事件、剪切板事件、资源事件等</li><li>事件流，三个阶段：事件捕获Capture-&gt;目标事件Target-&gt;事件冒泡Bubbling      onclick和addEventListener的区别，前者不支持一个事件绑定多个事件处理函数，后者支持</li></ul><p>addEventListener的第三个参数为指定事件是否在捕获或冒泡阶段执行，<u>设置为true表示事件在捕获阶段执行，而设置为false表示事件在冒泡阶段执行。</u>默认值为true</p><p>event属性</p><ul><li><code>event.target</code>指向<strong>引起触发事件的元素</strong>，而<code>event.currentTarget</code>则是<strong>事件绑定的元素</strong>。</li></ul><pre class="language-none"><code class="language-none">target.addEventListener(type, listener[, useCapture]);target.removeEventListener(type, listener[, useCapture]);&#x2F;*方法中包含3个参数，分别是绑定的事件处理属性名称（不包含on）、事件处理函数、是否在捕获时执行事件处理函数*&#x2F;</code></pre><p>event方法</p><ul><li><p>stopPropagation方法主要用于阻止事件的进一步传播，配合addeventlistener第三个参数可以实现在事件捕获阶段阻止事件向下传播或在事件冒泡阶段阻止事件向上传播</p></li><li><p>preventDefault方法用于取消事件的默认操作，比如a链接的跳转行为和表单自动提交行为就可以用preventDefault方法来取消。</p></li><li><p>和stopPropagation相比，stopImmediatePropagation同样可以阻止事件的传播，不同点在于其还可以把这个元素绑定的同类型事件也阻止了。</p></li></ul><h3 id="虚拟DOM"><a href="#虚拟DOM" class="headerlink" title="虚拟DOM"></a>虚拟DOM</h3><p>Virtual dom, 即虚拟DOM节点。它通过JS的Object对象模拟DOM中的节点，然后再通过特定的render方法将其渲染成真实的DOM节点。</p><p>包含了<code>tag</code>、<code>props</code>、<code>children</code>三个属性。分别代表当前元素的标签名称字符串，当前标签的属性对象，子元素对象数组，也就是说可以无限嵌套。</p><pre class="language-none"><code class="language-none">render方法转换属性时要考虑多种情况。像value、style等属性需要做特殊处理function createElement(type, props, children) &#123;    return new Element(type, props, children);&#125;class Element &#123;    constructor(type, props, children) &#123;        this.type &#x3D; type;        this.props &#x3D; props;        this.children &#x3D; children;    &#125;&#125;function render(eleObj) &#123;    let el &#x3D; document.createElement(eleObj.type); &#x2F;&#x2F; 创建元素    for(let key in eleObj.props) &#123;        &#x2F;&#x2F; 设置属性的方法        setAttr(el, key, eleObj.props[key])    &#125;    eleObj.children.forEach(child &#x3D;&gt; &#123;        &#x2F;&#x2F; 判断子元素是否是Element类型，是则递归，不是则创建文本节点        child &#x3D; (child instanceof Element) ? render(child) : document.createTextNode(child);        el.appendChild(child);    &#125;);    return el;&#125;function setAttr(node, key, value) &#123;    switch(key) &#123;        case &#39;value&#39;: &#x2F;&#x2F; node是一个input或者textarea            if(node.tagName.toUpperCase() &#x3D;&#x3D;&#x3D; &#39;INPUT&#39; || node.tagName.toUpperCase() &#x3D;&#x3D;&#x3D; &#39;TEXTAREA&#39;) &#123;                node.value &#x3D; value;            &#125; else &#123; &#x2F;&#x2F; 普通属性                node.setAttribute(key, value);            &#125;        break;        case &#39;style&#39;:            node.style.cssText &#x3D; value;        break;        default:            node.setAttribute(key, value);        break;    &#125;&#125;&#x2F;&#x2F;renderDom接受 el 真实DOM和target 渲染目标两个参数，负责将真实DOM添加到浏览器上function renderDom(el, target) &#123;    target.appendChild(el);&#125;</code></pre><h3 id="DOM-Diff"><a href="#DOM-Diff" class="headerlink" title="DOM Diff"></a>DOM Diff</h3><p>通过<code>JS</code>层面的计算，返回一个patch对象，即补丁对象，再通过特定的操作解析<code>patch</code>对象，完成页面的重新渲染。</p><p>1.用JS对象模拟DOM（虚拟DOM）<br>2.把此虚拟DOM转成真实DOM并插入页面中（render）<br>3.如果有事件发生修改了虚拟DOM，比较两棵虚拟DOM树的差异，得到差异对象（diff）<br>4.把差异对象应用到真正的DOM树上（patch）</p><h2 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h2><p>Browser Object Model 浏览器对象模型，控制浏览器的行为的接口</p><p>window是浏览器对象模型</p><h3 id="window-location"><a href="#window-location" class="headerlink" title="window.location"></a>window.location</h3><h4 id="hash属性"><a href="#hash属性" class="headerlink" title="hash属性"></a>hash属性</h4><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Location"><code>Location</code></a> 接口的 <strong><code>hash</code></strong> 属性返回一个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String"><code>USVString</code></a>，其中会包含 URL 标识中的 <code>&#39;#&#39;</code> 和 后面 URL 片段标识符。这里 fragment 不会经过<a href="https://developer.mozilla.org/en-US/docs/Glossary/percent-encoding">百分比编码</a>（URL 编码）。如果 URL 中没有 fragment，该属性会包含一个空字符串，<code>&quot;&quot;</code></p><p>通过监听 window 对象的 hashChange 事件实现简单的路由</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript">window<span class="token punctuation">.</span><span class="token function-variable function">onhashchange</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">var</span> hash <span class="token operator">=</span> window<span class="token punctuation">.</span>location<span class="token punctuation">.</span>hash  <span class="token keyword">var</span> path <span class="token operator">=</span> hash<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>  <span class="token keyword">switch</span> <span class="token punctuation">(</span>path<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">case</span> <span class="token string">'/'</span><span class="token operator">:</span>      <span class="token function">showHome</span><span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token keyword">break</span>    <span class="token keyword">case</span> <span class="token string">'/users'</span><span class="token operator">:</span>      <span class="token function">showUsersList</span><span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token keyword">break</span>    <span class="token keyword">default</span><span class="token operator">:</span>      <span class="token function">show404NotFound</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;web基础知识&quot;&gt;&lt;a href=&quot;#web基础知识&quot; class=&quot;headerlink&quot; title=&quot;web基础知识&quot;&gt;&lt;/a&gt;web基础知识&lt;/h2&gt;&lt;h3 id=&quot;url到页面&quot;&gt;&lt;a href=&quot;#url到页面&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="Frontend" scheme="https://hhumar.com/categories/Frontend/"/>
    
    
    <category term="Web" scheme="https://hhumar.com/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>Python</title>
    <link href="https://hhumar.com/2022/10/31/Python/"/>
    <id>https://hhumar.com/2022/10/31/Python/</id>
    <published>2022-10-31T01:57:20.000Z</published>
    <updated>2022-10-31T01:57:51.832Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="变量相关"><a href="#变量相关" class="headerlink" title="变量相关"></a>变量相关</h3><ul><li><p>Numbers（数字）</p><ul><li>int（有符号整型） <em>Python3.X 版本中 long 类型被移除，使用 int 替代。</em></li><li>float（浮点型）<ul><li>float(‘inf’) 表示正无穷 -float(‘inf’) 或 float(‘-inf’) 表示负无穷 其中，inf 均可以写成 Inf</li></ul></li><li>complex（复数）复数由实数部分和虚数部分构成，可以用 a + bj,或者 complex(a,b) 表示， 复数的实部 a 和虚部 b 都是浮点型。</li></ul></li><li><p>String（字符串）</p><ul><li><p>u&#x2F;U:表示unicode字符串<br>不是仅仅是针对中文, 可以针对任何的字符串，代表是对字符串进行unicode编码。<br>一般英文字符在使用各种编码下, 基本都可以正常解析, 所以一般不带u；但是中文, 必须表明所需编码, 否则一旦编码转换就会出现乱码。<br>建议所有编码方式采用utf-8，即在py文件开头添加: # coding: utf-8</p></li><li><p>r&#x2F;R:非转义的原始字符串<br>与普通字符相比，其他相对特殊的字符，其中可能包含转义字符，即那些，反斜杠加上对应字母，表示对应的特殊含义的，比如最常见的”\n”表示换行，”\t”表示Tab等。而如果是以r开头，那么说明后面的字符，都是普通的字符了，即如果是“\n”那么表示一个反斜杠字符，一个字母n，而不是表示换行了。<br>以r开头的字符，常用于正则表达式，对应着re模块。</p></li><li><p>F-strings python3.6开始支持，类似js的模板字符串</p><pre class="language-python" data-language="python"><code class="language-python">str_p <span class="token operator">=</span> <span class="token string-interpolation"><span class="token string">f'顺子是</span><span class="token interpolation"><span class="token punctuation">&#123;</span>add_string<span class="token punctuation">(</span><span class="token builtin">str</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span></span><span class="token string">'</span></span></code></pre></li></ul></li><li><p>List（列表）</p></li><li><p>Tuple（元组）</p></li><li><p>Dictionary（字典），类似js的map和object结合，键值可以为字符串也可以为number</p></li></ul><p>None 是 NoneType 数据类型的唯一值</p><p>python中除号用&#x2F;表示，但是和C语言不同的是&#x2F;得到的值总是<a href="https://so.csdn.net/so/search?q=%E6%B5%AE%E7%82%B9&spm=1001.2101.3001.7020">浮点</a>数，&#x2F;&#x2F; 两数相除，向下取整</p><p>未声明为非局部变量的变量是只读的，（写入只读变量会在最内层作用域中创建一个 <strong>新的</strong> 局部变量，而同名的外部变量保持不变。）</p><p>空字符串、空列表、空元组、空字典、空集合均为false</p><h3 id="内置类型"><a href="#内置类型" class="headerlink" title="内置类型"></a>内置类型</h3><p><a href="https://docs.python.org/zh-cn/3/library/stdtypes.html?highlight=maketrans#text-sequence-type-str">https://docs.python.org/zh-cn/3/library/stdtypes.html?highlight=maketrans#text-sequence-type-str</a></p><p>数字类型 — <a href="https://docs.python.org/zh-cn/3/library/functions.html#int"><code>int</code></a>, <a href="https://docs.python.org/zh-cn/3/library/functions.html#float"><code>float</code></a>, <a href="https://docs.python.org/zh-cn/3/library/functions.html#complex"><code>complex</code></a></p><p>序列类型 — <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html?highlight=maketrans#list"><code>list</code></a>, <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html?highlight=maketrans#tuple"><code>tuple</code></a>, <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html?highlight=maketrans#range"><code>range</code></a><a href="https://docs.python.org/zh-cn/3/library/stdtypes.html?highlight=maketrans#sequence-types-list-tuple-range">¶</a></p><p>文本序列类型 — <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html?highlight=maketrans#str"><code>str</code></a><a href="https://docs.python.org/zh-cn/3/library/stdtypes.html?highlight=maketrans#text-sequence-type-str">¶</a></p><p>…</p><h3 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h3><p>list() 可以直接把字符串转为字符数组，split方法则不行</p><p>chr()函数取整数值作为Unicode码转换为字符，ord() 获取单个字符输出 Unicode 码</p><h3 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h3><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>in &#x2F; not in</td><td>成员运算符</td></tr><tr><td>is &#x2F; not is</td><td>身份运算符</td></tr></tbody></table><h3 id="基础语句"><a href="#基础语句" class="headerlink" title="基础语句"></a>基础语句</h3><ul><li><p>yield语句：与 return 的差别在于会保留执行状态，下次调用会从上次执行点继续执行</p></li><li><p><code>if</code> 、<code>elif</code> 、<code>else</code>条件控制语句</p><p>支持a&lt;x&lt;b这种连比</p></li><li><p>循环语句：</p><ul><li><p>while……else</p></li><li><p>for循环，start默认为0，step默认为1，&lt;stop，不会等于stop</p><pre class="language-none"><code class="language-none">for i in range(satrt, stop, step):    业务逻辑</code></pre></li></ul><p><code>pass 语句</code> 是 Python 中的空语句，程序执行到此语句直接跳过，不会做任何的操作，仅作占位语句，但它在保持程序结构的完整性方面，有一定价值。</p><ul><li><p>列表推导式效率远高于for循环语句</p><p>out_list &#x3D; [表达式 for 变量 in 列表 条件判断语句等]</p><pre class="language-none"><code class="language-none">&gt;&gt;&gt; out_list &#x3D; [i**2 for i in range(10) if i % 2 &#x3D;&#x3D;0]&gt;&gt;&gt; out_list[0, 4, 16, 36, 64]</code></pre></li></ul></li><li><p>match…case</p><ul><li>变量名 <code>_</code> 作为 通配符 并确保目标将总是被匹配，是可选的，如果没有又之前 case 未得到匹配，则会执行一个空操作（no-op）</li></ul></li><li><p>try…except…as… 捕获异常</p><pre class="language-none"><code class="language-none">try:    a&#x3D;1+&quot;b&quot;except Exception as e:    print(e)</code></pre></li><li><p>lambda函数</p><pre class="language-none"><code class="language-none">lambda arg1,arg2,arg3… :&lt;表达式&gt;lambda x, y: x*y；函数输入是x和y，输出是它们的积x*ylambda:None；函数没有输入参数，输出是Nonelambda *args: sum(args); 输入是任意个数的参数，输出是它们的和(隐性要求是输入参数必须能够进行加法运算)lambda **kwargs: 1；输入是任意键值对参数，输出是1</code></pre></li></ul><h3 id="数据值传递和引用"><a href="#数据值传递和引用" class="headerlink" title="数据值传递和引用"></a>数据值传递和引用</h3><p>字符串，数值，元组均为静态变量，列表，字典为动态变量。一般静态变量值传递为拷贝，动态变量值传递为引用。利用 id() 可以查看变量存储地址。</p><p>注：对静态变量首次传递时也是引用，当需要修改静态变量时，因为静态变量不能改变，所以需要生成一个新的空间存储数据。</p><p>所以更准确地说，python中只有引用传递，只不过静态类型不可改变，要改变对应名称的值只能改变其指向的内存地址。</p><p><strong>is比较的是两个对象的内存地址是否相等，&#x3D;&#x3D;比较的是两个对象的值是否相等</strong>。</p><pre class="language-python" data-language="python"><code class="language-python">a <span class="token operator">=</span> <span class="token number">1</span>b <span class="token operator">=</span> <span class="token number">1</span>a <span class="token operator">==</span> b <span class="token comment"># True</span>a <span class="token keyword">is</span> b <span class="token comment"># True</span>a <span class="token operator">=</span> <span class="token number">888</span>b <span class="token operator">=</span> <span class="token number">888</span>a <span class="token operator">==</span> b <span class="token comment"># True</span>a <span class="token keyword">is</span> b <span class="token comment"># False</span>a <span class="token operator">=</span> <span class="token string">'hello'</span>b <span class="token operator">=</span> <span class="token string">'hello'</span>a <span class="token keyword">is</span> b <span class="token comment"># True</span>a <span class="token operator">==</span> b <span class="token comment"># True</span>a <span class="token operator">=</span> <span class="token string">'hello world'</span>b <span class="token operator">=</span> <span class="token string">'hello world'</span>a <span class="token operator">==</span> b <span class="token comment"># True</span>a <span class="token keyword">is</span> b <span class="token comment"># False</span></code></pre><p>部分代表小整数的对象都会指向小整数池，类似的，Python解释器中使用了 intern（字符串驻留），使值同样的字符串对象仅仅会保存一份，放在一个字符串储蓄池中，是共用的，如果字符串中有空格，默认不启用intern机制。对字符串储蓄池中的字符串使用 is 和 &#x3D;&#x3D; 比较会得到相同的结果。</p><p><strong>在shell中，仅有以下划线、数字、字母组成的字符串会被intern。而pycharm中只要是同一个字符串不超过20个字符都被加入到池中</strong></p><p>需要严格根据解释环境判断，在IDLE中id都一样。</p><p>垃圾回收：引用计数，当某个对象在其作用域内不再被其他对象引用的时候，Python 就自动清除对象；</p><p>注意深浅拷贝：</p><ul><li>a.append(tmp)a.append(tmp[:])</li></ul><h3 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h3><p>切片使用2个冒号分隔的3个数字来完成：</p><ul><li>第一个数字表示切片的开始位置，默认为0</li><li>第二个数字表是切片的截止（但不包含）位置（默认为列表长度）</li><li>第三个数字表示切片的步长(默认为1)，当步长省略时，顺便可以省略最后一个冒号。</li></ul><p><code>a[:]</code>是深复制，<code>a</code>是浅复制，相当于赋值<code>a</code>的话是赋值了指针，赋值<code>a[:]</code>相当于复制了<code>a</code>对应的那段空间</p><h3 id="解包"><a href="#解包" class="headerlink" title="解包"></a>解包</h3><p>解包赋值，是zip函数的逆操作。</p><h2 id="基础数据结构类型"><a href="#基础数据结构类型" class="headerlink" title="基础数据结构类型"></a>基础数据结构类型</h2><h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><p>中括号<code>[]</code>创建一个列表，列表内可含有各种不同类型，包括再嵌套列表。</p><p><code>append</code>一次添加1个元素，<code>insert</code>在指定位置添加元素</p><pre class="language-none"><code class="language-none">a.insert(2,5) # insert 在索引2处添加元素5</code></pre><p><code>remove</code>直接删除元素，若被删除元素在列表内重复出现多次，则只删除第一次</p><p><code>pop</code>方法若不带参数默认删除列表最后一个元素；若带参数则删除此参数代表的索引处的元素</p><p>列表封装的其他方法还包括如下：</p><pre class="language-none"><code class="language-none">clear&#96;,&#96;index&#96;,&#96;count&#96;,&#96;sort&#96;,&#96;reverse&#96;,&#96;copy</code></pre><h3 id="tuple"><a href="#tuple" class="headerlink" title="tuple"></a>tuple</h3><p>元组是一类不允许添加删除元素的特殊列表，也就是一旦创建后续决不允许增加、删除、修改。<code>()</code>创建元组。</p><h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p><strong>基本用法</strong> set是一种里面不能含有重复元素的数据结构，这种特性天然的使用于列表的去重。</p><h3 id="dict"><a href="#dict" class="headerlink" title="dict"></a>dict</h3><p><code>&#123;&#125;</code>创建，键值可以为数字、字符串甚至是元祖</p><p>元组可以作为 dict 的 key，但列表不能作为元组的 key。这是由于 dict 要求 key 必须是不可变类型，但列表是可变类型，因此列表不能作为元组的 key。</p><p>items()、keys()、values() 分别用于获取字典中的所有 key-value 对、所有 key、所有 value。这三个方法依次返回 dict_items、dict_keys 和 dict_values 对象，Python 不希望用户直接操作这几个方法，但可通过 list() 函数把它们转换成列表。</p><ul><li>dict.has_key(key)<br>如果键在字典dict里返回true，否则返回false</li><li>dict.get(key, default&#x3D;None) 返回指定键的值，如果值不在字典中返回default值</li></ul><h3 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h3><p>collections.deque()</p><p><em>class</em> <code>collections.``deque</code>([<em>iterable</em>[, <em>maxlen</em>]])</p><ul><li><p><code>append</code>(<em>x</em>)</p><p>添加 <em>x</em> 到右端。</p></li><li><p><code>appendleft</code>(<em>x</em>)</p><p>添加 <em>x</em> 到左端。</p></li><li><p><code>pop</code>()</p><p>移去并且返回一个元素，deque 最右侧的那一个。 如果没有元素的话，就引发一个 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#IndexError"><code>IndexError</code></a>。</p></li><li><p><code>popleft</code>()</p><p>移去并且返回一个元素，deque 最左侧的那一个。 如果没有元素的话，就引发 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#IndexError"><code>IndexError</code></a>。</p></li><li><p>Deque对象同样提供了一个只读属性:</p><ul><li><p><code>maxlen</code></p><p>Deque的最大尺寸，如果没有限定的话就是 <code>None</code> 。</p></li></ul></li></ul><h3 id="Counter"><a href="#Counter" class="headerlink" title="Counter"></a>Counter</h3><h3 id="OrderedDict"><a href="#OrderedDict" class="headerlink" title="OrderedDict"></a>OrderedDict</h3><p>collections. 有序字典</p><h3 id="heapq"><a href="#heapq" class="headerlink" title="heapq"></a>heapq</h3><h3 id="defaultdict"><a href="#defaultdict" class="headerlink" title="defaultdict"></a>defaultdict</h3><h3 id="ChainMap"><a href="#ChainMap" class="headerlink" title="ChainMap"></a>ChainMap</h3><h2 id="常用函数、方法"><a href="#常用函数、方法" class="headerlink" title="常用函数、方法"></a>常用函数、方法</h2><pre class="language-none"><code class="language-none">a &#x3D; &#39;123456&#39;a[2:3]&#x2F;&#x2F;&#39;3&#39; 冒号前包后不包string.isdigit() &#x2F;&#x2F;如果 string 只包含数字则返回 True 否则返回 False.</code></pre><h3 id="enumerate"><a href="#enumerate" class="headerlink" title="enumerate()"></a><strong>enumerate()</strong></h3><p>遍历列表(数组)，可以同时获取索引和值，下面是例子</p><pre class="language-python" data-language="python"><code class="language-python">arr1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"a"</span><span class="token punctuation">,</span><span class="token string">"b"</span><span class="token punctuation">,</span><span class="token string">"c"</span><span class="token punctuation">,</span><span class="token string">"d"</span><span class="token punctuation">]</span><span class="token keyword">for</span> index<span class="token punctuation">,</span>value <span class="token keyword">in</span> <span class="token builtin">enumerate</span><span class="token punctuation">(</span>arr1<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token keyword">print</span><span class="token punctuation">(</span>index<span class="token punctuation">,</span>value<span class="token punctuation">)</span><span class="token comment"># 结果</span><span class="token number">0</span> a<span class="token number">1</span> b<span class="token number">2</span> c<span class="token number">3</span> d</code></pre><h3 id="json模块"><a href="#json模块" class="headerlink" title="json模块"></a>json模块</h3><p>把字符串转换成字典对象json.loads()</p><p>把对象转换成字符串json.dumps()</p><p>json.dump(data,file)把字典对象转换成字符串并写入文件</p><p>字符串转换成字典对象时，字符串里只能使用双引号</p><h3 id="‘’-join-拼接字符串"><a href="#‘’-join-拼接字符串" class="headerlink" title="‘’.join() 拼接字符串"></a>‘’.join() 拼接字符串</h3><pre class="language-python" data-language="python"><code class="language-python">arr <span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">"a"</span><span class="token punctuation">,</span><span class="token string">"b"</span><span class="token punctuation">,</span><span class="token string">"c"</span><span class="token punctuation">]</span>arr_str <span class="token operator">=</span> <span class="token string">"-"</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>arr_str<span class="token punctuation">)</span><span class="token comment"># 输出结果 a-b-c</span><span class="token string">''</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>chain<span class="token punctuation">(</span><span class="token operator">*</span>mat<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">//</span>拼接二维矩阵</code></pre><h3 id="math-comb"><a href="#math-comb" class="headerlink" title="math.comb()"></a>math.comb()</h3><p>Python中的method方法用于获取从n个项目中选择k个项目(不重复且无顺序)的方法数量</p><h3 id="os-path-split-‘PATH’"><a href="#os-path-split-‘PATH’" class="headerlink" title="os.path.split(‘PATH’)"></a>os.path.split(‘PATH’)</h3><p>以 “PATH” 中最后一个 ‘&#x2F;‘ 作为分隔符，分隔后，将索引为0的视为目录（路径），将索引为1的视为文件名</p><h3 id="print"><a href="#print" class="headerlink" title="print"></a>print</h3><p> print(i,end&#x3D;’\n’)，可指定末尾字符，默认为换行</p><h3 id="round"><a href="#round" class="headerlink" title="round()"></a>round()</h3><p>四舍五入取整</p><h3 id="str-maketrans-intab-outtab"><a href="#str-maketrans-intab-outtab" class="headerlink" title="str.maketrans(intab.outtab)"></a>str.maketrans(intab.outtab)</h3><ul><li>intab – 字符串中要替代的字符组成的字符串。</li><li>outtab – 相应的映射字符的字符串。</li></ul><p>内建函数: bytearray.maketrans()、bytes.maketrans()、str.maketrans()</p><p>通常和 translate 方法配合使用</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token comment">#!/usr/bin/python3</span> intab <span class="token operator">=</span> <span class="token string">"aeiou"</span>outtab <span class="token operator">=</span> <span class="token string">"12345"</span>deltab <span class="token operator">=</span> <span class="token string">"thw"</span> trantab1 <span class="token operator">=</span> <span class="token builtin">str</span><span class="token punctuation">.</span>maketrans<span class="token punctuation">(</span>intab<span class="token punctuation">,</span>outtab<span class="token punctuation">)</span> <span class="token comment"># 创建字符映射转换表</span>trantab2 <span class="token operator">=</span> <span class="token builtin">str</span><span class="token punctuation">.</span>maketrans<span class="token punctuation">(</span>intab<span class="token punctuation">,</span>outtab<span class="token punctuation">,</span>deltab<span class="token punctuation">)</span> <span class="token comment">#创建字符映射转换表，并删除指定字符</span> test <span class="token operator">=</span> <span class="token string">"this is string example....wow!!!"</span> <span class="token keyword">print</span><span class="token punctuation">(</span>test<span class="token punctuation">.</span>translate<span class="token punctuation">(</span>trantab1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>test<span class="token punctuation">.</span>translate<span class="token punctuation">(</span>trantab2<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><h3 id="str-split"><a href="#str-split" class="headerlink" title="str.split()"></a>str.split()</h3><p>语法：str.split(str&#x3D;” “,num&#x3D;string.count(str))</p><p>参数说明：<br>str： 表示为分隔符，默认为空格，但是不能为空串。若字符串中没有分隔符，则把整个字符串作为列表的一个元素。<br>num：表示分割次数。如果存在参数num，则仅分隔成 num+1 个子字符串。</p><p>默认空格分隔时会忽略分割后的空串，包括\n\t\r （\r\n表示回车换行）</p><pre class="language-none"><code class="language-none">s.split(&#39;.&#39;,-1) #尽可能多的分隔，与不加num参数相同</code></pre><p>注意：str为不可变对象，所以此方法不会修改原对象，若需处理分割后的字符串需要转储返回值</p><pre class="language-none"><code class="language-none">sNew &#x3D; str.split()</code></pre><h3 id="str-strip-chars"><a href="#str-strip-chars" class="headerlink" title="str.strip([chars])"></a>str.strip([chars])</h3><p>strip() 方法用于移除<a href="https://so.csdn.net/so/search?q=%E5%AD%97%E7%AC%A6%E4%B8%B2&spm=1001.2101.3001.7020">字符串</a>头尾指定的字符（默认为空格或换行符）或字符序列。</p><p>还有lstrip和rstrip，去除头部或尾部</p><h3 id="和"><a href="#和" class="headerlink" title="* 和 **"></a>* 和 **</h3><ul><li><code>*args</code>：argument用于列表、元组、集合</li><li><code>**kwargs</code>：kwargument用于字典</li></ul><p>1.解包可迭代对象</p><pre class="language-none"><code class="language-none">nums1&#x3D;[*nums1,*nums2]nums1+&#x3D;nums2nums1.extend(nums2)</code></pre><p>2.函数可变参数</p><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p><a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#nonlocal"><code>nonlocal</code></a> 语句会使得所列出的名称指向之前在最近的包含作用域中绑定的除全局变量以外的变量。</p><p><a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#global"><code>global</code></a> 语句是作用于整个当前代码块的声明。 它意味着所列出的标识符将被解读为全局变量。 要给全局变量赋值不可能不用到 <code>global</code> 关键字，不过自由变量也可以指向全局变量而不必声明为全局变量。</p><p>在 <a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#global"><code>global</code></a> 语句中列出的名称不得在同一代码块内该 <code>global</code> 语句之前的位置中使用。</p><p>在 <a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#global"><code>global</code></a> 语句中列出的名称不能被定义为形式参数，也不能被作为 <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#with"><code>with</code></a> 语句或 <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#except"><code>except</code></a> 子句的目标，以及 <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#for"><code>for</code></a> 循环的目标列表、<a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#class"><code>class</code></a> 定义、函数定义、<a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#import"><code>import</code></a> 语句或变量标注等等。</p><pre class="language-none"><code class="language-none">def scope_test():    def do_local():        spam &#x3D; &quot;local spam&quot;    def do_nonlocal():        nonlocal spam        spam &#x3D; &quot;nonlocal spam&quot;    def do_global():        global spam        spam &#x3D; &quot;global spam&quot;    spam &#x3D; &quot;test spam&quot;    do_local()    print(&quot;After local assignment:&quot;, spam)    do_nonlocal()    print(&quot;After nonlocal assignment:&quot;, spam)    do_global()    print(&quot;After global assignment:&quot;, spam)scope_test()print(&quot;In global scope:&quot;, spam)输出：After local assignment: test spamAfter nonlocal assignment: nonlocal spamAfter global assignment: nonlocal spamIn global scope: global spam</code></pre><h2 id="可迭代对象，迭代器，生成器"><a href="#可迭代对象，迭代器，生成器" class="headerlink" title="可迭代对象，迭代器，生成器"></a>可迭代对象，迭代器，生成器</h2><p>常见可迭代对象</p><ol><li>集合或序列类型（如<code>list</code>、<code>tuple</code>、<code>set</code>、<code>dict</code>、<code>str</code>）</li><li>文件对象</li><li>在类中定义了<code>__iter__()</code>方法的对象，可以被认为是 <code>Iterable</code>对象，但自定义的可迭代对象要能在<code>for</code>循环中正确使用，就需要保证<code>__iter__()</code>实现必须是正确的（即可以通过内置<code>iter()</code>函数转成<code>Iterator</code>对象。<code>iter()</code>函数是能够将一个可迭代对象转成迭代器对象，然后在<code>for</code>中使用）</li><li>在类中实现了如果只实现<code>__getitem__()</code>的对象可以通过<code>iter()</code>函数转化成迭代器但其本身不是可迭代对象。所以当一个对象能够在<code>for</code>循环中运行，但不一定是<code>Iterable</code>对象。</li></ol><p><code>可迭代对象（Iteratable Object）</code> 是能够一次返回其中一个成员的对象，<strong>都构建了 <code>__iter__</code> 方法</strong></p><p><code>迭代器（Iterator）</code> 是同时实现<code>__iter__() 与 __next__()</code> 方法的对象。</p><pre class="language-none"><code class="language-none">class IterObj:    def __init__(self):        self.a &#x3D; [3, 5, 7, 11, 13, 17, 19]        self.n &#x3D; len(self.a)        self.i &#x3D; 0    def __iter__(self):        return iter(self.a)    def __next__(self):        while self.i &lt; self.n:            v &#x3D; self.a[self.i]            self.i +&#x3D; 1            return v        else:            self.i &#x3D; 0            raise StopIteration()</code></pre><p>定义生成器两种方法：</p><ol><li>列表生成器——生成器表达式</li><li>使用<code>yield</code>定义生成器函数——生成器函数</li></ol><p>Python 中，包含 yield 关键词的普通函数就是生成器。</p><p>定义二维数组</p><pre class="language-python" data-language="python"><code class="language-python">list_three <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">]</span></code></pre><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>对象方法、静态方法、类方法等，归属权分别为obj、cls、cls</p><h3 id="基础-1"><a href="#基础-1" class="headerlink" title="基础"></a>基础</h3><p>当（从结尾处）正常离开类定义时，将创建一个 <em>类对象</em>。 这基本上是一个包围在类定义所创建命名空间内容周围的包装器，原始的（在进入类定义之前起作用的）局部作用域将重新生效，类对象将在这里被绑定到类定义头所给出的类名称</p><p>任何形式为 <code>__spam</code> 的标识符（至少带有两个前缀下划线，至多一个后缀下划线）的文本将被替换为 <code>_classname__spam</code>，其中 <code>classname</code> 为去除了前缀下划线的当前类名称。 这种改写不考虑标识符的句法位置，只要它出现在类定义内部就会进行。__init__类似构造函数</p><pre class="language-none"><code class="language-none">class Student(object):    ...    def set_score(self, score):        self.__score &#x3D; score</code></pre><p>以双下划线开头，并且以双下划线结尾的，是特殊变量，特殊变量是可以直接访问的，不是private变量，所以，不能用<code>__name__</code>、<code>__score__</code>这样的变量名</p><p>t.ppr()等同于Test.ppr(t)</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">ppr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span>t <span class="token operator">=</span> Test<span class="token punctuation">(</span><span class="token punctuation">)</span>t<span class="token punctuation">.</span>ppr<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">#Test.ppr(t)</span><span class="token comment">#没有传参数，error:</span>Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>  File <span class="token string">"cl.py"</span><span class="token punctuation">,</span> line <span class="token number">6</span><span class="token punctuation">,</span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">></span>    t<span class="token punctuation">.</span>ppr<span class="token punctuation">(</span><span class="token punctuation">)</span>TypeError<span class="token punctuation">:</span> ppr<span class="token punctuation">(</span><span class="token punctuation">)</span> takes <span class="token number">0</span> positional arguments but <span class="token number">1</span> was given</code></pre><p>ins，用来表示调用它的类实例</p><p>cls，类</p><p>类本身的方法是函数对象，实例的方法是方法对象，实现原理如下：</p><p>​当一个实例的非数据属性被引用时，将搜索实例所属的类。 如果被引用的属性名称表示一个有效的类属性中的函数对象，会通过打包（指向）查找到的实例对象和函数对象到一个抽象对象的方式来创建方法对象：这个抽象对象就是方法对象。 当附带参数列表调用方法对象时，将基于实例对象和参数列表构建一个新的参数列表，并使用这个新参数列表调用相应的函数对象。</p><h3 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h3><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Parent</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">pprt</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token keyword">class</span> <span class="token class-name">Child</span><span class="token punctuation">(</span>Parent<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">cprt</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span>c <span class="token operator">=</span> Child<span class="token punctuation">(</span><span class="token punctuation">)</span>c<span class="token punctuation">.</span>cprt<span class="token punctuation">(</span><span class="token punctuation">)</span>c<span class="token punctuation">.</span>pprt<span class="token punctuation">(</span><span class="token punctuation">)</span>p <span class="token operator">=</span> Parent<span class="token punctuation">(</span><span class="token punctuation">)</span>p<span class="token punctuation">.</span>pprt<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">#output:</span><span class="token operator">&lt;</span>__main__<span class="token punctuation">.</span>Child <span class="token builtin">object</span> at <span class="token number">0x0000000002A47080</span><span class="token operator">></span><span class="token operator">&lt;</span>__main__<span class="token punctuation">.</span>Child <span class="token builtin">object</span> at <span class="token number">0x0000000002A47080</span><span class="token operator">></span><span class="token operator">&lt;</span>__main__<span class="token punctuation">.</span>Parent <span class="token builtin">object</span> at <span class="token number">0x0000000002A47240</span><span class="token operator">></span></code></pre><h3 id="类中的方法："><a href="#类中的方法：" class="headerlink" title="类中的方法："></a>类中的方法：</h3><ul><li><code>__init__</code>方法的第一参数永远是<code>self</code>，表示创建的类<strong>实例本身</strong>，因此，在<code>__init__</code>方法内部，就可以把各种属性绑定到self，因为self就指向创建的实例本身。（2）、有了<code>__init__</code>方法，在创建实例的时候，就不能传入空的参数了，必须传入与<code>__init__</code>方法匹配的参数，但self不需要传，Python解释器会自己把实例变量传进去：</li></ul><p>也分实例属性和类属性，后者所有实例共享</p><p><strong>实例属性访问优先级比类属性高</strong></p><p>千万不要在实例上修改类属性，它实际上并没有修改类属性，而是给实例绑定了一个实例属性。</p><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><h3 id="解释器信息"><a href="#解释器信息" class="headerlink" title="解释器信息"></a>解释器信息</h3><p>#!&#x2F;usr&#x2F;bin&#x2F;python</p><p>分成两种情况：</p><p>（1）如果调用 python 脚本时，使用:</p><pre class="language-none"><code class="language-none">python script.py </code></pre><p>#!&#x2F;usr&#x2F;bin&#x2F;python 被忽略，等同于注释</p><p>（2）如果调用python脚本时，使用:</p><pre class="language-none"><code class="language-none">.&#x2F;script.py </code></pre><p>#!&#x2F;usr&#x2F;bin&#x2F;python 指定解释器的路径</p><p>PS：shell 脚本中在第一行也有类似的声明。</p><h3 id="复杂类型注解"><a href="#复杂类型注解" class="headerlink" title="复杂类型注解"></a>复杂类型注解</h3><p>List[int]即由int组成的列表，但是，实际中，只要这个列表中存在nt（其他的可以为任何类型），就不会出现警告</p><h3 id="模块信息"><a href="#模块信息" class="headerlink" title="模块信息"></a>模块信息</h3><p>__name__</p><p>直接执行一段脚本的时候，这段脚本的 **<strong>name</strong>**变量等于 <strong>‘<strong>main</strong>‘<strong>，当这段脚本被导入其他程序的时候，</strong><strong>name</strong></strong> 变量等于脚本本身的名字。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;基础&quot;&gt;&lt;a href=&quot;#基础&quot; class=&quot;headerlink&quot; title=&quot;基础&quot;&gt;&lt;/a&gt;基础&lt;/h2&gt;&lt;h3 id=&quot;变量相关&quot;&gt;&lt;a href=&quot;#变量相关&quot; class=&quot;headerlink&quot; title=&quot;变量相关&quot;&gt;&lt;/a&gt;变量相关&lt;/h</summary>
      
    
    
    
    <category term="常用编程语言基础知识" scheme="https://hhumar.com/categories/%E5%B8%B8%E7%94%A8%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="Python" scheme="https://hhumar.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript</title>
    <link href="https://hhumar.com/2022/10/30/js/"/>
    <id>https://hhumar.com/2022/10/30/js/</id>
    <published>2022-10-30T07:29:37.000Z</published>
    <updated>2022-10-31T01:53:55.128Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><pre class="language-none"><code class="language-none">JS和python都是解释型语言，仅需解释器在每次执行时编译并解释执行，编译型语言如c++，Java编译一次后，产生可执行文件可多次执行，效率高&lt;!--本地路径&#x2F;和\是等效的--&gt;&lt;img src&#x3D;&quot;.\Image\20161025\guo.jpg&quot; &#x2F;&gt;&lt;img src&#x3D;&quot;.&#x2F;Image&#x2F;20161025&#x2F;guo.jpg&quot; &#x2F;&gt;&lt;img src&#x3D;&quot;.\Image&#x2F;20161025&#x2F;guo.jpg&quot; &#x2F;&gt;&lt;img src&#x3D;&quot;.&#x2F;Image\20161025\guo.jpg&quot; &#x2F;&gt;&lt;!--网络文件路径一定要使用正斜杠&#x2F;--&gt;</code></pre><p>诞生于1995，出现时用于处理网页中的<strong>前端验证</strong>，发展中遵循ECMAScript标准，完整的JavaScript由三部分组成：<strong>ECMAScript标准，DOM文档对象模型，BOM浏览器对象模型</strong></p><p>解释型语言，无需编译直接运行，动态语言，基于原型的面向对象，写在script标签中，从上到下逐条执行；标识符命名仅可以含有字母、数字、_、$</p><h2 id="变量性质、关键字和特性"><a href="#变量性质、关键字和特性" class="headerlink" title="变量性质、关键字和特性"></a>变量性质、关键字和特性</h2><p>区分大小写，允许Unicode字母、数字和表意文字(意味着可以用汉字定义变量但不推荐)</p><p>当浏览器开辟出供代码执行的栈<a href="https://so.csdn.net/so/search?q=%E5%86%85%E5%AD%98&spm=1001.2101.3001.7020">内存</a>后，代码并没有自上而下立即执行，而是继续做了一些事情：<strong>把当前作用域中所有带var&#x2F;function关键字的进行提前的声明和定义 &#x3D;&gt; 变量提升机制</strong></p><p>typeof 操作符</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">typeof</span> <span class="token string">'aaa'</span><span class="token punctuation">;</span><span class="token comment">//"string"</span></code></pre><h3 id="let和var的区别"><a href="#let和var的区别" class="headerlink" title="let和var的区别"></a><code>let</code>和<code>var</code>的区别</h3><p> <code>let</code>和<code>const</code>不存在变量提升机制；<code>var</code>允许重复声明，而<code>let</code>不允许重复声明； <code>let</code>能解决<code>typeof</code>检测时出现的暂时性死区问题（<code>let</code>比<code>var</code>更严谨）；let创建的全局变量没有给window设置对应的属性；let会产生块级作用域</p><ul><li><code>var</code>声明是全局作用域或函数作用域，而<code>let</code>和<code>const</code>是块作用域。</li><li><code>var</code>变量可以在其范围内更新和重新声明； <code>let</code>变量可以被更新但不能重新声明； <code>const</code>变量既不能更新也不能重新声明。</li><li>它们都被提升到其作用域的顶端。但是，虽然使用变量<code>undefined</code>初始化了<code>var</code>变量，但未初始化<code>let</code>和<code>const</code>变量。</li><li>尽管可以在不初始化的情况下声明<code>var</code>和<code>let</code>，但是在声明期间必须初始化<code>const</code>。</li></ul><p>暂时性死区：在块级顶部到变量正式申明这块区域去访问这个变量的话，直接报错</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//报错而不是到外部引用x</span>    <span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="六种数据类型"><a href="#六种数据类型" class="headerlink" title="六种数据类型"></a>六种数据类型</h3><p><code>String</code> <code>Number</code> <code>Boolean</code>  <code>Undefined</code> <code>Symbol</code> <code>Object</code> </p><p><code>Object</code>为引用数据类型  </p><ul><li><p>Number</p><p>均采用IEEE 754存储数字，会把能转换为整数的小数转换为整数。科学计数法：3.123e7等效于3.123*10^7</p><p>八进制值用0o做前缀，十六进制0x前缀</p><p>浮点值最高精度为1e-17，不宜用js做科学计算</p><p><code>NaN</code>表示<code>Not a Number</code>，数据类型也是<code>Number</code>，有<code>Number.MIN_VALUE</code>&#x3D;5E-324，<code>Number.MAX_VALUE</code>&#x3D;1.797e308，还有正无穷 Infinity 和负无穷 -Infinity。函数 isFinite()可以判断数值是不是有限</p><p>isNaN()函数可以判断所给参数是否能转换为数值，不能则返回 true</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token function">isNan</span><span class="token punctuation">(</span><span class="token string">'10'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//返回false，因为能转化为数字</span>num<span class="token punctuation">.</span><span class="token function">toFixed</span><span class="token punctuation">(</span>digits<span class="token punctuation">)</span><span class="token comment">//浮点数规整化，digits为小数点后保留位数</span>Math<span class="token punctuation">.</span><span class="token function">trunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//return the integer portion of a number</span></code></pre><p>即将支持的 BigInt 大数，在number字面量后加上 n 即可。可以表示任意大整数。</p></li><li><p><code>null</code>值用来表示一个为空的对象，<code>typeof null</code>时返回<code>object</code>类型。原则上 null 表示一个空指针</p></li><li><p>string：将其他数据类型转换为String类型：<code>toString</code>方法和<code>String</code>函数，前者不能转换null和undefined类型，后者可以，凡遇字母转换为<code>NaN</code>。  转换为Number类型：Number函数，针对字符串有<code>parseInt</code>和<code>parseFloat</code>，这两个函数遇到其他类型时会先将对象转换为字符串再进行转换。</p><p>toString()方法在用于数值对象时可以接受参数，表示转换为不同进制的数字字符。</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> num <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>num<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// "10" </span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>num<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// "1010" </span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>num<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// "12" </span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>num<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// "10" </span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>num<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// "a" </span></code></pre><p><em>用加号操作符给一个值加上一个空字符串””也可以将其转换为字符串</em></p><ul><li><p>&#96;&#96;反引号，不同于单引号’’和双引号””，可以包裹模板字符串，能够允许嵌入表达式的字符串字面量，嵌入${expression}即可</p></li><li><p>标签函数标签函数 会接收被插值记号分隔后的模板和对每个表达式求值的结果。 标签函数本身是一个常规函数，通过前缀到模板字面量来应用自定义行为。</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span> <span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token number">9</span><span class="token punctuation">;</span> <span class="token keyword">function</span> <span class="token function">simpleTag</span><span class="token punctuation">(</span><span class="token parameter">strings<span class="token punctuation">,</span> <span class="token operator">...</span>expressions</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>     console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>strings<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">const</span> expression <span class="token keyword">of</span> expressions<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>         console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>expression<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span>     <span class="token keyword">return</span> <span class="token string">'foobar'</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token keyword">let</span> taggedResult <span class="token operator">=</span> simpleTag<span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span> a <span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token string"> + </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span> b <span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token string"> = </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span> a <span class="token operator">+</span> b <span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span> <span class="token comment">// ["", " + ", " = ", ""] 字符串数组</span><span class="token comment">// 6 </span><span class="token comment">// 9 </span><span class="token comment">// 15 </span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>taggedResult<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// "foobar" </span></code></pre></li><li><p>用模板字面量也可以直接获取原始的模板字面量内容。在标签函数的第一个参数中，存在一个特殊的属性<code>raw</code>，其他地方无法对字符串数组使用。</p></li></ul></li><li><p>Symbol类型：唯一标识符，具有唯一性、隐藏性（用作对象属性名时无法通过object.key访问，而需要定制的object.getOwnPropertySymbols()方法得到对象中所有用作属性名的symbol）</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> id1 <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token string">'id'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> id2 <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token string">'id'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>id1<span class="token operator">===</span>id2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//false</span><span class="token keyword">let</span> id3 <span class="token operator">=</span> Symbol<span class="token punctuation">.</span><span class="token function">for</span><span class="token punctuation">(</span><span class="token string">'id'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>id1<span class="token operator">===</span>id3<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//false</span><span class="token keyword">let</span> id4  <span class="token operator">=</span>Symbol<span class="token punctuation">.</span><span class="token function">for</span><span class="token punctuation">(</span><span class="token string">'id'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>id3<span class="token operator">===</span>id4<span class="token punctuation">)</span><span class="token comment">//true</span></code></pre><p>全局注册并登记，使得相同参数注册的值symbol相等。前提是都通过for注册登记。</p></li></ul><p>数字0，空字符串，NaN，空指针null，undefined都可以自动转化为false</p><p>null 其实属于自己的类型 Null，而不属于Object类型，typeof 之所以会判定为 Object 类型，是因为JavaScript 数据类型在底层都是以二进制的形式表示的，二进制的前三位为 0 会被 typeof 判断为对象类型，而 null 的二进制位恰好都是 0 ，因此，null 被误判断为 Object 类型。 <strong>对象被赋值了null 以后，对象对应的堆内存中的值就是游离状态了，GC 会择机回收该值并释放内存。</strong>因此，<strong>需要释放某个对象，就将变量设置为 null，即表示该对象已经被清空，目前无效状态。</strong></p><h2 id="基础语句"><a href="#基础语句" class="headerlink" title="基础语句"></a>基础语句</h2><p>==运算符会做强制类型转换===不会，单引号双引号和python一样，都可以用来包裹字符串，无区别。</p><p>typeof 操作符，返回其后变量或字面量的类型</p><p>+ 能做数字间的加减运算，当任一对象为字符串时会把另一参加运算对象转化为字符串再进行字符串拼接，参与运算对象为 object 或其他类型时会先转换为字符串再按如上规则运算</p><ul><li><p>try{}catch{}finally{}</p><p>1.try中有return, 会先将值暂存，无论finally语句中对该值做什么处理，最终返回的都是try语句中的暂存值。</p><p>2.当try与finally语句中均有return语句，会忽略try中return。</p></li></ul><h3 id="空值合并运算符"><a href="#空值合并运算符" class="headerlink" title="空值合并运算符"></a>空值合并运算符</h3><p><strong>空值合并操作符</strong>（**<code>??</code>**）是一个逻辑操作符，当左侧的操作数为 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/null"><code>null</code></a> 或者 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/undefined"><code>undefined</code></a> 时，返回其右侧操作数，否则返回左侧操作数。</p><p>与[逻辑或操作符（<code>||</code>）不同，逻辑或操作符会在左侧操作数为<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Falsy">假值</a>时返回右侧操作数。也就是说，如果使用 <code>||</code> 来为某些变量设置默认值，可能会遇到意料之外的行为。比如为假值（例如，<code>&#39;&#39;</code> 或 <code>0</code>）时。</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> foo <span class="token operator">=</span> <span class="token keyword">null</span> <span class="token operator">??</span> <span class="token string">'default string'</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// expected output: "default string"</span><span class="token keyword">const</span> baz <span class="token operator">=</span> <span class="token number">0</span> <span class="token operator">??</span> <span class="token number">42</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>baz<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// expected output: 0</span><span class="token keyword">const</span> baz <span class="token operator">=</span> <span class="token number">0</span> <span class="token operator">||</span> <span class="token number">42</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>baz<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// expected output: 42</span></code></pre><p>逻辑空赋值 ??&#x3D;</p><p>x ??&#x3D; y ，x为null或undefined时才赋值为右值。</p><h3 id="可选链操作符"><a href="#可选链操作符" class="headerlink" title="可选链操作符"></a>可选链操作符</h3><p>?.TS中遇到过</p><p>判断是否为空</p><h3 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h3><p>ES6 </p><ul><li><p>数组结构赋值：</p><p>只要某种数据结构具有 Iterator 接口，都可以采用数组形式的解构赋值。</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> <span class="token punctuation">[</span>a<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span>b<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span></code></pre></li><li><p>对象解构赋值：</p><p>注意loc: { start }和loc: start是不一样的，前者把start也作为模式串，而后者只有loc是模式串</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> node <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  <span class="token literal-property property">loc</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token literal-property property">start</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>      <span class="token literal-property property">line</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>      <span class="token literal-property property">column</span><span class="token operator">:</span> <span class="token number">5</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">let</span> <span class="token punctuation">&#123;</span> loc<span class="token punctuation">,</span> <span class="token literal-property property">loc</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span> start <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token literal-property property">loc</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span> <span class="token literal-property property">start</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span> line <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span> <span class="token operator">=</span> node<span class="token punctuation">;</span>line <span class="token comment">// 1</span>loc  <span class="token comment">// Object &#123;start: Object&#125;</span>start <span class="token comment">// Object &#123;line: 1, column: 5&#125;</span></code></pre><p>默认值，生效的条件是，对象的属性值严格等于<code>undefined</code>。</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> <span class="token punctuation">&#123;</span>x <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">&#125;</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token literal-property property">x</span><span class="token operator">:</span> <span class="token keyword">undefined</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>x <span class="token comment">// 3var </span><span class="token punctuation">&#123;</span>x <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">&#125;</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token literal-property property">x</span><span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>x <span class="token comment">// null</span></code></pre><p>由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构。</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">let</span> <span class="token punctuation">&#123;</span><span class="token number">0</span> <span class="token operator">:</span> first<span class="token punctuation">,</span> <span class="token punctuation">[</span>arr<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">:</span> last<span class="token punctuation">&#125;</span> <span class="token operator">=</span> arr<span class="token punctuation">;</span><span class="token comment">//index</span>first <span class="token comment">// 1</span>last <span class="token comment">// 3</span></code></pre></li></ul><h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h3><pre class="language-none"><code class="language-none">&#x2F;&#x2F; 箭头函数forEach(() &#x3D;&gt; &#123; &#x2F;* … *&#x2F; &#125; )forEach((value) &#x3D;&gt; &#123; &#x2F;* … *&#x2F; &#125; )forEach((value, key) &#x3D;&gt; &#123; &#x2F;* … *&#x2F; &#125; )forEach((value, key, map) &#x3D;&gt; &#123; &#x2F;* … *&#x2F; &#125; )&#x2F;&#x2F; 回调函数forEach(callbackFn)forEach(callbackFn, thisArg)&#x2F;&#x2F; 内联回调函数forEach(function() &#123; &#x2F;* … *&#x2F; &#125;)forEach(function(value) &#123; &#x2F;* … *&#x2F; &#125;)forEach(function(value, key) &#123; &#x2F;* … *&#x2F; &#125;)forEach(function(value, key, map) &#123; &#x2F;* … *&#x2F; &#125;)forEach(function(value, key, map) &#123; &#x2F;* … *&#x2F; &#125;, thisArg)</code></pre><h2 id="Map和Set"><a href="#Map和Set" class="headerlink" title="Map和Set"></a>Map和Set</h2><ul><li>一个 Object 的键只能是字符串或者 Symbols，但一个 Map 的键可以是任意值。</li><li>Map 的键值对个数可以从 size 属性获取，而 Object 的键值对个数只能手动计算。</li></ul><p>Set 对象允许你存储任何类型的唯一值，无论是原始值或者是对象引用。重复值的元素会被略去。</p><pre class="language-none"><code class="language-none">Set.prototype.add(value)在Set对象尾部添加一个元素。返回该 Set 对象Set.prototype.delete(value)移除值为 value 的元素，并返回一个布尔值来表示是否移除成功。Set.prototype.has(value) 会在此之后返回 false。Set.prototype.has(value)返回一个布尔值，表示该值在 Set 中存在与否。Set.prototype.clear()移除Set对象内的所有元素。Set.prototype.forEach(callbackFn[, thisArg])按照插入顺序，为 Set 对象中的每一个值调用一次 callBackFn。如果提供了thisArg参数，回调中的 this 会是这个参数。Set.prototype.values()返回一个新的迭代器对象，该对象包含 Set 对象中的按插入顺序排列的所有元素的值。</code></pre><p>let newArray &#x3D; Array.from(set)，可以把括号内的对象转换为array并返回</p><pre class="language-none"><code class="language-none">Map.prototype.size返回 Map 对象中的键值对数量。Map.prototype.get(key)返回与 key 关联的值，若不存在关联的值，则返回 undefined。Map.prototype.has(key)返回一个布尔值，用来表明 Map 对象中是否存在与 key 关联的值。Map.prototype.set(key, value)在 Map 对象中设置与指定的键 key 关联的值 value，并返回 Map 对象。Map.prototype.delete(key)移除 Map 对象中指定的键值对，如果键值对存在并成功被移除，返回 true，否则返回 false。调用 delete 后再调用 Map.prototype.has(key) 将返回 false。</code></pre><h3 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h3><p><strong><code>WeakMap</code></strong> 对象是一组键&#x2F;值对的集合，其中的键是弱引用的。其键必须是对象，而值可以是任意的。</p><p>map API <em>可以</em> 通过使其四个 API 方法共用两个数组（一个存放键，一个存放值）来实现。给这种 map 设置值时会同时将键和值添加到这两个数组的末尾。从而使得键和值的索引在两个数组中相对应。当从该 map 取值的时候，需要遍历所有的键，然后使用索引从存储值的数组中检索出相应的值。</p><p>但是存在两个缺点：</p><ol><li>首先赋值和搜索操作都是 <em>O(*n</em>)* 的时间复杂度（<em>n</em> 是键值对的个数），因为这两个操作都需要遍历全部整个数组来进行匹配。</li><li>另外一个缺点是可能会导致内存泄漏，因为数组会一直引用着每个键和值。这种引用使得垃圾回收算法不能回收处理他们，即使没有其他任何引用存在了。</li></ol><p>相比之下，原生的 <code>WeakMap</code> 持有的是每个键对象的“弱引用”，这意味着在没有其他引用存在时垃圾回收能正确进行。原生 <code>WeakMap</code> 的结构是特殊且有效的，其用于映射的 key _只有_在其没有被回收时才是有效的。</p><p><strong>正由于这样的弱引用，<code>WeakMap</code> 的 key 是不可枚举的</strong>（没有方法能给出所有的 key）。如果 key 是可枚举的话，其列表将会受垃圾回收机制的影响，从而得到不确定的结果。因此，如果你想要这种类型对象的 key 值的列表，你应该使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map"><code>Map</code></a>。</p><ul><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/WeakMap/delete"><code>WeakMap.prototype.delete(key)</code></a></p><p>删除 WeakMap 中与 <code>key</code> 相关联的值。删除之后， <code>WeakMap.prototype.has(key)</code> 将会返回 <code>false</code>。</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/WeakMap/get"><code>WeakMap.prototype.get(key)</code></a></p><p>返回 WeakMap 中与 <code>key</code> 相关联的值，如果 <code>key</code> 不存在则返回 <code>undefined</code>。</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/WeakMap/has"><code>WeakMap.prototype.has(key)</code></a></p><p>返回一个布尔值，断言一个值是否已经与 <code>WeakMap</code> 对象中的 <code>key</code> 关联。</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/WeakMap/set"><code>WeakMap.prototype.set(key, value)</code></a></p><p>给 <code>WeakMap</code> 中的 <code>key</code> 设置一个 <code>value</code>。该方法返回一个 <code>WeakMap</code> 对象。</p></li></ul><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><pre class="language-none"><code class="language-none">pop()删除末尾元素 ，返回移除的数组元素；push(ele)末尾添加元素 ele，返回添加后数组的长度；shift()删除首元素并移动数组位置 ，返回添加后数组的长度；unshift(ele)在数组首位置添加元素ele，返回添加后数组的长度；shift() 方法用于把数组的第一个元素从其中删除，并返回第一个元素的值。unshift方法unshift() 方法将一个或多个元素添加到数组的开头，并返回该数组的新长度（该方法修改原有数组）arr.unshift(element1, ..., elementN)返回其 length 属性值Array.isArray(val):判断val是不是数组Array.prototype 属性表示 Array 构造函数的原型，并允许向所有Array对象添加新的属性和方法。或者说，允许利用prototype向任何对象添加属性和方法，从而应用到对象的所有实例上</code></pre><h3 id="遍历操作"><a href="#遍历操作" class="headerlink" title="遍历操作"></a>遍历操作</h3><p>最常用for (var i &#x3D; 0; i &lt; a.length; i++) {<br>    &#x2F;&#x2F; Do something with a[i]<br>}</p><p>for (. of array)：for (const currentValue of a)  {&#x2F;&#x2F; Do something with currentValue}</p><p>for(. in array)：for (var i in a) {&#x2F;&#x2F; 操作 a[i]}遍历索引，如果直接向 Array.prototype 添加了新的属性，使用这样的循环这些属性也同样会被遍历。不推荐这个循环</p><p>forEach()：<br>array.forEach(function(currentValue, index, array) {&#x2F;&#x2F; 操作 currentValue 或者 array[index]});</p><p>注: forEach() 对于空数组是不会执行回调函数的。</p><h3 id="Array-prototype-at"><a href="#Array-prototype-at" class="headerlink" title="Array.prototype.at()"></a><a href="https://link.segmentfault.com/?enc=gIfegOUoZxxLBOg/nmpAvw==.it+TiWVsG0Y95ewedhlKoMS2CPXZSbhECA0MBePgVHbbS3pnn4r95vxFQo8Wnk+rFcIZQbnMXjwFeEBW9uTMx/mnhkJ0ck8W/V9MIZGB4SZb5GqmV1RLVPtXvNkMw7kq">Array.prototype.at()</a></h3><ul><li>返回at中参数指向的index的数组元素，支持负数</li></ul><h3 id="array-prototype-concat"><a href="#array-prototype-concat" class="headerlink" title="array.prototype.concat()"></a>array.prototype.concat()</h3><p>拼接两个数组</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token function">concat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">concat</span><span class="token punctuation">(</span>value0<span class="token punctuation">)</span><span class="token function">concat</span><span class="token punctuation">(</span>value0<span class="token punctuation">,</span> value1<span class="token punctuation">)</span><span class="token function">concat</span><span class="token punctuation">(</span>value0<span class="token punctuation">,</span> value1<span class="token punctuation">,</span> <span class="token comment">/* … ,*/</span> valueN<span class="token punctuation">)</span></code></pre><p><code>valueN</code> 可选</p><p>数组和&#x2F;或值，将被合并到一个新的数组中。如果省略了所有 <code>valueN</code> 参数，则 <code>concat</code> 会返回调用此方法的现存数组的一个浅拷贝。详情请参阅下文描述。</p><h3 id="array-indexOf"><a href="#array-indexOf" class="headerlink" title="array.indexOf"></a>array.indexOf</h3><ul><li>判断数组中是否存在某个值，如果存在返回数组元素的下标，否则返回-1</li></ul><h3 id="array-includes-searchElement-fromIndex"><a href="#array-includes-searchElement-fromIndex" class="headerlink" title="array.includes(searchElement[, fromIndex])"></a>array.includes(searchElement[, fromIndex])</h3><ul><li>判断一个数组是否包含一个指定的值，如果存在返回 true，否则返回false。</li></ul><h3 id="reduce-方法"><a href="#reduce-方法" class="headerlink" title="reduce()方法"></a>reduce()方法</h3><p><strong><code>reduce()</code></strong> 方法对数组中的每个元素按序执行一个由您提供的 <strong>reducer</strong> 函数，每一次运行 <strong>reducer</strong> 会将先前元素的计算结果作为参数传入，最后将其结果汇总为单个返回值。</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript">array<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">total<span class="token punctuation">,</span>currentValue<span class="token punctuation">,</span><span class="token punctuation">[</span>currentIndex<span class="token punctuation">,</span><span class="token punctuation">[</span>arr<span class="token punctuation">]</span><span class="token punctuation">]</span></span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">[</span>initialValue<span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre><p>reduce() 方法接收一个回调函数作为参数，reduce 为数组中的每一个元素依次执行回调函数，回调函数接受四个参数：初始值（或者上一次回调函数的返回值），当前元素值，当前索引，调用 reduce 的数组。<br>reduce方法的返回值为回调函数最后的返回值。</p><p>如果没有提供initialValue，那么reduce的第一轮回调函数中的“total”就arr[0]，“current_Value”就是arr[1]，index就是1；</p><p>如果提供initialValue，那么reduce的第一轮回调函数中的“total”就是initialValue，“current_Value”就是arr[0]，index就是0。</p><p>所以在使用reduce函数时，回调函数中return最好不要省，而且initialValue也最好不要省！！！</p><h3 id="filter-方法"><a href="#filter-方法" class="headerlink" title="filter() 方法"></a>filter() 方法</h3><p>返回一个新数组，其包含通过所提供函数实现的测试的所有元素。 </p><p>var newArray &#x3D; arr.filter(callback(element[, index[, array]])[, thisArg])</p><p>上式中 element 必需，后三者都可选，但没传 index 则 array 也不能传</p><p>注：当所过滤的数组是对象数组的情况时，对新返回的数组元素属性做出修改，同时对原数组也会造成影响；当过滤数组为纯数组时，修改不会改变原数组。也就是浅拷贝</p><h3 id="from方法"><a href="#from方法" class="headerlink" title="from方法"></a>from方法</h3><p>Array.from(arrayLike[, mapFn[, thisArg]])参数分别为伪数组对象或可迭代对象，新数组中的每个元素会执行的回调函数，执行回调函数 mapFn 时 this 对象<br>返回一个新的数组实例。</p><p>Array.from(arrayLike[, mapFunction[, thisArg]])：arrayLike：必传参数，想要转换成数组的伪数组对象或可迭代对象。<br>mapFunction：可选参数，mapFunction(item，index){…} 是在集合中的每个项目上调用的函数。返回的值将插入到新集合中。<br>thisArg：可选参数，执行回调函数 mapFunction 时 this 对象。这个参数很少使用。</p><h3 id="array-map-方法"><a href="#array-map-方法" class="headerlink" title="array.map() 方法"></a>array.map() 方法</h3><p>返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值，按照原始数组元素顺序依次处理元素。<br>array_back&#x3D;array.map(function(currentValue,index,arr), thisValue)</p><p>注：map()方法不会对空数组进行检测；也不会改变原数组</p><p>eg.let arr &#x3D; new Array( 2 ).fill( 0 ).map( _ &#x3D;&gt; new Array( 3 ) ); &#x2F;&#x2F;作用类似C语言：int arr[2][3]</p><h3 id="arr-slice-begin-end"><a href="#arr-slice-begin-end" class="headerlink" title="arr.slice([begin[, end]])"></a>arr.slice([begin[, end]])</h3><ul><li><code>begin</code> 可选，可为负。如果 <code>begin</code> 大于<a href="https://so.csdn.net/so/search?q=%E6%95%B0%E7%BB%84&spm=1001.2101.3001.7020">数组</a>长度，返回空数组。slice(-1) 提取最后一个元素，slice(-2)提取最后两个元素，依次类推。前包后不包。<br><a href="https://so.csdn.net/so/search?q=slice&spm=1001.2101.3001.7020">slice</a>() 返回整个数组。</li></ul><h3 id="array-splice-start-deleteCount-item1-item2-…"><a href="#array-splice-start-deleteCount-item1-item2-…" class="headerlink" title="array.splice(start[, deleteCount[, item1[, item2[, …]]]])"></a>array.splice(start[, deleteCount[, item1[, item2[, …]]]])</h3><ul><li>start 指定修改的开始位置（从 0 计数）。如果超出了数组的长度，则从数组末尾开始添加内容；如果是负值，则表示从数组末位开始的第几位（从 -1 计数，这意味着 -n 是倒数第 n 个元素并且等价于 <code>array.length-n</code>）；如果负数的绝对值大于数组的长度，则表示开始位置为第 0 位。</li><li>deleteCount :整数，表示要移除的数组元素的个数。如果 <code>deleteCount</code> 大于 <code>start</code> 之后的元素的总数，则从 <code>start</code> 后面的元素都将被删除（含第 <code>start</code> 位）。如果 <code>deleteCount</code> 被省略了，或者它的值大于等于<code>array.length - start</code>(也就是说，如果它大于或者等于<code>start</code>之后的所有元素的数量)，那么<code>start</code>之后数组的所有元素都会被删除。如果 <code>deleteCount</code> 是 0 或者负数，则不移除元素。这种情况下，至少应添加一个新元素。</li><li>item:从start位置要添加进数组的元素，不指定时 splice 将只删除元素。</li></ul><p>返回被删除的元素</p><h3 id="arr-sort-compareFn"><a href="#arr-sort-compareFn" class="headerlink" title="arr.sort([compareFn])"></a>arr.sort([compareFn])</h3><p>如果没有指明 <code>compareFn</code> ，那么元素会按照转换为的字符串的诸个字符的 Unicode 位点进行排序。例如 “Banana” 会被排列到 “cherry” 之前。当数字按由小到大排序时，9 出现在 80 之前，但因为（没有指明 <code>compareFn</code>），比较的数字会先被转换为字符串，所以在 Unicode 顺序上 “80” 要比 “9” 要靠前。</p><ul><li>如果 <code>compareFn(a, b)</code> 大于 0 ， b 会被排列到 a 之前。</li><li>如果 <code>compareFn(a, b)</code> 小于 0 ，那么 a 会被排列到 b 之前；</li><li>如果 <code>compareFn(a, b)</code> 等于 0 ， a 和 b 的相对位置不变。备注： ECMAScript 标准并不保证这一行为，而且也不是所有浏览器都会遵守（例如 Mozilla 在 2003 年之前的版本）；</li><li><code>compareFn(a, b)</code> 必须总是对相同的输入返回相同的比较结果，否则排序的结果将是不确定的。</li></ul><h3 id="strArr-join-separator"><a href="#strArr-join-separator" class="headerlink" title="strArr.join(separator)"></a>strArr.join(separator)</h3><ul><li>用输入参数分隔输入字符串数组的每个元素，返回新字符串</li></ul><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>可以直接用比较符号比较字符串</p><h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><p>escape-unescape方法不会对 ASCII 字母和数字进行编码，也不会对下面这些 ASCII 标点符号进行编码： * @ - _ + . &#x2F; 。其他所有的字符都会被转义序列替换。</p><p>encodeURI-decodeURI对以下在 URI 中具有特殊含义的 ASCII 标点符号，encodeURI() 函数是不会进行转义的： , &#x2F; ? : @ &amp; &#x3D; + $ # </p><p>encodeURIComponent-decodeURIComponent该方法不会对 ASCII 字母和数字进行编码，也不会对这些 ASCII 标点符号进行编码： - _ . ! ~ * ‘ ( ) 。其他字符（比如 ：;&#x2F;?:@&amp;&#x3D;+$,# 这些用于分隔 URI 组件的标点符号），都是由一个或多个十六进制的转义序列替换的。</p><p><strong>1、如果只是<a href="https://www.zhihu.com/search?q=%E7%BC%96%E7%A0%81%E5%AD%97%E7%AC%A6%E4%B8%B2&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:20300871%7D">编码字符串</a>，不和URL有半毛钱关系，那么用escape。</strong></p><p><strong>2、如果你需要编码整个URL，然后需要使用这个URL，那么用encodeURI。</strong></p><p>比如</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token function">encodeURI</span><span class="token punctuation">(</span><span class="token string">"http://www.cnblogs.com/season-huang/some other thing"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>编码后会变为</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token string">"http://www.cnblogs.com/season-huang/some%20other%20thing"</span><span class="token punctuation">;</span></code></pre><p>其中，空格被编码成了%20。但是如果你用了encodeURIComponent，那么结果变为</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token string">"http%3A%2F%2Fwww.cnblogs.com%2Fseason-huang%2Fsome%20other%20thing"</span></code></pre><p>看到了区别吗，连 “&#x2F;“ 都被编码了，整个URL已经没法用了。</p><p><strong>3、当你需要编码URL中的参数的时候，那么encodeURIComponent是最好方法。</strong></p><h3 id="String-prototype-charAt-index"><a href="#String-prototype-charAt-index" class="headerlink" title="String.prototype.charAt(index)"></a>String.prototype.charAt(index)</h3><p>指定 <code>index</code> 处字符，参数不在 0 和字符串的 length-1 之间，则返回空字符串</p><h3 id="String-prototype-charCodeAt-index"><a href="#String-prototype-charCodeAt-index" class="headerlink" title="String.prototype.charCodeAt(index)"></a>String.prototype.charCodeAt(index)</h3><p>index：一个大于等于 <code>0</code>，小于字符串长度的整数。如果不是一个数值，则默认为 <code>0</code>。</p><p>返回值：指定 <code>index</code> 处字符的 UTF-16 代码单元值的一个数字；如果 <code>index</code> 超出范围，<code>charCodeAt()</code> 返回 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/NaN"><code>NaN</code></a>。</p><p>如果指定的 <code>index</code> 小于 <code>0</code> 、等于或大于字符串的长度，则 <code>charCodeAt</code> 返回 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/NaN"><code>NaN</code></a>。</p><h3 id="String-fromCharCode"><a href="#String-fromCharCode" class="headerlink" title="String.fromCharCode()"></a>String.fromCharCode()</h3><p>静态 <strong><code>String.fromCharCode()</code></strong> 方法返回由指定的 UTF-16 代码单元序列创建的字符串。</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript">String<span class="token punctuation">.</span><span class="token function">fromCharCode</span><span class="token punctuation">(</span>str<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">charCodeAt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </code></pre><h3 id="indexOf-和-lastIndexOf"><a href="#indexOf-和-lastIndexOf" class="headerlink" title="indexOf() 和 lastIndexOf()"></a>indexOf() 和 lastIndexOf()</h3><p>使用字符串的 indexOf() 和 lastIndexOf() 方法，可以根据参数字符串，返回指定子字符串的下标位置。这两个方法都有两个参数，说明如下。</p><ul><li>第一个参数为一个子字符串，指定要查找的目标。</li><li>第二个参数为一个整数，指定查找的起始位置，取值范围是 0~length-1。</li></ul><p>对于第二个参数来说，需要注意一下几个特殊情况。</p><ul><li>如果值为负数，则视为 0，相当于从第一个字符开始查找。</li><li>如果省略了这个参数，也将从字符串的第一个字符开始查找。</li><li>如果值大于等于 length 属性值，则视为当前字符串中没有指定的子字符串，返回 -1。</li></ul><h3 id="str-match-reg"><a href="#str-match-reg" class="headerlink" title="str.match(reg)"></a>str.match(reg)</h3><p>&#x2F;.&#x2F;g</p><p>方法对字符串对象进行检索,返回包含所有匹配结果的数组。而 正则表达式 &#x2F;.&#x2F;g 匹配的是所有的字符， 所以str.match(&#x2F;.&#x2F;g)返回的是由字符串str中所有的字符组成的数组，以此达到将字符串转换为数组的目的。 </p><h3 id="str-replace-pattern-replacement"><a href="#str-replace-pattern-replacement" class="headerlink" title="str.replace(pattern, replacement)"></a>str.replace(pattern, replacement)</h3><p>两个参数均为字符串，寻找到模式串替换为后者。</p><h3 id="str-search-regexp"><a href="#str-search-regexp" class="headerlink" title="str.search(regexp)"></a>str.search(regexp)</h3><p>返回 str 中给定正则表达式对应索引</p><h3 id="str-slice-a-b"><a href="#str-slice-a-b" class="headerlink" title="str.slice(a,b)"></a>str.slice(a,b)</h3><p>前包后不包；截取出来的字符串的长度为第二个参数与第一个参数之间的差；若参数值为负数,则将该值加上字符串长度后转为正值；若第一个参数等于大于第二个参数,则返回空字符串.</p><h3 id="str-substring-a-b"><a href="#str-substring-a-b" class="headerlink" title="str.substring(a,b)"></a>str.substring(a,b)</h3><p>前包后不包；若参数值为负数,则将该值转为0;两个参数中,取较小值作为开始位置,截取出来的字符串的长度为较大值与较小值之间的差.</p><h3 id="str-split-separator"><a href="#str-split-separator" class="headerlink" title="str.split(separator)"></a>str.split(separator)</h3><p>分割字符串，返回字符数组</p><h3 id="str-substr-a-length"><a href="#str-substr-a-length" class="headerlink" title="str.substr(a,length)"></a>str.substr(a,length)</h3><p>第一个参数代表开始位置,第二个参数代表截取的长度</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="基础-1"><a href="#基础-1" class="headerlink" title="基础"></a>基础</h3><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> <span class="token function-variable function">avg</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token operator">&lt;=</span><span class="token operator">></span><span class="token keyword">function</span> <span class="token function">avg</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token comment">//js创建函数有两种：一是函数声明function fnName () &#123;…&#125;;，二是函数表达式var fnName = function () &#123;…&#125;;前者因 js 具有 函数声明提升 所以定义在任何位置均可成功调用，而后者必须等到定义语句被解释后才能正常调用(与 var 的变量定义提升不同)</span><span class="token comment">//还有一种匿名函数：function () &#123;…&#125;; 使用function关键字声明一个函数，但未给函数命名，所以叫匿名函数，匿名函数属于函数表达式，匿名函数有很多作用，赋予一个变量则创建函数，赋予一个事件则成为事件处理程序或创建闭包等等。</span>函数表达式后面可以加括号立即调用该函数，<span class="token operator">*</span><span class="token function">函数声明不可以，只能以fnName</span><span class="token punctuation">(</span><span class="token punctuation">)</span>形式调用<span class="token operator">*</span> 存疑，在控制台中调用成功。是因为在函数定义前面加了运算符，比如用括号包裹，把它也转换为了表达式。<span class="token function">总结一下就是当把函数定义为表达式时总能在后面加上括号来立即调用。</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token keyword">var</span> <span class="token function-variable function">a</span><span class="token operator">=</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  三者均能立即调用。</code></pre><p>由 <code>Function</code> 构造函数创建的函数不会创建当前环境的闭包，它们总是被创建于全局环境，因此在运行时它们只能访问全局变量和自己的局部变量，不能访问它们被 <code>Function</code> 构造函数创建时所在的作用域的变量。这一点与使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/eval"><code>eval()</code></a> 执行创建函数的代码不同。</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function">too</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">2</span>    <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token function">too</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 1, not 2</span></code></pre><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">lambda</span> x<span class="token punctuation">:</span> x <span class="token operator">*</span> <span class="token number">8</span>let ans<span class="token operator">=</span>x <span class="token operator">=</span><span class="token operator">></span> x<span class="token operator">*</span><span class="token number">8</span><span class="token punctuation">;</span></code></pre><p>js的&#x3D;&gt;符号类似于lambda</p><pre class="language-none"><code class="language-none">&#x3D;&gt;是es6中的arrow function语法(x) &#x3D;&gt; x + 6相当于function(x)&#123;return x + 6;&#125;;const funcname&#x3D;(args)&#x3D;&gt;&#123;...&#125;函数调用：funcname(args)</code></pre><p>eval()函数，参数是一个字符串。如果字符串表示的是表达式，<code>eval()</code> 会对表达式进行求值。如果参数表示一个或多个 JavaScript 语句，那么<code>eval()</code> 就会执行这些语句。如果 <code>eval()</code> 的参数不是字符串， <code>eval()</code> 会将参数原封不动地返回。</p><p>永远不要使用eval()</p><h3 id="回调"><a href="#回调" class="headerlink" title="回调"></a>回调</h3><p>嵌套函数可以访问父函数作用域中的变量，可以利用这个特性减少全局变量的数量，有效地防止“污染”你的全局命名空间——你可以称它为“局部全局（local global）”。换种思路，把全局当作整体函数，那么就能形成作用域链(scope chain)，嵌套者能访问被嵌套者的变量，反之则不行，寻找变量的定义时总是从当前嵌套层或者说从金字塔的当前区域往外(往下)寻找，就近选择。需要注意的是每个函数的金字塔是不同的，在该函数被定义的时候就已经确定了，所以当在函数内部调用之前已定义的函数时，应当回到那个函数的“金字塔”寻找其所需要的变量，当前函数的作用域不会与产生交集。</p><p>头等函数(first-class functions)，可以当作参数被传递的函数。回调函数(callback)是被作为参数传递的函数，注意是函数作为参数，而非函数返回值作为参数，与其对应的是高阶函数，是使用回调函数的函数。</p><p>回调机制包括三方：起始函数，中间函数，回调函数；起始函数调用中间函数，把回调函数作为参数传递给中间函数。起始函数一般是当前运行的主函数，一般隐藏忽略，主要关注回调函数和把回调函数作为参数的中间函数。</p><p>回调实际上有两种：阻塞式回调和延迟式回调。两者的区别在于：阻塞式回调里，回调函数的调用一定发生在起始函数返回之前；而延迟式回调里，回调函数的调用有可能是在起始函数返回之后。</p><h3 id="call、apply和bind"><a href="#call、apply和bind" class="headerlink" title="call、apply和bind"></a>call、apply和bind</h3><p><code>myfunc(...args)&lt;=&gt;myfunc.apply(null,args)</code>展开语法将数组展开为数组元素。<strong>剩余参数</strong>语法允许我们将一个不定数量的参数表示为一个数组，与展开语法恰恰相反，形式为定义函数时<code>function fun1(...theArgs)&#123;alert(theArgs.length);&#125;</code>。剩余参数也可以被解构为包含变量，形式为<code>function f(...[a, b, c]) &#123;return a + b + c;&#125;</code>. </p><p><code>apply()</code> 的第一个参数应该是一个被当作 <code>this</code> 来看待的对象。于是这里是全局对象。</p><p><code>apply()</code> 有一个姐妹函数，名叫 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/call"><code>call</code></a>，它也可以允许你设置 <code>this</code>，但它带有一个扩展的参数列表而不是一个数组。</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>thisArg<span class="token punctuation">,</span> arg1<span class="token punctuation">,</span> arg2<span class="token punctuation">,</span> <span class="token operator">...</span><span class="token punctuation">)</span></code></pre><p>thisArg是函数执行时的 this 对象。call 实现</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">myCall</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">context<span class="token punctuation">,</span><span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 判断调用对象</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token keyword">this</span> <span class="token operator">!==</span> <span class="token string">"function"</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">"Type error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token comment">// 判断 context 是否传入，如果没有传就设置为 window</span>    context <span class="token operator">=</span> context <span class="token operator">||</span> window<span class="token punctuation">;</span>args <span class="token operator">=</span> args <span class="token operator">?</span> args <span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">const</span> key <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    context<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span><span class="token comment">//通过隐式绑定的方式调用函数</span>    result <span class="token operator">=</span> context<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 删除手动增加的属性方法</span>    <span class="token keyword">delete</span> context<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment">// 将执行结果返回</span>    <span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><p>类似的apply实现</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">myApply</span><span class="token operator">=</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">context<span class="token punctuation">,</span>args</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token keyword">this</span> <span class="token operator">!==</span> <span class="token string">"function"</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">"Type error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    args <span class="token operator">=</span> args <span class="token operator">?</span> args <span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> key <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    context<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token operator">=</span><span class="token keyword">this</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> result <span class="token operator">=</span> context<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">delete</span> context<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>bind先返回一个绑定了this的函数，再次执行则在this中执行</p><pre class="language-none"><code class="language-none">var a &#x3D;&#123;name : &quot;Cherry&quot;,fn : function (a,b) &#123;console.log( a + b)&#125;&#125;var b &#x3D; a.fn;b.bind(a,1,2)()           &#x2F;&#x2F; 3</code></pre><p>bind利用apply实现</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">myBind</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">context<span class="token punctuation">,</span> <span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> fn <span class="token operator">=</span> <span class="token keyword">this</span>    args <span class="token operator">=</span> args <span class="token operator">?</span> args <span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token function">newFn</span><span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>newFnArgs</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token keyword">instanceof</span> <span class="token class-name">newFn</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">fn</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">,</span> <span class="token operator">...</span>newFnArgs<span class="token punctuation">)</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token operator">...</span>args<span class="token punctuation">,</span><span class="token operator">...</span>newFnArgs<span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="函数柯里化"><a href="#函数柯里化" class="headerlink" title="函数柯里化"></a>函数柯里化</h3><p>将接受 <strong>n 个参数的 1 个函数改为只接受一个参数的 n 个互相嵌套的函数</strong>，当前置部分参数一致时，可以通过固定前置参数生成指定函数，简化代码。</p><p>对应偏函数是柯里化的宽松情况，不一定需要每一层都只固定一个参数，继承思想即可。</p><h3 id="函数参数的传递"><a href="#函数参数的传递" class="headerlink" title="函数参数的传递"></a>函数参数的传递</h3><p>有值传递和引用传递，基本类型传递值，引用类型(对象)传递对象的地址，如果在函数中对对象重新赋值，则传递进来的地址改变，即在堆中重新分配一段空间，改变传递进来地址的值指向这个新的地址，不影响原对象。</p><pre class="language-none"><code class="language-none">function changeAgeAndReference(person) &#123;    person.age &#x3D; 25;    person &#x3D; &#123;        name: &quot;John&quot;,        age: 50    &#125;;    return person;&#125;var personObj1 &#x3D; &#123;    name: &quot;Alex&quot;,    age: 30&#125;;var personObj2 &#x3D; changeAgeAndReference(personObj1);console.log(personObj1); &#x2F;&#x2F; -&gt; &#123;name: &#39;Alex&#39;, age: 25&#125;console.log(personObj2); &#x2F;&#x2F; -&gt; &#123;name: &#39;John&#39;, age: 50&#125;</code></pre><p>对对象的重新赋值在任何地方都是如此：在动态堆中重新分配内存空间并赋值，再把原地址的值改为新对象的地址。</p><p>当一个对象没有对应地址指向时，也就是上一段中原对象的情况，这个对象的内存地址会被回收，这是js的垃圾回收机制</p><p>“如果连续五次垃圾回收之后，内存占用一次比一次大，就有内存泄漏。这就要求实时查看内存占用。”避免内存泄漏的要点在于往后不会使用的变量要及时赋空。</p><h2 id="闭包、词法环境-作用域"><a href="#闭包、词法环境-作用域" class="headerlink" title="闭包、词法环境(作用域)"></a>闭包、词法环境(作用域)</h2><p>一个函数和对其周围状态（<strong>lexical environment，词法环境</strong>）的引用捆绑在一起（或者说函数被引用包围），这样的组合就是<strong>闭包</strong>（<strong>closure</strong>）。</p><ul><li>用于保存私有属性：将不需要对外暴露的属性、函数保存在闭包函数的父函数里，避免外部操作对值的干扰</li><li>避免局部属性污染全局变量空间导致的命名空间混乱</li><li>模块化封装，将对立的功能模块通过闭包进去封装，只暴露较少的 API 供外部应用使用</li></ul><p>缺点：内存消耗，由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题。</p><p>c语言退出函数时局部变量也会退出其作用域，所以难以创建闭包；js创建函数时会保留其能访问的变量的地址，这也是创建闭包的前提所在。</p><p>词法环境有两大成员：<strong>「Environment Record（环境记录）」</strong>，可能为 null 的 <strong>「Outer Lexical Environment（外部词法环境引用）」</strong>。<strong>任何在环境记录中的标识符都可以在当前词法环境直接以标识符形式访问</strong>。</p><p>Environment Record 是一个抽象类，存在三个具体的子类，<strong>「Declarative Environment Record」</strong> ，<strong>「Object Environment Record」</strong>，<strong>「Global Environment Record（全局环境记录）」</strong></p><p>声明式环境记录保存 let、const、function 等非 var 声明标识符，对象式环境记录保存 var 声明标识符。 </p><h3 id="对象式环境记录"><a href="#对象式环境记录" class="headerlink" title="对象式环境记录"></a>对象式环境记录</h3><p>对象式记录也是用于记录标识符与变量的映射，但是它只记录var声明的标识符 ； 并且它有一个关联的绑定对象(binding object)。</p><ul><li><p>在词法环境中，会为对象式环境记录中所有的标识符绑定到绑定对象的同名属性上。<br>例如var number&#x3D;1000; , 也能够通过window.number形式获取到number的值。</p></li><li><p>反过来也可以，会将绑定对象的所有属性名（自然也必须是能做标识符的）绑定到对象式环境记录中的同名标识符上。<br>例如：window.thousand &#x3D; 1000; 然后直接以 thousand就能获取到该值（严格模式下报错）</p></li><li><p>每个标识符在绑定后都会直接实例化并初始化为undefined ，如果标识符已经绑定了绑定对象上的原有属性上，那么该变量就是对应属性值 。<br>比如之前的isNaN在声明前使用时就有值，就是这个原因。<br>变量提升也是这个原因造成的。</p></li><li><p>如果标识符已经存在，那么无视之，所以var可以重复声明。</p></li></ul><h3 id="声明式环境记录"><a href="#声明式环境记录" class="headerlink" title="声明式环境记录"></a>声明式环境记录</h3><p>同样的，声明式环境记录也比较特殊，它只记录非var声明的标识符，例如let、const、function……声明的标识符等等。并且它没有关联的绑定对象。</p><ul><li><p>所有声明的标识符（这里应该包含var声明的标识符，但不建立关联）都位于此处。</p></li><li><p>将所有非var声明的标识符实例化，但不初始化，也就是变量处于uninitialized状态。也就是说内存中已经为变量预留出空间，但是还没有和对应的标识符建立绑定关系。</p></li><li><p>在执行上下文的运行（perform状态）阶段，并执行到声明语句时，才会真正初始化并默认赋值为undefined。<br>所以你就懂了，let声明的标识符之前无法访问，就是因为还没有建立绑定。<br>暂存死区的根本原因在此。</p></li><li><p>在声明式环境记录中，<strong>不允许出现重复的标识符</strong>，所以它无法重复。甚至和var声明的标识符冲突。注意，它会在代码加载后的预编译阶段（只能说是运行前，因为JS没有真正的预编译啊……）就已经完成。</p></li></ul><p>全局环境记录包含前两者，是底层记录形式，绑定对象为 window 。</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span>b</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">var</span> t <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> sum <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">let</span> sum <span class="token operator">=</span> a<span class="token operator">+</span>b<span class="token punctuation">;</span>        <span class="token keyword">var</span> mul <span class="token operator">=</span> a<span class="token operator">*</span>b <span class="token operator">+</span>sum<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span>  mul<span class="token operator">*</span>t<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">,</span><span class="token number">30</span><span class="token punctuation">)</span> <span class="token comment">// 6500</span><span class="token comment">//词法环境</span>FunctionEnv <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token literal-property property">This</span><span class="token operator">:</span><span class="token operator">&lt;</span>window<span class="token operator">></span>    <span class="token literal-property property">outerEnv</span><span class="token operator">:</span><span class="token operator">&lt;</span>GlobalEnv<span class="token operator">></span><span class="token punctuation">,</span>    <span class="token literal-property property">ObjRec</span><span class="token operator">:</span><span class="token punctuation">&#123;</span>        <span class="token literal-property property">t</span><span class="token operator">:</span><span class="token operator">&lt;</span><span class="token number">10</span><span class="token operator">></span><span class="token punctuation">,</span>        <span class="token literal-property property">mul</span><span class="token operator">:</span><span class="token operator">&lt;</span><span class="token number">650</span><span class="token operator">></span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token literal-property property">DecRec</span><span class="token operator">:</span><span class="token punctuation">&#123;</span>        <span class="token literal-property property">sum</span><span class="token operator">:</span><span class="token operator">&lt;</span><span class="token number">10</span><span class="token operator">></span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>BlockEnv<span class="token operator">=</span><span class="token punctuation">&#123;</span>    <span class="token literal-property property">This</span><span class="token operator">:</span><span class="token operator">&lt;</span>window<span class="token operator">></span><span class="token punctuation">,</span>    <span class="token literal-property property">outerEnv</span><span class="token operator">:</span><span class="token operator">&lt;</span>FunctionEnv<span class="token operator">></span><span class="token punctuation">,</span>    <span class="token literal-property property">DecRec</span><span class="token operator">:</span><span class="token punctuation">&#123;</span>        <span class="token literal-property property">sum</span><span class="token operator">:</span><span class="token operator">&lt;</span><span class="token number">50</span><span class="token operator">></span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>函数属于声明式环境记录是因为存在块级作用域，var 剥离出的环境记录只有全局作用域和函数作用域。</p><p>声明式对应 LexEnv，对象式对应 VarEnv</p><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p>this和new</p><pre class="language-none"><code class="language-none">this 使用在函数中时被用来指向当前调用函数的对象，也即在对象上使用. or [] 访问属性或者方法时，this就相当于这个对象，如果没有. or []依附对象进行直接访问时，this将指向全局对象（global object），也即访问全局属性&#x2F;变量或者方法&#x2F;函数。Global execution context in scripts:this指全局对象-一个名字叫global的对象Global execution context in modules：this返回undefinednew 创建一个崭新的空对象，然后使用指向那个对象的 this 调用特定的函数，修改this对象的属性。如果你没有使用 new 运算符，构造函数会像其他的常规函数一样被调用，并不会创建一个对象。在这种情况下，this 的指向也是不一样的。</code></pre><p>for … in object 可以遍历对象的所有属性，利用全局对象Object的方法keys可以获得属性名数组，例如有对象实例student，Object.keys(student)为student的所有属性名数组。判断对象是否包含某一属性可以用 in ，’keyName’ in objectName 是bool值。当通过类实例化时，虽然方法可以访问，in也报true，但方法不属于对象本身，而是属于类。</p><p>const objectName&#x3D;{}，引用关系不可变，但引用内容可变，意思是仍然可以为对象分配属性。</p><p>类也是对象。js引擎会自动把常量包装成对象，以能使用对应的对象方法。如length等。</p><p>ES6中在对象中添加方法时可以不写key而是直接像下面这样</p><pre class="language-none"><code class="language-none">objectName&#123;...funcName(args...)&#123;...&#125;...&#125;;same asobjectName&#123;...funcName:function(args...)&#123;...&#125;...&#125;;λ-calculus</code></pre><p>以下写法在ES6中合法</p><pre class="language-none"><code class="language-none">let obj&#x3D;&#123;name:&quot;hh&quot;,age:&quot;13&quot;&#125;let &#123;name,age&#125;&#x3D;obj;</code></pre><p><code>Object.defineProperty(object, property, methods)</code></p><p>第一个参数是一个对象，第二个参数是给该对象设置的属性名称，第三个参数是配置该属性的方法，比如set&#x2F;get方法</p><p>在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象。</p><h2 id="防抖节流"><a href="#防抖节流" class="headerlink" title="防抖节流"></a>防抖节流</h2><p>防抖：多次连续触发只执行一次</p><p>节流：一段时间内连续触发只执行一次，冷却时间过了可以继续</p><pre class="language-vue" data-language="vue"><code class="language-vue">&lt;template&gt;    &lt;div id&#x3D;&quot;content&quot;          style&#x3D;&quot;height:150px;                line-height:150px;                text-align:center;                 color: #fff;background-color:black;                font-size:80px;&quot;&gt;    &lt;&#x2F;div&gt;&lt;&#x2F;template&gt; &lt;script&gt;    let num &#x3D; 1;    const content &#x3D; document.getElementById(&#39;content&#39;);    function count() &#123;        content.innerHTML &#x3D; num++;    &#125;;    content.onmousemove &#x3D; count;&#x2F;&#x2F;防抖 非立即执行版function debunce(func,wait,...args)&#123;        let timeout;        return function()&#123;            const context &#x3D; this;            if(timeout) clearTimeout(timeout);            timeout &#x3D; setTimeout(()&#x3D;&gt;&#123;                func.apply(context,args);            &#125;,wait);        &#125;    &#125;    &#x2F;&#x2F;防抖 立即执行    function debunce(func,wait,...args)&#123;        let timeout;        return function()&#123;            const context &#x3D; this;            let callNow &#x3D; !timeout;            if(timeout) clearTimeout(timeout);            timeout &#x3D; setTimeout(()&#x3D;&gt;&#123;                timeout &#x3D; null;            &#125;,wait)            if(callNow) func.apply(context,args);        &#125;    &#125;        &#x2F;&#x2F;节流 时间戳立即执行    function throttle(func,wait,...args)&#123;        let pre&#x3D;0;        return function()&#123;            const context &#x3D; this;            let now &#x3D; Date.now();            if(now-pre&gt;&#x3D;wait)&#123;                func.apply(context,args);                pre&#x3D;Date.now();            &#125;        &#125;    &#125;    &#x2F;&#x2F;节流 延时器延迟执行    function throttle(func,wait,...args)&#123;        let timeout&#x3D;0;        return function()&#123;            const context &#x3D; this;            if(!timeout)&#123;                timeout&#x3D;setTimeout(()&#x3D;&gt;&#123;                    timeout&#x3D;null;                    func.apply(context,args);                &#125;,wait);            &#125;        &#125;    &#125;&lt;&#x2F;script&gt;</code></pre><h2 id="异步和同步"><a href="#异步和同步" class="headerlink" title="异步和同步"></a>异步和同步</h2><p>异步任务分为宏任务和微任务</p><p><strong>宏任务：</strong>script&#x2F;外层同步代码，定时器<code>setTimeout</code>，<code>setInterval</code>，node中的setImmediate，<code>事件绑定</code>，<code>回调函数</code>，<code>node中的fs模块</code></p><p><strong>微任务：</strong><code>new Promise().then(回调)</code>，<code>process.nextTick()</code>，<code>async await</code>,<code>Object.observe</code>,<code>MutaionObserver</code></p><p>Event Loop的执行顺序是：</p><ol><li>首先执行执行栈里的任务。</li><li>执行栈清空后，检查微任务（microtask）队列，将可执行的微任务全部执行。</li><li>取宏任务（macrotask）队列中的第一项执行。</li><li>回到第二步。</li></ol><p>await后面的函数会先执行一遍，然后就会跳出整个async函数来执行后面js栈（后面会详述）的代码。等本轮事件循环执行完了之后又会跳回到async函数中等待await后面表达式的返回值。</p><pre class="language-none"><code class="language-none">console.log(&quot;script start&quot;);async function async1() &#123;  await async2();  console.log(&quot;async1 end&quot;);&#125;async function async2() &#123;  console.log(&quot;async2 end&quot;);&#125;async1();setTimeout(function () &#123;  console.log(&quot;setTimeout&quot;);&#125;, 0);new Promise((resolve) &#x3D;&gt; &#123;  console.log(&quot;Promise&quot;);  resolve();&#125;)  .then(function () &#123;    console.log(&quot;promise1&quot;);  &#125;)  .then(function () &#123;    console.log(&quot;promise2&quot;);  &#125;);console.log(&quot;script end&quot;);&#x2F;&#x2F; script start &#x3D;&gt; async2 end &#x3D;&gt; Promise &#x3D;&gt; script end &#x3D;&gt; async1 end&#x3D;&gt; promise1 &#x3D;&gt; promise2 &#x3D;&gt; setTimeout</code></pre><p>Promise</p><p>第一段调用了Promise构造函数，第二段是调用了promise实例的.then方法。promise的构造函数是同步执行，promise.then中的函数是异步执行。</p><p>promise实例有三种状态：</p><ul><li>pending（待定）</li><li>fulfilled（已执行）&#x2F;或者也可形象地叫做resolved</li><li>rejected（已拒绝）</li></ul><p>调用resolve和reject能将分别将promise实例的状态变成fulfilled和rejected，只有状态变成已完成（即fulfilled和rejected之一），才能触发状态的回调</p><pre class="language-none"><code class="language-none">let p &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;  &#x2F;&#x2F; 做一些事情  &#x2F;&#x2F; 然后在某些条件下resolve，或者reject  if (&#x2F;* 条件随便写^_^ *&#x2F;) &#123;    resolve()  &#125; else &#123;    reject()  &#125;&#125;)p.then(() &#x3D;&gt; &#123;    &#x2F;&#x2F; 如果p的状态被resolve了，就进入这里&#125;, () &#x3D;&gt; &#123;    &#x2F;&#x2F; 如果p的状态被reject&#125;)</code></pre><ul><li><p>多个 then() 链式调用，<strong>并不是连续的创建了多个微任务并推入微任务队列</strong>，因为 then() 的返回值必然是一个 Promise，而后续的 then() 是上一步 then() 返回的 Promise 的回调</p></li><li><p>按照规范</p><pre class="language-arcade" data-language="arcade"><code class="language-arcade">async function async1()&#123;  console.log(&#39;async1 start&#39;)  await async2()  console.log(&#39;async1 end&#39;)&#125;</code></pre><p>可以转化为：</p><pre class="language-arcade" data-language="arcade"><code class="language-arcade">function async1()&#123;  console.log(&#39;async1 start&#39;)  return RESOLVE(async2())      .then(() &#x3D;&gt; &#123; console.log(&#39;async1 end&#39;) &#125;);&#125;</code></pre></li><li><p><code>RESOLVE(p)</code>接近于<code>Promise.resolve(p)</code>，不过有微妙而重要的区别：p 如果本身已经是 Promise 实例，Promise.resolve 会直接返回 p 而不是产生一个新 promise；</p></li><li><p>如果<code>RESOLVE(p)</code>严格按照标准，应该产生一个新的 promise，尽管该 promise 确定会 resolve 为 p，<strong>但这个过程本身是异步的</strong>，也就是现在进入 job 队列的是<strong>新 promise 的 resolve 过程</strong>，所以该 promise 的 then 不会被立即调用，而要等到当前 job 队列执行到前述 resolve 过程才会被调用，然后其回调（也就是继续 await 之后的语句）才加入 job 队列，所以时序上就晚了</p></li><li><p>所以上述的 async1 函数我们可以进一步转换一下：</p><pre class="language-arcade" data-language="arcade"><code class="language-arcade">function async1()&#123;  console.log(&#39;async1 start&#39;)  return new Promise(resolve &#x3D;&gt; resolve(async2()))    .then(() &#x3D;&gt; &#123;      console.log(&#39;async1 end&#39;)    &#125;);&#125;</code></pre></li></ul><h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><p>JSON对象有两个方法。JSON支持三种类型值：简单值（不包括 undefined ，字符串、数字、null，布尔值均可），对象，数组。也没有分号</p><p>JSON.stringify()</p><p>JSON.parse()</p><h2 id="网络请求和远程资源"><a href="#网络请求和远程资源" class="headerlink" title="网络请求和远程资源"></a>网络请求和远程资源</h2><p>Ajax</p><p>asynchronous JavaScript and XML</p><h3 id="XMLHttpRequest对象-XHR"><a href="#XMLHttpRequest对象-XHR" class="headerlink" title="XMLHttpRequest对象-XHR"></a>XMLHttpRequest对象-XHR</h3><p>XHR对象类型</p><pre class="language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>    <span class="token comment">//XMR方法</span>open<span class="token operator">:</span>function(method<span class="token punctuation">,</span>url<span class="token punctuation">,</span>isAsync)<span class="token punctuation">,</span><span class="token comment">//必须首先使用的方法</span>setRequestHeader<span class="token operator">:</span>function(HeaderKey<span class="token operator">:</span>string<span class="token punctuation">,</span>HeaderValue<span class="token operator">:</span>any)<span class="token comment">//自定义发送头部的信息，必须在open之后，send之前调用此函数。需要区别于浏览器正常发送头部，因为部分浏览器允许重写默认头部，某些则会引起错误</span>send<span class="token operator">:</span>function(arg)<span class="token punctuation">,</span><span class="token comment">//参数为请求体数据，不存在请求体时参数需显示设置为 null</span><span class="token comment">//readyState变化时自动调用此函数</span>onreadystatechange<span class="token operator">:</span>function()<span class="token punctuation">,</span><span class="token comment">//获取响应头部信息</span>getResponseHeaders<span class="token operator">:</span>function(headerKey<span class="token operator">:</span>string)<span class="token punctuation">,</span>getAllResponseHeaders()<span class="token operator">:</span>function()<span class="token punctuation">,</span><span class="token comment">//send 方法执行得到返回内容之后，这些属性会被填充</span>responseType<span class="token operator">:</span><span class="token string">""</span><span class="token punctuation">,</span>responseText<span class="token operator">:</span><span class="token string">"string"</span><span class="token punctuation">,</span><span class="token comment">//响应体文本</span>responseXML<span class="token operator">:</span>XML DOM<span class="token punctuation">,</span><span class="token comment">//响应类型为 text/xml 或者 application/xml 时返回的包含响应式数据的 XML DOM 文档</span>status<span class="token operator">:</span>statusCode<span class="token punctuation">,</span><span class="token comment">//响应HTTP状态码 2xx表示成功，304表示资源未修改，直接从浏览器缓存读取，此两种情况都表示响应有效</span>statusText<span class="token operator">:</span>'description'<span class="token punctuation">,</span><span class="token comment">//HTTP状态描述信息</span><span class="token comment">//状态属性</span>readyState<span class="token operator">:</span><span class="token number">0</span>|<span class="token number">1</span>|<span class="token number">2</span>|<span class="token number">3</span>|<span class="token number">4</span><span class="token punctuation">,</span><span class="token comment">//五种状态，0表示未调用 open 方法，未初始化，1表示已 open 但未 send，2表示 sent 但未收到响应，3表示收到部分响应 receiving ，4表示完成，已收到所有响应 complete。</span><span class="token comment">//收到响应之前可调用此方法终止异步请求，同时应当取消对该XHR对象的引用</span>abort<span class="token operator">:</span>function()<span class="token punctuation">,</span><span class="token punctuation">&#125;</span></code></pre><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//创建XHR对象</span><span class="token keyword">let</span> xhr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XMLHttpRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//使用XMR对象</span><span class="token comment">//首先必须使用open方法，三个参数依次是请求类型：string，请求URL：string，是否异步：Boolean；这里的URL是相对于代码所在的页面的，必须遵守同源策略（同一域名，同一端口，同一协议），否则抛出安全错误。</span>xhr<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">'get'</span><span class="token punctuation">,</span><span class="token string">'example.com'</span><span class="token punctuation">,</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>xhr<span class="token punctuation">.</span><span class="token function">setRequestHeader</span><span class="token punctuation">(</span><span class="token string">'myHaeder'</span><span class="token punctuation">,</span><span class="token string">'myValue'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>xhr<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>send时XHR默认会发送的头部字段：</p><ul><li>Accept 浏览器可以处理的内容类型</li><li>Accept-Charset 浏览器支持显示的字符集</li><li>Accept-Encoding 浏览器可以处理的压缩编码类型</li><li>Accept-Language 浏览器使用的语言</li><li>Connection 浏览器与服务器的连接类型</li><li>Cookie 页面中设置的Cookie</li><li>Host 发送请求的页面所在的域</li><li>Referer 发送请求的页面的 URL ，将错就错，正确拼法是 referre</li><li>User-Agent 浏览器的用户代理字符串</li></ul><h4 id="Get请求"><a href="#Get请求" class="headerlink" title="Get请求"></a>Get请求</h4><p>The <code>encodeURIComponent()</code> method <strong>encodes</strong> a URI component. Use the <a href="https://www.w3schools.com/jsref/jsref_decodeuricomponent.asp">decodeURIComponent()</a> function to <strong>decode</strong> an encoded URI component.</p><h4 id="Post请求"><a href="#Post请求" class="headerlink" title="Post请求"></a>Post请求</h4><h3 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h3><p>跨域资源共享 Cross-origin Resource Share使用场景：</p><ul><li>由 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest"><code>XMLHttpRequest</code></a> 或 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API">Fetch APIs</a> 发起的跨源 HTTP 请求。</li><li>Web 字体 (CSS 中通过 <code>@font-face</code> 使用跨源字体资源)，<a href="https://www.w3.org/TR/css-fonts-3/#font-fetching-requirements">因此，网站就可以发布 TrueType 字体资源，并只允许已授权网站进行跨站调用</a>。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/WebGL_API/Tutorial/Using_textures_in_WebGL">WebGL 贴图</a></li><li>使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/drawImage"><code>drawImage</code></a> 将 Images&#x2F;video 画面绘制到 canvas。</li><li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Shapes/Shapes_From_Images">来自图像的 CSS 图形 (en-US)</a></li></ul><p>跨源资源共享标准新增了一组 HTTP 首部字段，允许服务器声明哪些源站通过浏览器有权限访问哪些资源。另外，规范要求，对那些可能对服务器数据产生副作用的 HTTP 请求方法（特别是 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/GET"><code>GET</code></a> 以外的 HTTP 请求，或者搭配某些 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/MIME_types">MIME 类型</a> 的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/POST"><code>POST</code></a> 请求），浏览器必须首先使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/OPTIONS"><code>OPTIONS</code></a> 方法发起一个预检请求（preflight request），从而获知服务端是否允许该跨源请求。服务器确认允许之后，才发起实际的 HTTP 请求。在预检请求的返回中，服务器端也可以通知客户端，是否需要携带身份凭证（包括 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Cookies">Cookies</a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Authentication">HTTP 认证</a> 相关数据）。</p><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>setInterval();  指每隔多少毫秒执行一次函数。因此它有两个参数，第一个参数为每次执行的函数，第二个参数为毫秒。如setInterval( fn, 16 )，返回值为id，用于标识一个setInterval调用。 </p><p>setTimeout() 方法只运行一次，也就是说当达到设定的时间后就开始运行指定的代码，运行完后就结束了，次数是一次。 setInterval() 是循环执行的，即每达到指定的时间间隔就执行相应的函数或者表达式，只要窗口不关闭或clearInterval() 调用就会无限循环下去。</p><p>date对象，包含一系列获取时间的方法</p><h2 id="Control-abstraction-objects"><a href="#Control-abstraction-objects" class="headerlink" title="Control abstraction objects"></a><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects#control_abstraction_objects">Control abstraction objects</a></h2><p>控制抽象对象</p><ul><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise"><code>Promise</code></a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator"><code>Generator</code></a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/GeneratorFunction"><code>GeneratorFunction</code></a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/AsyncFunction"><code>AsyncFunction</code></a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/AsyncGenerator"><code>AsyncGenerator</code></a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/AsyncGeneratorFunction"><code>AsyncGeneratorFunction</code></a></li></ul><h2 id="Reflection"><a href="#Reflection" class="headerlink" title="Reflection"></a>Reflection</h2><p><strong>Proxy</strong> 对象用于创建一个对象的代理，从而实现基本操作的拦截和自定义（如属性查找、赋值、枚举、函数调用等）。</p><pre class="language-none"><code class="language-none">const p &#x3D; new Proxy(target, handler)handler 包含捕捉器（trap）的占位符对象，可译为处理器对象。traps提供属性访问的方法。这类似于操作系统中捕获器的概念。target被 Proxy 代理虚拟化的对象。它常被作为代理的存储后端。根据目标验证关于对象不可扩展性或不可配置属性的不变量（保持不变的语义）。</code></pre><p><strong><code>Proxy.revocable()</code></strong> 方法可以用来创建一个可撤销的代理对象。细节见<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy/revocable">此处</a>。</p><pre class="language-none"><code class="language-none">Proxy.revocable(target, handler);</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JS&quot;&gt;&lt;a href=&quot;#JS&quot; class=&quot;headerlink&quot; title=&quot;JS&quot;&gt;&lt;/a&gt;JS&lt;/h1&gt;&lt;h2 id=&quot;基础&quot;&gt;&lt;a href=&quot;#基础&quot; class=&quot;headerlink&quot; title=&quot;基础&quot;&gt;&lt;/a&gt;基础&lt;/h2&gt;&lt;pre c</summary>
      
    
    
    
    <category term="常用编程语言基础知识" scheme="https://hhumar.com/categories/%E5%B8%B8%E7%94%A8%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="JavaScript" scheme="https://hhumar.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>回来咯</title>
    <link href="https://hhumar.com/2022/10/25/hello-world/"/>
    <id>https://hhumar.com/2022/10/25/hello-world/</id>
    <published>2022-10-25T07:37:56.643Z</published>
    <updated>2022-10-31T01:54:28.172Z</updated>
    
    <content type="html"><![CDATA[<h2 id="杂谈"><a href="#杂谈" class="headerlink" title="杂谈"></a>杂谈</h2><p>老早之前就建好这个站了，不过嫌弃默认样式太丑又不会自定义，所以就没一直用下去</p><p>这次学了一点前端回来捡起来这个站，当作一个安全的备份记录的地方，希望能早点把真真正正自己写的网站弄出来，暂时把这里当作主要阵地。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;杂谈&quot;&gt;&lt;a href=&quot;#杂谈&quot; class=&quot;headerlink&quot; title=&quot;杂谈&quot;&gt;&lt;/a&gt;杂谈&lt;/h2&gt;&lt;p&gt;老早之前就建好这个站了，不过嫌弃默认样式太丑又不会自定义，所以就没一直用下去&lt;/p&gt;
&lt;p&gt;这次学了一点前端回来捡起来这个站，当作一个安全的</summary>
      
    
    
    
    <category term="生活" scheme="https://hhumar.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
    <category term="first in all" scheme="https://hhumar.com/tags/first-in-all/"/>
    
  </entry>
  
</feed>
